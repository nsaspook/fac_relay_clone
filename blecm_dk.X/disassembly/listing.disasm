Disassembly Listing for blecm_dk
Generated From:
/sdd/work/fac_relay_clone/blecm_dk.X/dist/default/production/blecm_dk.X.production.elf
Oct 25, 2016 3:08:14 PM

---  /sdd/work/fac_relay_clone/uart.c  ------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        uart.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Uart functions
33:                 * 
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdbool.h>
39:                #include <stddef.h>
40:                #include "uart.h"
41:                #include "config.h"
42:                
43:                //UART receive buffer type
44:                
45:                typedef struct {
46:                	volatile uint8_t buffer[SIZE_RxBuffer];
47:                	volatile uint8_t volatile *head;
48:                	volatile uint8_t *tail;
49:                	volatile uint16_t byteCount;
50:                } UART_RX_BUFFER_T;
51:                
52:                //UART transmit buffer type
53:                
54:                typedef struct {
55:                	volatile uint8_t buffer[SIZE_TxBuffer];
56:                	volatile uint8_t *head;
57:                	volatile uint8_t volatile *tail;
58:                	volatile uint16_t byteCount;
59:                } UART_TX_BUFFER_T;
60:                
61:                //Buffer instances
62:                static UART_RX_BUFFER_T rxBuf;
63:                static UART_TX_BUFFER_T txBuf;
64:                
65:                //**********************************************************************************************************************
66:                // Initialize the UART to communicate with the Bluetooth module
67:                
68:                void UART_Init(void)
69:                {
002060  FA0000     LNK #0x0
70:                	rxBuf.tail = &rxBuf.buffer[0]; //Initialize the pointers
002062  208004     MOV #0x800, W4
002064  884814     MOV W4, 0x902
71:                	rxBuf.head = &rxBuf.buffer[0];
002066  208004     MOV #0x800, W4
002068  884804     MOV W4, 0x900
72:                	txBuf.tail = &txBuf.buffer[0];
00206A  209064     MOV #0x906, W4
00206C  885044     MOV W4, 0xA08
73:                	txBuf.head = &txBuf.buffer[0];
00206E  209064     MOV #0x906, W4
002070  885034     MOV W4, 0xA06
74:                	txBuf.byteCount = rxBuf.byteCount = 0;
002072  EB0200     CLR W4
002074  884824     MOV W4, 0x904
002076  804824     MOV 0x904, W4
002078  885054     MOV W4, 0xA0A
75:                
76:                	U1BRG = 34; //Baud rate 115,200 - actually 115,384 baud 0.16% error
00207A  200224     MOV #0x22, W4
00207C  881144     MOV W4, U1BRG
77:                	U1MODE = 0x8008; //Enable UART, no flow control, BRGH = 1 for high speed baud mode
00207E  280084     MOV #0x8008, W4
002080  881104     MOV W4, U1MODE
78:                	U1STA = 0x0400; //Enable transmit
002082  204004     MOV #0x400, W4
002084  881114     MOV W4, U1STA
79:                	UART_RX_IF = 0; //Clear UART interrupt flags
002086  A96085     BCLR 0x85, #3
80:                	UART_ER_IF = 0;
002088  A9208C     BCLR IFS4, #1
81:                	UART_RX_IE = 1; //Enable UART Receive and Error interrupt
00208A  A86095     BSET 0x95, #3
82:                	UART_ER_IE = 1;
00208C  A8209C     BSET IEC4, #1
83:                }
00208E  FA8000     ULNK
002090  060000     RETURN
84:                
85:                //**********************************************************************************************************************
86:                // Start transmission by enabling the UART transmit interrupt
87:                
88:                inline void UART_TxStart(void)
89:                {
002092  FA0000     LNK #0x0
90:                	UART_TX_IE = 1; //Enable transmit interrupts
002094  A88095     BSET 0x95, #4
91:                }
002096  FA8000     ULNK
002098  060000     RETURN
92:                
93:                //**********************************************************************************************************************
94:                // See if there are one or more bytes in the receive buffer
95:                
96:                bool UART_IsNewRxData(void)
97:                {
00209A  FA0000     LNK #0x0
98:                	__builtin_disi(0x3FFF); //disable interrupts
00209C  FC3FFF     DISI #0x3FFF
99:                	if (rxBuf.byteCount == 0) { //Check if data in buffer
00209E  804824     MOV 0x904, W4
0020A0  520FE0     SUB W4, #0x0, [W15]
0020A2  3A0003     BRA NZ, 0x20AA
100:               		__builtin_disi(0); //enable interrupts
0020A4  FC0000     DISI #0x0
101:               		return(false); //No bytes in the buffer so return false
0020A6  EB4200     CLR.B W4
0020A8  370002     BRA 0x20AE
102:               	}
103:               	__builtin_disi(0); //enable interrupts
0020AA  FC0000     DISI #0x0
104:               	return(true); //There are bytes in the buffer
0020AC  B3C014     MOV.B #0x1, W4
105:               }
0020AE  784004     MOV.B W4, W0
0020B0  FA8000     ULNK
0020B2  060000     RETURN
106:               
107:               //**********************************************************************************************************************
108:               // Read a byte from the receive buffer
109:               
110:               uint8_t UART_ReadRxBuffer(void)
111:               {
0020B4  FA0002     LNK #0x2
112:               	uint8_t Temp;
113:               
114:               	__builtin_disi(0x3FFF); //disable interrupts
0020B6  FC3FFF     DISI #0x3FFF
115:               	if (rxBuf.byteCount == 0) { //For safety, do not allow read of empty buffer
0020B8  804824     MOV 0x904, W4
0020BA  520FE0     SUB W4, #0x0, [W15]
0020BC  3A0003     BRA NZ, 0x20C4
116:               		__builtin_disi(0); //enable interrupts
0020BE  FC0000     DISI #0x0
117:               		return(0); //Return zero if there is nothing in the buffer
0020C0  EB4200     CLR.B W4
0020C2  37000F     BRA 0x20E2
118:               	}
119:               
120:               	rxBuf.byteCount--; //Decrement byte count
0020C4  804824     MOV 0x904, W4
0020C6  E90204     DEC W4, W4
0020C8  884824     MOV W4, 0x904
121:               	__builtin_disi(0); //enable interrupts
0020CA  FC0000     DISI #0x0
122:               	Temp = *rxBuf.tail++; //Get the byte and increment the pointer
0020CC  804814     MOV 0x902, W4
0020CE  784F14     MOV.B [W4], [W14]
0020D0  E80204     INC W4, W4
0020D2  884814     MOV W4, 0x902
123:               	if (rxBuf.tail > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if at end of buffer
0020D4  804815     MOV 0x902, W5
0020D6  208FF4     MOV #0x8FF, W4
0020D8  528F84     SUB W5, W4, [W15]
0020DA  360002     BRA LEU, 0x20E0
124:               		rxBuf.tail = &rxBuf.buffer[0]; //then wrap the pointer to beginning
0020DC  208004     MOV #0x800, W4
0020DE  884814     MOV W4, 0x902
125:               	}
126:               	return(Temp);
0020E0  78421E     MOV.B [W14], W4
127:               }
0020E2  784004     MOV.B W4, W0
0020E4  FA8000     ULNK
0020E6  060000     RETURN
128:               
129:               //**********************************************************************************************************************
130:               // Write a byte to the transmit buffer
131:               
132:               void UART_WriteTxBuffer(const uint8_t TxByte)
133:               {
0020E8  FA0002     LNK #0x2
0020EA  784F00     MOV.B W0, [W14]
134:               	*txBuf.head++ = TxByte; //Put the byte in the transmit buffer and increment the pointer
0020EC  805034     MOV 0xA06, W4
0020EE  784A1E     MOV.B [W14], [W4]
0020F0  E80204     INC W4, W4
0020F2  885034     MOV W4, 0xA06
135:               	if (txBuf.head > &txBuf.buffer[SIZE_TxBuffer - 1]) { //Check if at end of buffer
0020F4  805035     MOV 0xA06, W5
0020F6  20A054     MOV #0xA05, W4
0020F8  528F84     SUB W5, W4, [W15]
0020FA  360002     BRA LEU, 0x2100
136:               		txBuf.head = &txBuf.buffer[0]; //Wrap pointer to beginning
0020FC  209064     MOV #0x906, W4
0020FE  885034     MOV W4, 0xA06
137:               	}
138:               	__builtin_disi(0x3FFF); //disable interrupts
002100  FC3FFF     DISI #0x3FFF
139:               	if (txBuf.byteCount < SIZE_TxBuffer) { //Increment byte count
002102  805055     MOV 0xA0A, W5
002104  200FF4     MOV #0xFF, W4
002106  528F84     SUB W5, W4, [W15]
002108  3E0003     BRA GTU, 0x2110
140:               		txBuf.byteCount++;
00210A  805054     MOV 0xA0A, W4
00210C  E80204     INC W4, W4
00210E  885054     MOV W4, 0xA0A
141:               	}
142:               	__builtin_disi(0); //enable interrupts
002110  FC0000     DISI #0x0
143:               }
002112  FA8000     ULNK
002114  060000     RETURN
144:               
145:               //**********************************************************************************************************************
146:               // Return the number of bytes free in the TX buffer
147:               
148:               uint16_t UART_GetTXBufferFreeSpace(void)
149:               {
002116  FA0002     LNK #0x2
150:               	uint16_t space;
151:               
152:               	__builtin_disi(0x3FFF); //disable interrupts            
002118  FC3FFF     DISI #0x3FFF
153:               	space = SIZE_TxBuffer - txBuf.byteCount;
00211A  805054     MOV 0xA0A, W4
00211C  201005     MOV #0x100, W5
00211E  528F04     SUB W5, W4, [W14]
154:               	__builtin_disi(0); //enable interrupts
002120  FC0000     DISI #0x0
155:               	return space;
002122  78021E     MOV [W14], W4
156:               }
002124  780004     MOV W4, W0
002126  FA8000     ULNK
002128  060000     RETURN
157:               
158:               //Peek at buffer tail
159:               
160:               uint8_t UART_PeekRxBuffer(void)
161:               {
00212A  FA0000     LNK #0x0
162:               	__builtin_disi(0x3FFF); //disable interrupts
00212C  FC3FFF     DISI #0x3FFF
163:               	if (rxBuf.byteCount == 0) { //Check if pointers are the same
00212E  804824     MOV 0x904, W4
002130  520FE0     SUB W4, #0x0, [W15]
002132  3A0003     BRA NZ, 0x213A
164:               		__builtin_disi(0); //enable interrupts
002134  FC0000     DISI #0x0
165:               		return(NULL); //No bytes in the buffer so return NULL
002136  EB4200     CLR.B W4
002138  370003     BRA 0x2140
166:               	} else {
167:               		__builtin_disi(0); //enable interrupts
00213A  FC0000     DISI #0x0
168:               		return *rxBuf.tail;
00213C  804814     MOV 0x902, W4
00213E  784214     MOV.B [W4], W4
169:               	}
170:               }
002140  784004     MOV.B W4, W0
002142  FA8000     ULNK
002144  060000     RETURN
171:               
172:               //**********************************************************************************************************************
173:               // Interrupt routine for UART receive interrupts
174:               
175:               void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt(void)
176:               {
002146  781F80     MOV W0, [W15++]
002148  BE9F84     MOV.D W4, [W15++]
00214A  FA0000     LNK #0x0
177:               	UART_RX_IF = 0; //Clear UART Receive interrupt flag
00214C  A96085     BCLR 0x85, #3
178:               	*rxBuf.head++ = UART_RX_BUF; //Put received byte in the buffer
00214E  804805     MOV 0x900, W5
002150  801134     MOV U1RXREG, W4
002152  784204     MOV.B W4, W4
002154  784A84     MOV.B W4, [W5]
002156  E80205     INC W5, W4
002158  884804     MOV W4, 0x900
179:               	if (rxBuf.head > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if end of buffer
00215A  804805     MOV 0x900, W5
00215C  208FF4     MOV #0x8FF, W4
00215E  528F84     SUB W5, W4, [W15]
002160  360002     BRA LEU, 0x2166
180:               		rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
002162  208004     MOV #0x800, W4
002164  884804     MOV W4, 0x900
181:               	}
182:               	if (rxBuf.byteCount < SIZE_RxBuffer) { //Increment byte count
002166  804825     MOV 0x904, W5
002168  200FF4     MOV #0xFF, W4
00216A  528F84     SUB W5, W4, [W15]
00216C  3E0003     BRA GTU, 0x2174
183:               		rxBuf.byteCount++;
00216E  804824     MOV 0x904, W4
002170  E80204     INC W4, W4
002172  884824     MOV W4, 0x904
184:               	}
185:               }
002174  FA8000     ULNK
002176  BE024F     MOV.D [--W15], W4
002178  78004F     MOV [--W15], W0
00217A  064000     RETFIE
186:               
187:               //**********************************************************************************************************************
188:               // Interrupt routine for UART transmit interrupts
189:               
190:               void __attribute__((interrupt, no_auto_psv)) _U1TXInterrupt(void)
191:               {
00217C  781F80     MOV W0, [W15++]
00217E  BE9F84     MOV.D W4, [W15++]
002180  FA0000     LNK #0x0
192:               	if (txBuf.byteCount > 0) //Check if more data is in the buffer
002182  805054     MOV 0xA0A, W4
002184  520FE0     SUB W4, #0x0, [W15]
002186  320016     BRA Z, 0x21B4
193:               	{
194:               		//Only do anything if hardware buffer has space
195:               		if (!UART_FULL) {
002188  801115     MOV U1STA, W5
00218A  202004     MOV #0x200, W4
00218C  628204     AND W5, W4, W4
00218E  520FE0     SUB W4, #0x0, [W15]
002190  3A0012     BRA NZ, 0x21B6
196:               			UART_TX_IF = 0; //Clear UART 1 TX interrupt flag
002192  A98085     BCLR 0x85, #4
197:               			UART_TX_BUF = *txBuf.tail++; //Load next byte into the TX buffer
002194  805045     MOV 0xA08, W5
002196  784215     MOV.B [W5], W4
002198  FB8204     ZE W4, W4
00219A  881124     MOV W4, U1TXREG
00219C  E80205     INC W5, W4
00219E  885044     MOV W4, 0xA08
198:               			if (txBuf.tail > &txBuf.buffer[SIZE_TxBuffer - 1]) { //Check if end of buffer
0021A0  805045     MOV 0xA08, W5
0021A2  20A054     MOV #0xA05, W4
0021A4  528F84     SUB W5, W4, [W15]
0021A6  360002     BRA LEU, 0x21AC
199:               				txBuf.tail = &txBuf.buffer[0]; //Wrap pointer to beginning
0021A8  209064     MOV #0x906, W4
0021AA  885044     MOV W4, 0xA08
200:               			}
201:               			txBuf.byteCount--; //Decrement byte count
0021AC  805054     MOV 0xA0A, W4
0021AE  E90204     DEC W4, W4
0021B0  885054     MOV W4, 0xA0A
0021B2  370001     BRA 0x21B6
202:               		}
203:               	} else {
204:               		UART_TX_IE = 0; //No more data to transmit, so stop interrupts
0021B4  A98095     BCLR 0x95, #4
205:               	}
206:               }
0021B6  FA8000     ULNK
0021B8  BE024F     MOV.D [--W15], W4
0021BA  78004F     MOV [--W15], W0
0021BC  064000     RETFIE
207:               
208:               //**********************************************************************************************************************
209:               // Interrupt routine for UART error interrupts
210:               
211:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void)
212:               {
0021BE  781F80     MOV W0, [W15++]
0021C0  BE9F84     MOV.D W4, [W15++]
0021C2  FA0000     LNK #0x0
213:               	IFS4bits.U1ERIF = 0; //Clear interrupt flag
0021C4  A9208C     BCLR IFS4, #1
214:               
215:               	//Handle an overflow error by reading next byte and clearing flag
216:               	if (U1STAbits.OERR == 1) {
0021C6  801114     MOV U1STA, W4
0021C8  620262     AND W4, #0x2, W4
0021CA  520FE0     SUB W4, #0x0, [W15]
0021CC  320014     BRA Z, 0x21F6
217:               		*rxBuf.head++ = UART_RX_BUF; //Put received byte in the buffer
0021CE  804805     MOV 0x900, W5
0021D0  801134     MOV U1RXREG, W4
0021D2  784204     MOV.B W4, W4
0021D4  784A84     MOV.B W4, [W5]
0021D6  E80205     INC W5, W4
0021D8  884804     MOV W4, 0x900
218:               		if (rxBuf.head > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if end of buffer
0021DA  804805     MOV 0x900, W5
0021DC  208FF4     MOV #0x8FF, W4
0021DE  528F84     SUB W5, W4, [W15]
0021E0  360002     BRA LEU, 0x21E6
219:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
0021E2  208004     MOV #0x800, W4
0021E4  884804     MOV W4, 0x900
220:               		}
221:               		if (rxBuf.byteCount < SIZE_RxBuffer) { //Increment byte count
0021E6  804825     MOV 0x904, W5
0021E8  200FF4     MOV #0xFF, W4
0021EA  528F84     SUB W5, W4, [W15]
0021EC  3E0003     BRA GTU, 0x21F4
222:               			rxBuf.byteCount++;
0021EE  804824     MOV 0x904, W4
0021F0  E80204     INC W4, W4
0021F2  884824     MOV W4, 0x904
223:               		}
224:               		U1STAbits.OERR = 0;
0021F4  A92222     BCLR U1STA, #1
225:               	}
226:               
227:               	//Clear any other error bits
228:               	U1STAbits.FERR = 0;
0021F6  A94222     BCLR U1STA, #2
229:               	U1STAbits.PERR = 0;
0021F8  A96222     BCLR U1STA, #3
230:               }
0021FA  FA8000     ULNK
0021FC  BE024F     MOV.D [--W15], W4
0021FE  78004F     MOV [--W15], W0
002200  064000     RETFIE
---  /sdd/work/fac_relay_clone/timers.c  ----------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        timers.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Timer functions
33:                 *
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdbool.h>
39:                #include "config.h"
40:                #include "timers.h"
41:                #include "app.h"
42:                
43:                extern APP_DATA appData;
44:                
45:                static volatile uint16_t tickCount[TMR_COUNT] = {0};
46:                
47:                //**********************************************************************************************************************
48:                // Initialize the timers
49:                
50:                void Timers_Init(void)
51:                {
002402  FA0000     LNK #0x0
52:                	//Timer 5 is used for interrupt based software timers counting 1ms intervals to a resolution of 500us
53:                	T1CON = TIMER_OFF; //Timer 5 off
002404  EB0200     CLR W4
002406  880824     MOV W4, T1CON
54:                	TMR1 = 0; //Clear timer 5
002408  EB0200     CLR W4
00240A  880804     MOV W4, TMR1
55:                	PR1 = TIMER_500US_PERIOD; //Set the period value for 500us
00240C  207CF4     MOV #0x7CF, W4
00240E  880814     MOV W4, PR1
56:                	T1CON |= TIMER_ON_PRESCALE1; //using 1:1 prescaler and turn on timer 5
002410  800825     MOV T1CON, W5
002412  280004     MOV #0x8000, W4
002414  720205     IOR W4, W5, W4
002416  880824     MOV W4, T1CON
57:                	IFS0bits.T1IF = 0; //Clear the interrupt flag
002418  A96084     BCLR IFS0, #3
58:                	IEC0bits.T1IE = 1; //Enable the timer 5 interrupt
00241A  A86094     BSET IEC0, #3
59:                
60:                #ifdef USE_SLEEP                //see config.h, Application setting section
61:                	//Timer 2/3 is used in 32-bit mode as inactivity timer to trigger sleep mode
62:                	T2CON = TIMER_OFF; //Timer 3 off
63:                	TMR3 = 0; //Clear timer 3
64:                	TMR2 = 0; //Clear timer 2
65:                	T2CONbits.T32 = 1; //Enable 32-bit mode
66:                	PR3 = (uint16_t) (SLEEP_TIME >> 16); //Set the period value - msw
67:                	PR2 = (uint16_t) (SLEEP_TIME | 0x0000FFFF); //lsw
68:                	T2CON |= TIMER_ON_PRESCALE256; //using 1:256 prescaler and turn on timer 3
69:                	IFS0bits.T3IF = 0; //Clear the interrupt flag
70:                	IEC0bits.T3IE = 1; //Enable the timer 3 interrupt
71:                
72:                #ifndef SLEEP_MODE_RTCC         //we'll be using Timer 1 for periodic wakeup
73:                	T1CON = 0x0000; //Timer 1 off
74:                	T1CONbits.T1ECS = 0b10; //Clock source LPRC
75:                	T1CONbits.TCS = 1;
76:                	T1CONbits.TCKPS = 0b11; //using 1:256 prescaler
77:                	TMR1 = 0; //Clear timer 1
78:                	PR1 = T1_SLEEP_PERIOD; //Set the period for sleep
79:                	IFS0bits.T1IF = 0; //Clear the interrupt flag
80:                	IEC0bits.T1IE = 1; //Enable the timer 1 interrupt
81:                #endif //not SLEEP_MODE_RTCC    
82:                #endif //USE_SLEEP
83:                }
00241C  FA8000     ULNK
00241E  060000     RETURN
84:                
85:                //**********************************************************************************************************************
86:                // Start one of the software timers
87:                
88:                inline void StartTimer(uint8_t timer, uint16_t count)
89:                {
002420  FA0004     LNK #0x4
002422  784F00     MOV.B W0, [W14]
002424  980711     MOV W1, [W14+2]
90:                	tickCount[timer] = count << 1; //Interrupt is every 500us but StartTimer() takes multiple of 1ms so multiply by 2
002426  78429E     MOV.B [W14], W5
002428  FB8205     ZE W5, W4
00242A  90029E     MOV [W14+2], W5
00242C  428285     ADD W5, W5, W5
00242E  420304     ADD W4, W4, W6
002430  20AF44     MOV #0xAF4, W4
002432  430204     ADD W6, W4, W4
002434  780A05     MOV W5, [W4]
91:                }
002436  FA8000     ULNK
002438  060000     RETURN
92:                
93:                //**********************************************************************************************************************
94:                // Check if one of the software software timers has timed out
95:                
96:                inline bool TimerDone(uint8_t timer)
97:                {
00243A  FA0002     LNK #0x2
00243C  784F00     MOV.B W0, [W14]
98:                	if (tickCount[timer] == 0) { //Check if counted down to zero
00243E  78429E     MOV.B [W14], W5
002440  FB8205     ZE W5, W4
002442  420284     ADD W4, W4, W5
002444  20AF44     MOV #0xAF4, W4
002446  428204     ADD W5, W4, W4
002448  780214     MOV [W4], W4
00244A  520FE0     SUB W4, #0x0, [W15]
00244C  3A0002     BRA NZ, 0x2452
99:                		return true; //then return true
00244E  B3C014     MOV.B #0x1, W4
002450  370001     BRA 0x2454
100:               	}
101:               	return false; //else return false
002452  EB4200     CLR.B W4
102:               }
002454  784004     MOV.B W4, W0
002456  FA8000     ULNK
002458  060000     RETURN
103:               
104:               //**********************************************************************************************************************
105:               // Simple delay for n milliseconds (blocking)
106:               
107:               void WaitMs(uint16_t numMilliseconds)
108:               {
00245A  FA0002     LNK #0x2
00245C  780F00     MOV W0, [W14]
109:               	StartTimer(TMR_INTERNAL, numMilliseconds); //Start software timer and wait for it to count down
00245E  78009E     MOV [W14], W1
002460  EB4000     CLR.B W0
002462  07FFDE     RCALL StartTimer
110:               	while (!TimerDone(TMR_INTERNAL)) {
002464  370001     BRA 0x2468
002468  EB4000     CLR.B W0
00246A  07FFE7     RCALL TimerDone
00246C  784200     MOV.B W0, W4
00246E  A20404     BTG.B W4, #0
002470  524FE0     SUB.B W4, #0x0, [W15]
002472  3AFFF9     BRA NZ, 0x2466
111:               		Idle();
002466  FE4001     PWRSAV #1
112:               	} //Enter idle mode to reduce power while waiting
113:               } //(timer interrupt will wake part from idle)
002474  FA8000     ULNK
002476  060000     RETURN
114:               
115:               #ifdef USE_SLEEP                //see config.h, Application setting section
116:               //Reset the inactivity sleep timer
117:               
118:               inline void SleepTimerReset(void)
119:               {
120:               	TMR3 = 0; //Clear timer 3
121:               	TMR2 = 0; //Clear timer 2
122:               }
123:               #endif
124:               
125:               //**********************************************************************************************************************
126:               // Timer 1 interrupt routine - software timers
127:               
128:               void _ISR_NO_AUTO_PSV _T1Interrupt(void)
129:               {
002478  781F80     MOV W0, [W15++]
00247A  BE9F84     MOV.D W4, [W15++]
00247C  781F86     MOV W6, [W15++]
00247E  FA0002     LNK #0x2
130:               	uint8_t i;
131:               
132:               	LATAbits.LATA0 = 1;
002480  A802C4     BSET LATA, #0
133:               	IFS0bits.T1IF = 0; //Clear the interrupt flag
002482  A96084     BCLR IFS0, #3
134:               	//Decrement each software timer
135:               	for (i = 0; i < TMR_COUNT; i++) {
002484  EB4200     CLR.B W4
002486  784F04     MOV.B W4, [W14]
002488  370014     BRA 0x24B2
0024B0  E84F1E     INC.B [W14], [W14]
0024B2  78421E     MOV.B [W14], W4
0024B4  524FEA     SUB.B W4, #0xA, [W15]
0024B6  36FFE9     BRA LEU, 0x248A
136:               		if (tickCount[i] != 0) {
00248A  78429E     MOV.B [W14], W5
00248C  FB8205     ZE W5, W4
00248E  420284     ADD W4, W4, W5
002490  20AF44     MOV #0xAF4, W4
002492  428204     ADD W5, W4, W4
002494  780214     MOV [W4], W4
002496  520FE0     SUB W4, #0x0, [W15]
002498  32000B     BRA Z, 0x24B0
137:               			tickCount[i]--;
00249A  78429E     MOV.B [W14], W5
00249C  FB8205     ZE W5, W4
00249E  420304     ADD W4, W4, W6
0024A0  20AF45     MOV #0xAF4, W5
0024A2  430285     ADD W6, W5, W5
0024A4  780295     MOV [W5], W5
0024A6  E90285     DEC W5, W5
0024A8  420304     ADD W4, W4, W6
0024AA  20AF44     MOV #0xAF4, W4
0024AC  430204     ADD W6, W4, W4
0024AE  780A05     MOV W5, [W4]
138:               		}
139:               	}
140:               	LATAbits.LATA0 = 0;
0024B8  A902C4     BCLR LATA, #0
141:               }
0024BA  FA8000     ULNK
0024BC  78034F     MOV [--W15], W6
0024BE  BE024F     MOV.D [--W15], W4
0024C0  78004F     MOV [--W15], W0
0024C2  064000     RETFIE
142:               
143:               #ifdef USE_SLEEP                //see config.h, Application setting section
144:               //**********************************************************************************************************************
145:               // Timer 3 interrupt routine - inactivity timer
146:               
147:               void _ISR_NO_AUTO_PSV _T3Interrupt(void)
148:               {
149:               	IFS0bits.T3IF = 0; //Clear the interrupt flag    
150:               	appData.sleepFlag = true;
151:               }
152:               #ifndef SLEEP_MODE_RTCC
153:               //**********************************************************************************************************************
154:               // Timer 1 interrupt routine - periodic wakeup timer
155:               
156:               void _ISR_NO_AUTO_PSV _T1Interrupt(void)
157:               {
158:               	IFS0bits.T1IF = 0; //Clear the interrupt flag
159:               	appData.timer1Flag = true;
160:               }
161:               #endif //not SLEEP_MODE_RTCC
162:               #endif //USE_SLEEP
---  /sdd/work/fac_relay_clone/switches.c  --------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2015 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        switches.c
29:                 * Date:        September 17, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 *
33:                 */
34:                
35:                #include <xc.h>
36:                #include "app.h"
37:                #include "config.h"
38:                #include "timers.h"
39:                
40:                extern APP_DATA appData;
41:                
42:                //Switches state machine
43:                
44:                void Switch_Tasks(void)
45:                {
0024C4  FA0000     LNK #0x0
46:                	//Check if switches have changed and debounce timers are expired
47:                	if (appData.sw1Changed && TimerDone(TMR_SW1_DEBOUNCE)) {
0024C6  20AE44     MOV #0xAE4, W4
0024C8  784214     MOV.B [W4], W4
0024CA  524FE0     SUB.B W4, #0x0, [W15]
0024CC  32000D     BRA Z, 0x24E8
0024CE  B3C050     MOV.B #0x5, W0
0024D0  07FFB4     RCALL TimerDone
0024D2  784200     MOV.B W0, W4
0024D4  524FE0     SUB.B W4, #0x0, [W15]
0024D6  320008     BRA Z, 0x24E8
48:                
49:                		appData.sw1Changed = false; //clear individual flag
0024D8  EB4200     CLR.B W4
0024DA  FD0200     EXCH W0, W4
0024DC  B7EAE4     MOV.B WREG, 0xAE4
0024DE  FD0200     EXCH W0, W4
50:                		appData.sendSwitches = true; //set group flag to request TX
0024E0  B3C014     MOV.B #0x1, W4
0024E2  FD0200     EXCH W0, W4
0024E4  B7EAD7     MOV.B WREG, 0xAD7
0024E6  FD0200     EXCH W0, W4
51:                	}
52:                	if (appData.sw2Changed && TimerDone(TMR_SW2_DEBOUNCE)) {
0024E8  20AE54     MOV #0xAE5, W4
0024EA  784214     MOV.B [W4], W4
0024EC  524FE0     SUB.B W4, #0x0, [W15]
0024EE  32000D     BRA Z, 0x250A
0024F0  B3C060     MOV.B #0x6, W0
0024F2  07FFA3     RCALL TimerDone
0024F4  784200     MOV.B W0, W4
0024F6  524FE0     SUB.B W4, #0x0, [W15]
0024F8  320008     BRA Z, 0x250A
53:                
54:                		appData.sw2Changed = false;
0024FA  EB4200     CLR.B W4
0024FC  FD0200     EXCH W0, W4
0024FE  B7EAE5     MOV.B WREG, 0xAE5
002500  FD0200     EXCH W0, W4
55:                		appData.sendSwitches = true;
002502  B3C014     MOV.B #0x1, W4
002504  FD0200     EXCH W0, W4
002506  B7EAD7     MOV.B WREG, 0xAD7
002508  FD0200     EXCH W0, W4
56:                	}
57:                	if (appData.sw3Changed && TimerDone(TMR_SW3_DEBOUNCE)) {
00250A  20AE64     MOV #0xAE6, W4
00250C  784214     MOV.B [W4], W4
00250E  524FE0     SUB.B W4, #0x0, [W15]
002510  32000D     BRA Z, 0x252C
002512  B3C070     MOV.B #0x7, W0
002514  07FF92     RCALL TimerDone
002516  784200     MOV.B W0, W4
002518  524FE0     SUB.B W4, #0x0, [W15]
00251A  320008     BRA Z, 0x252C
58:                
59:                		appData.sw3Changed = false;
00251C  EB4200     CLR.B W4
00251E  FD0200     EXCH W0, W4
002520  B7EAE6     MOV.B WREG, 0xAE6
002522  FD0200     EXCH W0, W4
60:                		appData.sendSwitches = true;
002524  B3C014     MOV.B #0x1, W4
002526  FD0200     EXCH W0, W4
002528  B7EAD7     MOV.B WREG, 0xAD7
00252A  FD0200     EXCH W0, W4
61:                	}
62:                	if (appData.sw4Changed && TimerDone(TMR_SW4_DEBOUNCE)) {
00252C  20AE74     MOV #0xAE7, W4
00252E  784214     MOV.B [W4], W4
002530  524FE0     SUB.B W4, #0x0, [W15]
002532  32000B     BRA Z, 0x254A
002534  B3C080     MOV.B #0x8, W0
002536  07FF81     RCALL TimerDone
002538  784200     MOV.B W0, W4
00253A  524FE0     SUB.B W4, #0x0, [W15]
00253C  320006     BRA Z, 0x254A
63:                
64:                		appData.sw4Changed = false;
00253E  EB4200     CLR.B W4
002540  780004     MOV W4, W0
002542  B7EAE7     MOV.B WREG, 0xAE7
65:                		appData.sendSwitches = true;
002544  B3C014     MOV.B #0x1, W4
002546  780004     MOV W4, W0
002548  B7EAD7     MOV.B WREG, 0xAD7
66:                	}
67:                }
00254A  FA8000     ULNK
00254C  060000     RETURN
68:                
69:                //Change notification interrupt
70:                //Process and start debounce timers for switch changes
71:                //The switches are well debounced in hardware
72:                //Adding the software debounce limits unneeded switch update messages
73:                //and groups together multiple switch presses that occur within the debounce period
74:                
75:                void _ISR_NO_AUTO_PSV _CNInterrupt(void)
76:                {
00254E  781F80     MOV W0, [W15++]
002550  FA0000     LNK #0x0
77:                	IFS1bits.CNIF = 0; //Clear IF
002552  A96086     BCLR IFS1, #3
78:                
79:                #ifdef USE_SLEEP                //see config.h, Application setting section
80:                	appData.CNint = true;
81:                	SleepTimerReset(); //Reset the inactivity sleep timer
82:                #endif
83:                
84:                }
002554  FA8000     ULNK
002556  78004F     MOV [--W15], W0
002558  064000     RETFIE
---  /sdd/work/fac_relay_clone/main.c  ------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        main.c
29:                 * Date:        July 24, 2014
30:                 * Compiler:    XC16 v1.23
31:                 * 
32:                 * Remote Relay mods Oct 2016 FGB@MCHP
33:                 * 
34:                 * 	// RELAYs are outputs and open-drain
35:                	// to drive ILQ2 opto
36:                	// setup in Mikrobus header
37:                	ODCDbits.ODD3 = 1; // pin 16 PWM
38:                	ODCDbits.ODD9 = 1; // pin 11 SDA
39:                	ODCDbits.ODD10 = 1; // pin 12 SCL
40:                	ODCDbits.ODD4 = 1; // pin 2 RST
41:                 *
42:                 */
43:                
44:                #include <xc.h>
45:                #include <stdint.h>
46:                #include "app.h"
47:                #include "config.h"
48:                
49:                void initBoard(void);
50:                
51:                // PIC24FV16KM202 Configuration Bit Settings
52:                
53:                // 'C' source line config statements
54:                
55:                // FBS
56:                
57:                #pragma config BWRP = OFF               // Boot Segment Write Protect (Disabled)
58:                #pragma config BSS = OFF                // Boot segment Protect (No boot program flash segment)
59:                
60:                // FGS
61:                #pragma config GWRP = OFF               // General Segment Write Protect (General segment may be written)
62:                #pragma config GCP = OFF                // General Segment Code Protect (No Protection)
63:                
64:                // FOSCSEL
65:                #pragma config FNOSC = FRC              // Oscillator Select (Fast RC Oscillator (FRC))
66:                #pragma config SOSCSRC = DIG            // SOSC Source Type (Analog Mode for use with crystal)
67:                #pragma config LPRCSEL = HP             // LPRC Oscillator Power and Accuracy (High Power, High Accuracy Mode)
68:                #pragma config IESO = OFF                // Internal External Switch Over bit (Internal External Switchover mode enabled (Two-speed Start-up enabled))
69:                
70:                // FOSC
71:                #pragma config POSCMOD = NONE           // Primary Oscillator Configuration bits (Primary oscillator disabled)
72:                #pragma config OSCIOFNC = CLKO          // CLKO Enable Configuration bit (CLKO output signal enabled)
73:                #pragma config POSCFREQ = HS            // Primary Oscillator Frequency Range Configuration bits (Primary oscillator/external clock input frequency greater than 8MHz)
74:                #pragma config SOSCSEL = SOSCHP         // SOSC Power Selection Configuration bits (Secondary Oscillator configured for high-power operation)
75:                #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Both Clock Switching and Fail-safe Clock Monitor are disabled)
76:                
77:                // FWDT
78:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscale Select bits (1:32768)
79:                #pragma config FWPSA = PR128            // WDT Prescaler bit (WDT prescaler ratio of 1:128)
80:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable bits (WDT disabled in hardware; SWDTEN bit disabled)
81:                #pragma config WINDIS = OFF             // Windowed Watchdog Timer Disable bit (Standard WDT selected(windowed WDT disabled))
82:                
83:                // FPOR
84:                #pragma config BOREN = BOR0             // Brown-out Reset Enable bits (Brown-out Reset disabled in hardware, SBOREN bit disabled)
85:                #pragma config RETCFG = OFF             //  (Retention regulator is not available)
86:                #pragma config PWRTEN = ON              // Power-up Timer Enable bit (PWRT enabled)
87:                #pragma config I2C1SEL = SEC            // Alternate I2C1 Pin Mapping bit (Use  Alternate ASCL1/ASDA1 Pins For I2C1)
88:                #pragma config BORV = V18               // Brown-out Reset Voltage bits (Brown-out Reset set to lowest voltage (1.8V))
89:                #pragma config MCLRE = ON               // MCLR Pin Enable bit (RA5 input pin disabled, MCLR pin enabled)
90:                
91:                // FICD
92:                #pragma config ICS = PGx1               // ICD Pin Placement Select bits (EMUC/EMUD share PGC1/PGD1)
93:                
94:                // #pragma config statements should precede project file includes.
95:                // Use project enums instead of #define for ON and OFF.
96:                
97:                //**********************************************************************************************************************
98:                // Main routine - start of executable code
99:                
100:               int main(void)
101:               {
002202  FA0000     LNK #0x0
102:               	initBoard(); //Initialize the pins and peripherals
002204  070014     RCALL initBoard
103:               
104:               	while (1) {
105:               		APP_Tasks();
002206  07FCD1     RCALL APP_Tasks
106:               		Idle(); //Idle until an interrupt is generated
002208  FE4001     PWRSAV #1
107:               		RCONbits.IDLE = 0;
00220A  A94740     BCLR RCON, #2
108:               		LED2 = !LED2;
00220C  801665     MOV LATB, W5
00220E  210004     MOV #0x1000, W4
002210  628204     AND W5, W4, W4
002212  A7F004     BTSC W4, #15
002214  EA0204     NEG W4, W4
002216  E90204     DEC W4, W4
002218  DE224F     LSR W4, #15, W4
00221A  784204     MOV.B W4, W4
00221C  FB8204     ZE W4, W4
00221E  620261     AND W4, #0x1, W4
002220  DD224C     SL W4, #12, W4
002222  801666     MOV LATB, W6
002224  2EFFF5     MOV #0xEFFF, W5
002226  630285     AND W6, W5, W5
002228  720205     IOR W4, W5, W4
00222A  881664     MOV W4, LATB
109:               	}
00222C  37FFEC     BRA 0x2206
110:               
111:               	//End of while(1) main loop
112:               	return(true);
113:               }
114:               
115:               //**********************************************************************************************************************
116:               // Initialize the pins and peripherals
117:               
118:               void initBoard(void)
119:               {
00222E  FA0000     LNK #0x0
120:               	/****************************************************************************
121:               	 * Oscillator Init
122:               	 * Clocking is setup at 32MHz sys clock and to allow USB functionality
123:               	 * Self-tune on SOF is enabled if USB is enabled and connected to host
124:               	 ***************************************************************************/
125:               	// DOZEN disabled; DOZE 1:16; CPDIV 1:1; RCDIV FRC/1; PLLEN disabled; ROI disabled;
126:               	CLKDIVbits.RCDIV = 1;
002230  803A24     MOV CLKDIV, W4
002232  A08004     BSET W4, #8
002234  A19004     BCLR W4, #9
002236  A1A004     BCLR W4, #10
002238  883A24     MOV W4, CLKDIV
127:               	OSCCONbits.COSC = 0x1;
00223A  803A14     MOV OSCCON, W4
00223C  A0C004     BSET W4, #12
00223E  A1D004     BCLR W4, #13
002240  A1E004     BCLR W4, #14
002242  883A14     MOV W4, OSCCON
128:               	OSCCONbits.NOSC = 0x1;
002244  803A14     MOV OSCCON, W4
002246  A08004     BSET W4, #8
002248  A19004     BCLR W4, #9
00224A  A1A004     BCLR W4, #10
00224C  883A14     MOV W4, OSCCON
129:               
130:               	// STSRC USB; STEN enabled; STOR disabled; STORPOL Interrupt when STOR is 1; STLOCK disabled; STLPOL Interrupt when STLOCK is 1; STSIDL disabled; TUN Center frequency; 
131:               	OSCTUN = 0x0;
00224E  EB0200     CLR W4
002250  883A44     MOV W4, OSCTUN
132:               
133:               	//Enable low voltage retention sleep mode
134:               	RCONbits.RETEN = 1;
002252  A88741     BSET 0x741, #4
135:               
136:               #ifdef SET_PMD_BITS    //see config.h, Application settings section
137:               	/****************************************************************************
138:               	 * PMD bits - setting a bit disables clocking to that peripheral
139:               	 * (drops operating current by about 2 mA when used in this app)
140:               	 ***************************************************************************/
141:               	PMD1bits.T4MD = 1;
142:               
143:               #if !defined (USE_SLEEP) || defined (SLEEP_MODE_RTCC)    //see config.h, Application settings section
144:               	PMD1bits.T1MD = 1;
145:               #endif
146:               
147:               	PMD1bits.I2C1MD = 1;
148:               	PMD1bits.U2MD = 1;
149:               	PMD1bits.SPI2MD = 1;
150:               	PMD1bits.SPI1MD = 1;
151:               	PMD3bits.TXMMD = 1;
152:               
153:               #if !defined (USE_SLEEP) || !defined (SLEEP_MODE_RTCC)    //see config.h, Application settings section
154:               	PMD3bits.RTCCMD = 1;
155:               #endif
156:               
157:               	PMD3bits.PMPMD = 1;
158:               	PMD3bits.CRCMD = 1;
159:               	PMD3bits.DAC1MD = 1;
160:               	PMD3bits.U3MD = 1;
161:               	PMD3bits.I2C2MD = 1;
162:               	PMD2 = 0xFFFF;
163:               	PMD4bits.UPWMMD = 1;
164:               	PMD4bits.U4MD = 1;
165:               	PMD4bits.REFOMD = 1;
166:               	PMD4bits.CTMUMD = 1;
167:               	PMD4bits.HLVDMD = 1;
168:               	PMD5 = 0xFFFF;
169:               	PMD6 = 0xFFFF;
170:               	PMD7 = 0xFFFF;
171:               #endif
172:               
173:               	/****************************************************************************
174:               	 * GPIO Init
175:               	 ***************************************************************************/
176:               	ANSA = 0x00;
002254  EB0200     CLR W4
002256  882704     MOV W4, ANSA
177:               	ANSB = 0x00;
002258  EB0200     CLR W4
00225A  882714     MOV W4, ANSB
178:               
179:               
180:               	CNPU1 = 0;
00225C  EB0200     CLR W4
00225E  880374     MOV W4, CNPU1
181:               	CNPU2 = 0;
002260  EB0200     CLR W4
002262  880384     MOV W4, CNPU2
182:               
183:               
184:               	CNPD1 = 0;
002264  EB0200     CLR W4
002266  8802B4     MOV W4, CNPD1
185:               	CNPD2 = 0;
002268  EB0200     CLR W4
00226A  8802C4     MOV W4, CNPD2
186:               
187:               
188:               	CNEN1 = 0x0000;
00226C  EB0200     CLR W4
00226E  880314     MOV W4, CNEN1
189:               	CNEN2 = 0x0000;
002270  EB0200     CLR W4
002272  880324     MOV W4, CNEN2
190:               
191:               	ODCB = 0x0000;
002274  EB0200     CLR W4
002276  881674     MOV W4, ODCB
192:               
193:               	IEC1bits.CNIE = 1;
002278  A86096     BSET IEC1, #3
194:               
195:               	// RELAYs are outputs and open-drain
196:               	// to drive ILQ2 opto
197:               	// setup in Mikrobus header
198:               	//	ODCDbits.ODD3 = 1; // pin 16
199:               	//	ODCDbits.ODD9 = 1; // pin 11
200:               	//	ODCDbits.ODD10 = 1; // pin 12
201:               	//	ODCDbits.ODD4 = 1; // pin 2
202:               
203:               	// LEDs are outputs and off
204:               	LED1 = 1;
00227A  A8A2CD     BSET 0x2CD, #5
205:               	LED2 = 0;
00227C  A982CD     BCLR 0x2CD, #4
206:               	LED3 = 0;
00227E  A982CC     BCLR LATB, #4
207:               	LED4 = 0;
002280  A962CC     BCLR LATB, #3
208:               	LED5 = 0;
002282  A9A2CD     BCLR 0x2CD, #5
209:               	LED6 = 0;
002284  A9A2CD     BCLR 0x2CD, #5
210:               	LED7 = 0;
002286  A9A2CD     BCLR 0x2CD, #5
211:               	LED_TRIS1 = 0;
002288  A9A2C9     BCLR 0x2C9, #5
212:               	LED_TRIS2 = 0;
00228A  A982C9     BCLR 0x2C9, #4
213:               	LED_TRIS3 = 0;
00228C  A982C8     BCLR TRISB, #4
214:               	LED_TRIS4 = 0;
00228E  A962C8     BCLR TRISB, #3
215:               
216:               	//RN4020 module - UART1
217:               	BT_WAKE_HW = 1; //Dormant line is set high
002290  A842CD     BSET 0x2CD, #2
218:               	BT_WAKE_HW_TRIS = 0; //Dormant line is output
002292  A942C9     BCLR 0x2C9, #2
219:               
220:               	BT_WAKE_SW = 0; //keep low until after UART is initialized
002294  A962CD     BCLR 0x2CD, #3
221:               	BT_WAKE_SW_TRIS = 0;
002296  A962C9     BCLR 0x2C9, #3
222:               
223:               	BT_CMD = 0; //Command mode on
002298  A902C4     BCLR LATA, #0
224:               	BT_CMD_TRIS = 0;
00229A  A902C0     BCLR TRISA, #0
225:               
226:               	BT_WS_TRIS = 1;
00229C  A842C0     BSET TRISA, #2
227:               	BT_MLDP_EV_TRIS = 1;
00229E  A882C0     BSET TRISA, #4
228:               	BT_CONNECTED_TRIS = 1;
0022A0  A822C0     BSET TRISA, #1
229:               
230:               	U1CTS_TRIS = 1;
0022A2  A802C9     BSET 0x2C9, #0
231:               	U1RX_TRIS = 1;
0022A4  A842C8     BSET TRISB, #2
232:               	U1RTS_LAT = 0;
0022A6  A922CD     BCLR 0x2CD, #1
233:               	U1RTS_TRIS = 0;
0022A8  A922C9     BCLR 0x2C9, #1
234:               	U1TX_TRIS = 0;
0022AA  A9E2C8     BCLR TRISB, #7
235:               
236:               	/****************************************************************************
237:               	 * PPS Init - Peripheral Pin Select
238:               	 * Click Boards using PPS-controlled peripherals will require additional
239:               	 * setup here
240:               	 ***************************************************************************/
241:               	__builtin_disi(0x3FFF); //disable interrupts
0022AC  FC3FFF     DISI #0x3FFF
242:               
243:               	//unlock registers
244:               	__builtin_write_OSCCONL(OSCCON & 0xBF);
0022AE  803A15     MOV OSCCON, W5
0022B0  200BF4     MOV #0xBF, W4
0022B2  628304     AND W5, W4, W6
0022B4  200464     MOV #0x46, W4
0022B6  200575     MOV #0x57, W5
0022B8  207427     MOV #0x742, W7
0022BA  784B84     MOV.B W4, [W7]
0022BC  784B85     MOV.B W5, [W7]
0022BE  784B86     MOV.B W6, [W7]
245:               
246:               	__builtin_write_OSCCONL(OSCCON | 0x40);
0022C0  803A15     MOV OSCCON, W5
0022C2  200404     MOV #0x40, W4
0022C4  780304     MOV W4, W6
0022C6  730305     IOR W6, W5, W6
0022C8  200464     MOV #0x46, W4
0022CA  200575     MOV #0x57, W5
0022CC  207427     MOV #0x742, W7
0022CE  784B84     MOV.B W4, [W7]
0022D0  784B85     MOV.B W5, [W7]
0022D2  784B86     MOV.B W6, [W7]
247:               
248:               	__builtin_disi(0); //enable interrupts
0022D4  FC0000     DISI #0x0
249:               
250:               	/****************************************************************************
251:               	 * Interrupt Priorities
252:               	 * Interrupt-enabled peripherals being used for Click Boards should be
253:               	 * configured here as well
254:               	 ***************************************************************************/
255:               	//    UERI: U1E - UART1 Error
256:               	//    Priority: 6
257:               	IPC16bits.U1ERIP = 6;
0022D6  800624     MOV IPC16, W4
0022D8  A14004     BCLR W4, #4
0022DA  A05004     BSET W4, #5
0022DC  A06004     BSET W4, #6
0022DE  880624     MOV W4, IPC16
258:               
259:               	//    UTXI: U1TX - UART1 Transmitter
260:               	//    Priority: 5
261:               	IPC3bits.U1TXIP = 5;
0022E0  800554     MOV IPC3, W4
0022E2  A00004     BSET W4, #0
0022E4  A11004     BCLR W4, #1
0022E6  A02004     BSET W4, #2
0022E8  880554     MOV W4, IPC3
262:               
263:               	//    URXI: U1RX - UART1 Receiver
264:               	//    Priority: 5
265:               	IPC2bits.U1RXIP = 5;
0022EA  800544     MOV IPC2, W4
0022EC  A0C004     BSET W4, #12
0022EE  A1D004     BCLR W4, #13
0022F0  A0E004     BSET W4, #14
0022F2  880544     MOV W4, IPC2
266:               
267:               
268:               	//    TI: T1 - Timer1
269:               	//    Priority: 3
270:               	IPC0bits.T1IP = 3;
0022F4  800524     MOV IPC0, W4
0022F6  A0C004     BSET W4, #12
0022F8  A0D004     BSET W4, #13
0022FA  A1E004     BCLR W4, #14
0022FC  880524     MOV W4, IPC0
271:               
272:               	//    RTCI: RTCC - Real-Time Clock and Calendar
273:               	//    Priority: 2
274:               	IPC15bits.RTCIP = 2;
0022FE  800614     MOV IPC15, W4
002300  A18004     BCLR W4, #8
002302  A09004     BSET W4, #9
002304  A1A004     BCLR W4, #10
002306  880614     MOV W4, IPC15
275:               
276:               	//    CN: Switches - change notification
277:               	//    Priority: 2
278:               	IPC4bits.CNIP = 2;
002308  800564     MOV IPC4, W4
00230A  A1C004     BCLR W4, #12
00230C  A0D004     BSET W4, #13
00230E  A1E004     BCLR W4, #14
002310  880564     MOV W4, IPC4
279:               
280:               	//    ADI: ADC1 - Pipeline A/D Converter 1
281:               	//    Priority: 1
282:               	IPC3bits.AD1IP = 1;
002312  800554     MOV IPC3, W4
002314  A04004     BSET W4, #4
002316  A15004     BCLR W4, #5
002318  A16004     BCLR W4, #6
00231A  880554     MOV W4, IPC3
283:               }
00231C  FA8000     ULNK
00231E  060000     RETURN
---  /sdd/work/fac_relay_clone/leds.c  ------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        leds.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 * add relay outputs
32:                 *
33:                 * LED functions
34:                 *
35:                 */
36:                
37:                #include "timers.h"
38:                #include "config.h"
39:                #include "leds.h"
40:                #include "app.h"
41:                
42:                extern APP_DATA appData;
43:                static LED_LIGHTSHOW_T lightShow = LED_IDLE;
44:                
45:                void LED_Tasks()
46:                {
001E86  FA0000     LNK #0x0
47:                	switch (lightShow) {
001E88  805874     MOV lightShow, W4
001E8A  200005     MOV #0x0, W5
001E8C  200046     MOV #0x4, W6
001E8E  200007     MOV #0x0, W7
001E90  520F86     SUB W4, W6, [W15]
001E92  5A8F87     SUBB W5, W7, [W15]
001E94  3E00AF     BRA GTU, 0x1FF4
001E96  016004     BRA W4
001E98  370004     BRA 0x1EA2
001E9A  37000A     BRA 0x1EB0
001E9C  370024     BRA 0x1EE6
001E9E  370086     BRA 0x1FAC
001EA0  3700A2     BRA 0x1FE6
48:                	case LED_IDLE:
49:                		LED1 = 0;
001EA2  A9A2CD     BCLR 0x2CD, #5
50:                		LED2 = 0;
001EA4  A982CD     BCLR 0x2CD, #4
51:                		LED3 = 0;
001EA6  A982CC     BCLR LATB, #4
52:                		LED4 = 0;
001EA8  A962CC     BCLR LATB, #3
53:                		LED5 = 1;
001EAA  A8A2CD     BSET 0x2CD, #5
54:                		LED6 = 0;
001EAC  A9A2CD     BCLR 0x2CD, #5
55:                		break;
001EAE  3700A5     BRA 0x1FFA
56:                
57:                	case LED_BTLE_ADVERTISING:
58:                		LED1 = 0;
001EB0  A9A2CD     BCLR 0x2CD, #5
59:                		LED2 = 0;
001EB2  A982CD     BCLR 0x2CD, #4
60:                		LED3 = 0;
001EB4  A982CC     BCLR LATB, #4
61:                		LED4 = 0;
001EB6  A962CC     BCLR LATB, #3
62:                		LED6 = 0;
001EB8  A9A2CD     BCLR 0x2CD, #5
63:                		if (TimerDone(TMR_LEDS)) {
001EBA  B3C010     MOV.B #0x1, W0
001EBC  0702BE     RCALL TimerDone
001EBE  784200     MOV.B W0, W4
001EC0  524FE0     SUB.B W4, #0x0, [W15]
001EC2  32009A     BRA Z, 0x1FF8
64:                			LED5 ^= 1;
001EC4  801664     MOV LATB, W4
001EC6  DE224D     LSR W4, #13, W4
001EC8  624261     AND.B W4, #0x1, W4
001ECA  A20404     BTG.B W4, #0
001ECC  624261     AND.B W4, #0x1, W4
001ECE  FB8204     ZE W4, W4
001ED0  620261     AND W4, #0x1, W4
001ED2  DD224D     SL W4, #13, W4
001ED4  801666     MOV LATB, W6
001ED6  2DFFF5     MOV #0xDFFF, W5
001ED8  630285     AND W6, W5, W5
001EDA  720205     IOR W4, W5, W4
001EDC  881664     MOV W4, LATB
65:                			StartTimer(TMR_LEDS, LED_BLINK_MS);
001EDE  201F41     MOV #0x1F4, W1
001EE0  B3C010     MOV.B #0x1, W0
001EE2  07029E     RCALL StartTimer
66:                		}
67:                		break;
001EE4  37008A     BRA 0x1FFA
001FF8  000000     NOP
68:                
69:                	case LED_BTLE_PAIRED:
70:                		LED1 = appData.led1; // logic high turns on led
001EE6  20AD94     MOV #0xAD9, W4
001EE8  784214     MOV.B [W4], W4
001EEA  FB8204     ZE W4, W4
001EEC  620261     AND W4, #0x1, W4
001EEE  DD224D     SL W4, #13, W4
001EF0  801666     MOV LATB, W6
001EF2  2DFFF5     MOV #0xDFFF, W5
001EF4  630285     AND W6, W5, W5
001EF6  720205     IOR W4, W5, W4
001EF8  881664     MOV W4, LATB
71:                		RELAY1 = !appData.led1; // logic low turns on relay
001EFA  20AD94     MOV #0xAD9, W4
001EFC  784214     MOV.B [W4], W4
001EFE  A20404     BTG.B W4, #0
001F00  FB8204     ZE W4, W4
001F02  784204     MOV.B W4, W4
001F04  624261     AND.B W4, #0x1, W4
001F06  FB8204     ZE W4, W4
001F08  620261     AND W4, #0x1, W4
001F0A  DD224D     SL W4, #13, W4
001F0C  801666     MOV LATB, W6
001F0E  2DFFF5     MOV #0xDFFF, W5
001F10  630285     AND W6, W5, W5
001F12  720205     IOR W4, W5, W4
001F14  881664     MOV W4, LATB
72:                		LED2 = appData.led2;
001F16  20ADA4     MOV #0xADA, W4
001F18  784214     MOV.B [W4], W4
001F1A  FB8204     ZE W4, W4
001F1C  620261     AND W4, #0x1, W4
001F1E  DD224C     SL W4, #12, W4
001F20  801666     MOV LATB, W6
001F22  2EFFF5     MOV #0xEFFF, W5
001F24  630285     AND W6, W5, W5
001F26  720205     IOR W4, W5, W4
001F28  881664     MOV W4, LATB
73:                		RELAY2 = !appData.led2;
001F2A  20ADA4     MOV #0xADA, W4
001F2C  784214     MOV.B [W4], W4
001F2E  A20404     BTG.B W4, #0
001F30  FB8204     ZE W4, W4
001F32  784204     MOV.B W4, W4
001F34  624261     AND.B W4, #0x1, W4
001F36  FB8204     ZE W4, W4
001F38  620261     AND W4, #0x1, W4
001F3A  DD224C     SL W4, #12, W4
001F3C  801666     MOV LATB, W6
001F3E  2EFFF5     MOV #0xEFFF, W5
001F40  630285     AND W6, W5, W5
001F42  720205     IOR W4, W5, W4
001F44  881664     MOV W4, LATB
74:                		LED3 = appData.led3;
001F46  20ADB4     MOV #0xADB, W4
001F48  784214     MOV.B [W4], W4
001F4A  FB8204     ZE W4, W4
001F4C  620261     AND W4, #0x1, W4
001F4E  DD2244     SL W4, #4, W4
001F50  801666     MOV LATB, W6
001F52  2FFEF5     MOV #0xFFEF, W5
001F54  630285     AND W6, W5, W5
001F56  720205     IOR W4, W5, W4
001F58  881664     MOV W4, LATB
75:                		RELAY3 = !appData.led3;
001F5A  20ADB4     MOV #0xADB, W4
001F5C  784214     MOV.B [W4], W4
001F5E  A20404     BTG.B W4, #0
001F60  FB8204     ZE W4, W4
001F62  784204     MOV.B W4, W4
001F64  624261     AND.B W4, #0x1, W4
001F66  FB8204     ZE W4, W4
001F68  620261     AND W4, #0x1, W4
001F6A  DD2244     SL W4, #4, W4
001F6C  801666     MOV LATB, W6
001F6E  2FFEF5     MOV #0xFFEF, W5
001F70  630285     AND W6, W5, W5
001F72  720205     IOR W4, W5, W4
001F74  881664     MOV W4, LATB
76:                		LED4 = appData.led4;
001F76  20ADC4     MOV #0xADC, W4
001F78  784214     MOV.B [W4], W4
001F7A  FB8204     ZE W4, W4
001F7C  620261     AND W4, #0x1, W4
001F7E  DD2243     SL W4, #3, W4
001F80  801666     MOV LATB, W6
001F82  2FFF75     MOV #0xFFF7, W5
001F84  630285     AND W6, W5, W5
001F86  720205     IOR W4, W5, W4
001F88  881664     MOV W4, LATB
77:                		RELAY4 = !appData.led4;
001F8A  20ADC4     MOV #0xADC, W4
001F8C  784214     MOV.B [W4], W4
001F8E  A20404     BTG.B W4, #0
001F90  FB8204     ZE W4, W4
001F92  784204     MOV.B W4, W4
001F94  624261     AND.B W4, #0x1, W4
001F96  FB8204     ZE W4, W4
001F98  620261     AND W4, #0x1, W4
001F9A  DD2243     SL W4, #3, W4
001F9C  801666     MOV LATB, W6
001F9E  2FFF75     MOV #0xFFF7, W5
001FA0  630285     AND W6, W5, W5
001FA2  720205     IOR W4, W5, W4
001FA4  881664     MOV W4, LATB
78:                		LED5 = 1;
001FA6  A8A2CD     BSET 0x2CD, #5
79:                		LED6 = 0;
001FA8  A9A2CD     BCLR 0x2CD, #5
80:                		break;
001FAA  370027     BRA 0x1FFA
81:                
82:                	case LED_ERROR:
83:                		switch (appData.error_code) {
001FAC  20ADF4     MOV #0xADF, W4
001FAE  784214     MOV.B [W4], W4
001FB0  FB0204     SE W4, W4
001FB2  420FE3     ADD W4, #0x3, [W15]
001FB4  320009     BRA Z, 0x1FC8
001FB6  420FE2     ADD W4, #0x2, [W15]
001FB8  3A000E     BRA NZ, 0x1FD6
84:                		case ERROR_INITIALIZATION:
85:                			LED1 = 1;
001FBA  A8A2CD     BSET 0x2CD, #5
86:                			LED2 = 0;
001FBC  A982CD     BCLR 0x2CD, #4
87:                			LED3 = 0;
001FBE  A982CC     BCLR LATB, #4
88:                			LED4 = 0;
001FC0  A962CC     BCLR LATB, #3
89:                			LED5 = 1;
001FC2  A8A2CD     BSET 0x2CD, #5
90:                			LED6 = 1;
001FC4  A8A2CD     BSET 0x2CD, #5
91:                			break;
001FC6  37000E     BRA 0x1FE4
92:                		case ERROR_RN_FW:
93:                			LED1 = 1;
001FC8  A8A2CD     BSET 0x2CD, #5
94:                			LED2 = 1;
001FCA  A882CD     BSET 0x2CD, #4
95:                			LED3 = 0;
001FCC  A982CC     BCLR LATB, #4
96:                			LED4 = 0;
001FCE  A962CC     BCLR LATB, #3
97:                			LED5 = 1;
001FD0  A8A2CD     BSET 0x2CD, #5
98:                			LED6 = 1;
001FD2  A8A2CD     BSET 0x2CD, #5
99:                			break;
001FD4  370007     BRA 0x1FE4
100:               		default:
101:               			LED1 = 1;
001FD6  A8A2CD     BSET 0x2CD, #5
102:               			LED2 = 1;
001FD8  A882CD     BSET 0x2CD, #4
103:               			LED3 = 1;
001FDA  A882CC     BSET LATB, #4
104:               			LED4 = 1;
001FDC  A862CC     BSET LATB, #3
105:               			LED5 = 1;
001FDE  A8A2CD     BSET 0x2CD, #5
106:               			LED6 = 1;
001FE0  A8A2CD     BSET 0x2CD, #5
107:               			break;
001FE2  000000     NOP
108:               		}
109:               		break;
001FE4  37000A     BRA 0x1FFA
110:               
111:               	case LED_SLEEP:
112:               		LED1 = 0;
001FE6  A9A2CD     BCLR 0x2CD, #5
113:               		LED2 = 0;
001FE8  A982CD     BCLR 0x2CD, #4
114:               		LED3 = 0;
001FEA  A982CC     BCLR LATB, #4
115:               		LED4 = 0;
001FEC  A962CC     BCLR LATB, #3
116:               		LED5 = 0;
001FEE  A9A2CD     BCLR 0x2CD, #5
117:               		LED6 = 1;
001FF0  A8A2CD     BSET 0x2CD, #5
118:               		break;
001FF2  370003     BRA 0x1FFA
119:               
120:               	default:
121:               		break;
001FF4  000000     NOP
001FF6  370001     BRA 0x1FFA
122:               	}
123:               }
001FFA  FA8000     ULNK
001FFC  060000     RETURN
124:               
125:               inline void LED_SET_LightShow(LED_LIGHTSHOW_T setting)
126:               {
001FFE  FA0002     LNK #0x2
002000  780F00     MOV W0, [W14]
127:               	lightShow = setting;
002002  78021E     MOV [W14], W4
002004  885874     MOV W4, lightShow
128:               }
002006  FA8000     ULNK
002008  060000     RETURN
129:               
130:               //Update LEDs with status from LED update message
131:               
132:               void GetNewLEDs(void)
133:               {
00200A  FA0000     LNK #0x0
134:               	appData.led1 = appData.receive_packet[9] == '1' ? 1 : 0;
00200C  20A175     MOV #0xA17, W5
00200E  784295     MOV.B [W5], W5
002010  B3C314     MOV.B #0x31, W4
002012  6AC204     XOR.B W5, W4, W4
002014  FB8204     ZE W4, W4
002016  E90204     DEC W4, W4
002018  DE224F     LSR W4, #15, W4
00201A  784204     MOV.B W4, W4
00201C  780004     MOV W4, W0
00201E  B7EAD9     MOV.B WREG, 0xAD9
135:               	appData.led2 = appData.receive_packet[11] == '1' ? 1 : 0;
002020  20A195     MOV #0xA19, W5
002022  784295     MOV.B [W5], W5
002024  B3C314     MOV.B #0x31, W4
002026  6AC204     XOR.B W5, W4, W4
002028  FB8204     ZE W4, W4
00202A  E90204     DEC W4, W4
00202C  DE224F     LSR W4, #15, W4
00202E  784204     MOV.B W4, W4
002030  780004     MOV W4, W0
002032  B7EADA     MOV.B WREG, 0xADA
136:               	appData.led3 = appData.receive_packet[13] == '1' ? 1 : 0;
002034  20A1B5     MOV #0xA1B, W5
002036  784295     MOV.B [W5], W5
002038  B3C314     MOV.B #0x31, W4
00203A  6AC204     XOR.B W5, W4, W4
00203C  FB8204     ZE W4, W4
00203E  E90204     DEC W4, W4
002040  DE224F     LSR W4, #15, W4
002042  784204     MOV.B W4, W4
002044  780004     MOV W4, W0
002046  B7EADB     MOV.B WREG, 0xADB
137:               	appData.led4 = appData.receive_packet[15] == '1' ? 1 : 0;
002048  20A1D5     MOV #0xA1D, W5
00204A  784295     MOV.B [W5], W5
00204C  B3C314     MOV.B #0x31, W4
00204E  6AC204     XOR.B W5, W4, W4
002050  FB8204     ZE W4, W4
002052  E90204     DEC W4, W4
002054  DE224F     LSR W4, #15, W4
002056  784204     MOV.B W4, W4
002058  780004     MOV W4, W0
00205A  B7EADC     MOV.B WREG, 0xADC
138:               }
00205C  FA8000     ULNK
00205E  060000     RETURN
---  /sdd/work/fac_relay_clone/comparator.c  ------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2015 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        comparator.c
29:                 * Date:        September 18, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Comparator functions
33:                 *
34:                 */
35:                
36:                #include <xc.h>
37:                #include "app.h"
38:                #include "config.h"
39:                #include "timers.h"
40:                
41:                //State machine for comparator
42:                //Returns next timer value
43:                
44:                uint16_t CMP_Tasks(void)
45:                {
00257C  FA0000     LNK #0x0
46:                	return 1000;
00257E  203E84     MOV #0x3E8, W4
47:                }
002580  780004     MOV W4, W0
002582  FA8000     ULNK
002584  060000     RETURN
48:                
49:                //Initialize CMP2 for low input voltage detection
50:                
51:                void CMP_Init(void)
52:                {
002586  FA0000     LNK #0x0
53:                
54:                }
002588  FA8000     ULNK
00258A  060000     RETURN
55:                
56:                //Comparator interrupt
57:                
58:                void _ISR_NO_AUTO_PSV _CompInterrupt(void)
59:                {
00258C  781F80     MOV W0, [W15++]
00258E  FA0000     LNK #0x0
60:                	IFS1bits.CMIF = 0; //clear flags
002590  A94086     BCLR IFS1, #2
61:                
62:                }
002592  FA8000     ULNK
002594  78004F     MOV [--W15], W0
002596  064000     RETFIE
---  /sdd/work/fac_relay_clone/bluetooth.c  -------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        bluetooth.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Functions to communicate with a RN4020 Bluetooth LE module over a UART
33:                 * 
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdio.h>
39:                #include <stdbool.h>
40:                #include "bluetooth.h"
41:                #include "config.h"
42:                #include "app.h"
43:                #include "uart.h"
44:                #include "timers.h"
45:                
46:                //**********************************************************************************************************************
47:                // Receive a message over the Bluetooth link
48:                
49:                bool BT_ReceivePacket(char * Message)
50:                {
0015F0  FA0002     LNK #0x2
0015F2  BE9F88     MOV.D W8, [W15++]
0015F4  780F00     MOV W0, [W14]
51:                	static enum BluetoothDecodeState btDecodeState = WaitForCR; //Static so maintains state on reentry   //Byte read from the UART buffer
52:                	static uint16_t i = 0;
53:                
54:                	if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
0015F6  070551     RCALL UART_IsNewRxData
0015F8  784200     MOV.B W0, W4
0015FA  524FE0     SUB.B W4, #0x0, [W15]
0015FC  320032     BRA Z, 0x1662
55:                	{
56:                		Message[i++] = UART_ReadRxBuffer();
0015FE  805858     MOV i, W8
001600  44049E     ADD W8, [W14], W9
001602  070558     RCALL UART_ReadRxBuffer
001604  784200     MOV.B W0, W4
001606  784C84     MOV.B W4, [W9]
001608  E80208     INC W8, W4
00160A  885854     MOV W4, i
57:                		if (i == BT_RX_PKT_SZ) {
00160C  805855     MOV i, W5
00160E  200644     MOV #0x64, W4
001610  528F84     SUB W5, W4, [W15]
001612  3A0002     BRA NZ, 0x1618
58:                			i = 0;
001614  EB0200     CLR W4
001616  885854     MOV W4, i
59:                		}
60:                
61:                		switch (btDecodeState) {
001618  805864     MOV btDecodeState, W4
00161A  520FE0     SUB W4, #0x0, [W15]
00161C  320003     BRA Z, 0x1624
00161E  520FE1     SUB W4, #0x1, [W15]
001620  32000A     BRA Z, 0x1636
001622  370019     BRA 0x1656
62:                		case WaitForCR:
63:                			if (Message[i - 1] == '\r') { //See if this is the CR
001624  805854     MOV i, W4
001626  E90204     DEC W4, W4
001628  42021E     ADD W4, [W14], W4
00162A  784214     MOV.B [W4], W4
00162C  524FED     SUB.B W4, #0xD, [W15]
00162E  3A0016     BRA NZ, 0x165C
64:                				btDecodeState = WaitForLF; //Is CR so wait for LF
001630  200014     MOV #0x1, W4
001632  885864     MOV W4, btDecodeState
65:                			}
66:                			break;
001634  370016     BRA 0x1662
00165C  000000     NOP
00165E  370001     BRA 0x1662
67:                
68:                		case WaitForLF:
69:                			btDecodeState = WaitForCR; //Will be looking for a new packet next
001636  EB0200     CLR W4
001638  885864     MOV W4, btDecodeState
70:                			if (Message[i - 1] == '\n') //See if this is the LF
00163A  805854     MOV i, W4
00163C  E90204     DEC W4, W4
00163E  42021E     ADD W4, [W14], W4
001640  784214     MOV.B [W4], W4
001642  524FEA     SUB.B W4, #0xA, [W15]
001644  3A000D     BRA NZ, 0x1660
71:                			{
72:                				Message[i] = NULL; //Got a complete message!
001646  805854     MOV i, W4
001648  42029E     ADD W4, [W14], W5
00164A  EB4200     CLR.B W4
00164C  784A84     MOV.B W4, [W5]
73:                				i = 0;
00164E  EB0200     CLR W4
001650  885854     MOV W4, i
74:                				return true;
001652  B3C014     MOV.B #0x1, W4
001654  370007     BRA 0x1664
75:                			}
76:                			break;
001660  000000     NOP
77:                
78:                		default: //Invalid state so start looking for a new start of frame
79:                			btDecodeState = WaitForCR;
001656  EB0200     CLR W4
001658  885864     MOV W4, btDecodeState
00165A  370003     BRA 0x1662
80:                		}
81:                	}
82:                	return false;
001662  EB4200     CLR.B W4
83:                }
001664  784004     MOV.B W4, W0
001666  BE044F     MOV.D [--W15], W8
001668  FA8000     ULNK
00166A  060000     RETURN
84:                
85:                //**********************************************************************************************************************
86:                // Send a command to the RN4020 module
87:                //Return true for success, false for busy
88:                
89:                bool BT_SendCommand(const char *data, bool wait)
90:                {
00166C  FA0006     LNK #0x6
00166E  980710     MOV W0, [W14+2]
001670  984741     MOV.B W1, [W14+4]
91:                	uint16_t i;
92:                	//Only transmit a message if TX timer expired, or wait flag is set to false
93:                	//We limit transmission frequency to avoid overwhelming the BTLE link
94:                	if (TimerDone(TMR_BT_TX) || wait == false) {
001672  B3C090     MOV.B #0x9, W0
001674  0706E2     RCALL TimerDone
001676  784200     MOV.B W0, W4
001678  524FE0     SUB.B W4, #0x0, [W15]
00167A  3A0004     BRA NZ, 0x1684
00167C  90424E     MOV.B [W14+4], W4
00167E  A20404     BTG.B W4, #0
001680  524FE0     SUB.B W4, #0x0, [W15]
001682  32001B     BRA Z, 0x16BA
95:                		for (i = 0; i < SIZE_TxBuffer; i++) {
001684  EB0200     CLR W4
001686  780F04     MOV W4, [W14]
001688  37000C     BRA 0x16A2
0016A0  E80F1E     INC [W14], [W14]
0016A2  200FF4     MOV #0xFF, W4
0016A4  78029E     MOV [W14], W5
0016A6  528F84     SUB W5, W4, [W15]
0016A8  36FFF0     BRA LEU, 0x168A
0016AA  370001     BRA 0x16AE
96:                			if (*data != '\0') //Keep loading bytes until end of string
00168A  90021E     MOV [W14+2], W4
00168C  784214     MOV.B [W4], W4
00168E  524FE0     SUB.B W4, #0x0, [W15]
001690  32000D     BRA Z, 0x16AC
97:                				UART_WriteTxBuffer(*data++); //Load byte into the transmit buffer
001692  90021E     MOV [W14+2], W4
001694  784214     MOV.B [W4], W4
001696  90029E     MOV [W14+2], W5
001698  E80285     INC W5, W5
00169A  980715     MOV W5, [W14+2]
00169C  784004     MOV.B W4, W0
00169E  070524     RCALL UART_WriteTxBuffer
98:                			else
99:                				break;
0016AC  000000     NOP
100:               		}
101:               		UART_TxStart(); //Start transmitting the bytes
0016AE  0704F1     RCALL UART_TxStart
102:               		StartTimer(TMR_BT_TX, BT_TX_MS); //Restart transmit timer
0016B0  200961     MOV #0x96, W1
0016B2  B3C090     MOV.B #0x9, W0
0016B4  0706B5     RCALL StartTimer
103:               		return true;
0016B6  B3C014     MOV.B #0x1, W4
0016B8  370001     BRA 0x16BC
104:               	}
105:               	return false;
0016BA  EB4200     CLR.B W4
106:               }
0016BC  784004     MOV.B W4, W0
0016BE  FA8000     ULNK
0016C0  060000     RETURN
107:               
108:               //**********************************************************************************************************************
109:               // Send a byte to the RN4020 module
110:               
111:               void BT_SendByte(char data)
112:               {
0016C2  FA0002     LNK #0x2
0016C4  784F00     MOV.B W0, [W14]
113:               	UART_WriteTxBuffer(data); //Load byte into the transmit buffer
0016C6  78421E     MOV.B [W14], W4
0016C8  784004     MOV.B W4, W0
0016CA  07050E     RCALL UART_WriteTxBuffer
114:               	UART_TxStart(); //Start transmitting the byte
0016CC  0704E2     RCALL UART_TxStart
115:               }
0016CE  FA8000     ULNK
0016D0  060000     RETURN
116:               
117:               //**********************************************************************************************************************
118:               // Get a response from the RN4020 module
119:               
120:               bool BT_GetResponse(char *data)
121:               {
0016D2  FA0006     LNK #0x6
0016D4  980720     MOV W0, [W14+4]
122:               	uint16_t byteCount = 0;
0016D6  EB0200     CLR W4
0016D8  780F04     MOV W4, [W14]
123:               	char newByte;
124:               
125:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
0016DA  202581     MOV #0x258, W1
0016DC  B3C020     MOV.B #0x2, W0
0016DE  0706A0     RCALL StartTimer
126:               
127:               	while (byteCount < BT_RX_PKT_SZ) //Don't accept more than the buffer size
0016E0  37001A     BRA 0x1716
001716  200634     MOV #0x63, W4
001718  78029E     MOV [W14], W5
00171A  528F84     SUB W5, W4, [W15]
00171C  36FFE2     BRA LEU, 0x16E2
128:               	{
129:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
0016E2  0704DB     RCALL UART_IsNewRxData
0016E4  784200     MOV.B W0, W4
0016E6  524FE0     SUB.B W4, #0x0, [W15]
0016E8  32000F     BRA Z, 0x1708
130:               		{
131:               			newByte = UART_ReadRxBuffer(); //Read the data byte for processing
0016EA  0704E4     RCALL UART_ReadRxBuffer
0016EC  784200     MOV.B W0, W4
0016EE  984724     MOV.B W4, [W14+2]
132:               			*data++ = newByte; //Add it to the buffer
0016F0  90022E     MOV [W14+4], W4
0016F2  9042AE     MOV.B [W14+2], W5
0016F4  784A05     MOV.B W5, [W4]
0016F6  90022E     MOV [W14+4], W4
0016F8  E80204     INC W4, W4
0016FA  980724     MOV W4, [W14+4]
133:               			byteCount++; //Keep track of the number of bytes received
0016FC  E80F1E     INC [W14], [W14]
134:               			if (newByte == '\n') //Check if got linefeed
0016FE  90422E     MOV.B [W14+2], W4
001700  524FEA     SUB.B W4, #0xA, [W15]
001702  3A0002     BRA NZ, 0x1708
135:               				return true; //If linefeed then return success
001704  B3C014     MOV.B #0x1, W4
001706  37000C     BRA 0x1720
136:               		}
137:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001708  B3C020     MOV.B #0x2, W0
00170A  070697     RCALL TimerDone
00170C  784200     MOV.B W0, W4
00170E  524FE0     SUB.B W4, #0x0, [W15]
001710  320002     BRA Z, 0x1716
138:               			return false; //If timed out then return failure
001712  EB4200     CLR.B W4
001714  370005     BRA 0x1720
139:               	}
140:               	return false;
00171E  EB4200     CLR.B W4
141:               }
001720  784004     MOV.B W4, W0
001722  FA8000     ULNK
001724  060000     RETURN
142:               
143:               //**********************************************************************************************************************
144:               // Compare the buffer with the response with one of the expected responses
145:               
146:               bool BT_CompareResponse(const char *data1, const char *data2)
147:               {
001726  FA0006     LNK #0x6
001728  980710     MOV W0, [W14+2]
00172A  980721     MOV W1, [W14+4]
148:               	uint16_t i;
149:               
150:               	for (i = 0; i < 50; i++) //Compare up to 50 bytes
00172C  EB0200     CLR W4
00172E  780F04     MOV W4, [W14]
001730  37001A     BRA 0x1766
001764  E80F1E     INC [W14], [W14]
001766  200314     MOV #0x31, W4
001768  78029E     MOV [W14], W5
00176A  528F84     SUB W5, W4, [W15]
00176C  36FFE2     BRA LEU, 0x1732
151:               	{
152:               		if (*data1 == '\0') //See if reached end of string with no bytes different
001732  90021E     MOV [W14+2], W4
001734  784214     MOV.B [W4], W4
001736  524FE0     SUB.B W4, #0x0, [W15]
001738  3A0002     BRA NZ, 0x173E
153:               			return true; //No bytes were different so return success
00173A  B3C014     MOV.B #0x1, W4
00173C  370019     BRA 0x1770
154:               		else if (*data1++ != *data2++) //else see if the bytes are different
00173E  90021E     MOV [W14+2], W4
001740  784294     MOV.B [W4], W5
001742  90022E     MOV [W14+4], W4
001744  784214     MOV.B [W4], W4
001746  6AC204     XOR.B W5, W4, W4
001748  FB8204     ZE W4, W4
00174A  EA0204     NEG W4, W4
00174C  DE224F     LSR W4, #15, W4
00174E  784204     MOV.B W4, W4
001750  90029E     MOV [W14+2], W5
001752  E80285     INC W5, W5
001754  980715     MOV W5, [W14+2]
001756  9002AE     MOV [W14+4], W5
001758  E80285     INC W5, W5
00175A  980725     MOV W5, [W14+4]
00175C  524FE0     SUB.B W4, #0x0, [W15]
00175E  320002     BRA Z, 0x1764
155:               			return false; //Bytes differ so return failure
001760  EB4200     CLR.B W4
001762  370006     BRA 0x1770
156:               	}
157:               	return false; //Did not reach end of string so return failure
00176E  EB4200     CLR.B W4
158:               }
001770  784004     MOV.B W4, W0
001772  FA8000     ULNK
001774  060000     RETURN
159:               
160:               //**********************************************************************************************************************
161:               // Get a response from the RN4020 module and compare with an expected response
162:               
163:               bool BT_CheckResponse(const char *data)
164:               {
001776  FA003C     LNK #0x3C
001778  981F50     MOV W0, [W14+58]
165:               	uint16_t i, ByteCount = 0;
00177A  EB0200     CLR W4
00177C  980714     MOV W4, [W14+2]
166:               	char NewByte, Buffer[50], *BufPtr;
167:               
168:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
00177E  202581     MOV #0x258, W1
001780  B3C020     MOV.B #0x2, W0
001782  07064E     RCALL StartTimer
169:               
170:               	BufPtr = Buffer;
001784  470267     ADD W14, #0x7, W4
001786  980724     MOV W4, [W14+4]
171:               	while (ByteCount < 50) //Don't accept more than the buffer size
001788  37001A     BRA 0x17BE
0017BE  90029E     MOV [W14+2], W5
0017C0  200314     MOV #0x31, W4
0017C2  528F84     SUB W5, W4, [W15]
0017C4  36FFE2     BRA LEU, 0x178A
0017C6  370001     BRA 0x17CA
172:               	{
173:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
00178A  070487     RCALL UART_IsNewRxData
00178C  784200     MOV.B W0, W4
00178E  524FE0     SUB.B W4, #0x0, [W15]
001790  32000F     BRA Z, 0x17B0
174:               		{
175:               			NewByte = (char) UART_ReadRxBuffer(); //Read the data byte for processing
001792  070490     RCALL UART_ReadRxBuffer
001794  784200     MOV.B W0, W4
001796  984764     MOV.B W4, [W14+6]
176:               			*BufPtr++ = NewByte; //Add it to the buffer
001798  90022E     MOV [W14+4], W4
00179A  9042EE     MOV.B [W14+6], W5
00179C  784A05     MOV.B W5, [W4]
00179E  90022E     MOV [W14+4], W4
0017A0  E80204     INC W4, W4
0017A2  980724     MOV W4, [W14+4]
177:               			ByteCount++;
0017A4  90021E     MOV [W14+2], W4
0017A6  E80204     INC W4, W4
0017A8  980714     MOV W4, [W14+2]
178:               			if (NewByte == '\n') //Check if got linefeed
0017AA  90426E     MOV.B [W14+6], W4
0017AC  524FEA     SUB.B W4, #0xA, [W15]
0017AE  32000C     BRA Z, 0x17C8
179:               				break; //If linefeed then we have what we want
0017C8  000000     NOP
180:               		}
181:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
0017B0  B3C020     MOV.B #0x2, W0
0017B2  070643     RCALL TimerDone
0017B4  784200     MOV.B W0, W4
0017B6  524FE0     SUB.B W4, #0x0, [W15]
0017B8  320002     BRA Z, 0x17BE
182:               			return false; //If timed out then return failure
0017BA  EB4200     CLR.B W4
0017BC  37002A     BRA 0x1812
183:               	}
184:               
185:               	BufPtr = Buffer;
0017CA  470267     ADD W14, #0x7, W4
0017CC  980724     MOV W4, [W14+4]
186:               	for (i = 0; i < ByteCount; i++) //Compare all bytes received
0017CE  EB0200     CLR W4
0017D0  780F04     MOV W4, [W14]
0017D2  37001A     BRA 0x1808
001806  E80F1E     INC [W14], [W14]
001808  90021E     MOV [W14+2], W4
00180A  78029E     MOV [W14], W5
00180C  528F84     SUB W5, W4, [W15]
00180E  39FFE2     BRA NC, 0x17D4
187:               	{
188:               		if (*data == '\0') //See if reached end of string with no bytes different
0017D4  901A5E     MOV [W14+58], W4
0017D6  784214     MOV.B [W4], W4
0017D8  524FE0     SUB.B W4, #0x0, [W15]
0017DA  3A0002     BRA NZ, 0x17E0
189:               			return true; //No bytes were different so return success
0017DC  B3C014     MOV.B #0x1, W4
0017DE  370019     BRA 0x1812
190:               		else if (*data++ != *BufPtr++) //else see if the bytes are different
0017E0  901A5E     MOV [W14+58], W4
0017E2  784294     MOV.B [W4], W5
0017E4  90022E     MOV [W14+4], W4
0017E6  784214     MOV.B [W4], W4
0017E8  6AC204     XOR.B W5, W4, W4
0017EA  FB8204     ZE W4, W4
0017EC  EA0204     NEG W4, W4
0017EE  DE224F     LSR W4, #15, W4
0017F0  784204     MOV.B W4, W4
0017F2  901ADE     MOV [W14+58], W5
0017F4  E80285     INC W5, W5
0017F6  981F55     MOV W5, [W14+58]
0017F8  9002AE     MOV [W14+4], W5
0017FA  E80285     INC W5, W5
0017FC  980725     MOV W5, [W14+4]
0017FE  524FE0     SUB.B W4, #0x0, [W15]
001800  320002     BRA Z, 0x1806
191:               			return false; //Bytes differ so return failure
001802  EB4200     CLR.B W4
001804  370006     BRA 0x1812
192:               	}
193:               	return true; //All bytes matched so return success
001810  B3C014     MOV.B #0x1, W4
194:               }
001812  784004     MOV.B W4, W0
001814  FA8000     ULNK
001816  060000     RETURN
195:               
196:               //**********************************************************************************************************************
197:               // Get a response from the RN4020 module and compare with an expected response
198:               //   All incoming bytes in the position of the wildcard character are ignored
199:               //   Use this to ignore text that changes, like MAC addresses.
200:               
201:               bool BT_CheckResponseWithWildcard(const char *data, char Wildcard)
202:               {
001818  FA003E     LNK #0x3E
00181A  981F50     MOV W0, [W14+58]
00181C  987F41     MOV.B W1, [W14+60]
203:               	uint16_t i, ByteCount = 0;
00181E  EB0200     CLR W4
001820  980714     MOV W4, [W14+2]
204:               	char NewByte, Buffer[50], *BufPtr;
205:               
206:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
001822  202581     MOV #0x258, W1
001824  B3C020     MOV.B #0x2, W0
001826  0705FC     RCALL StartTimer
207:               
208:               	BufPtr = Buffer;
001828  470267     ADD W14, #0x7, W4
00182A  980724     MOV W4, [W14+4]
209:               	while (ByteCount < 50) //Don't accept more than the buffer size
00182C  37001A     BRA 0x1862
001862  90029E     MOV [W14+2], W5
001864  200314     MOV #0x31, W4
001866  528F84     SUB W5, W4, [W15]
001868  36FFE2     BRA LEU, 0x182E
00186A  370001     BRA 0x186E
210:               	{
211:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
00182E  070435     RCALL UART_IsNewRxData
001830  784200     MOV.B W0, W4
001832  524FE0     SUB.B W4, #0x0, [W15]
001834  32000F     BRA Z, 0x1854
212:               		{
213:               			NewByte = UART_ReadRxBuffer(); //Read the data byte for processing
001836  07043E     RCALL UART_ReadRxBuffer
001838  784200     MOV.B W0, W4
00183A  984764     MOV.B W4, [W14+6]
214:               			*BufPtr++ = NewByte; //Add it to the buffer
00183C  90022E     MOV [W14+4], W4
00183E  9042EE     MOV.B [W14+6], W5
001840  784A05     MOV.B W5, [W4]
001842  90022E     MOV [W14+4], W4
001844  E80204     INC W4, W4
001846  980724     MOV W4, [W14+4]
215:               			ByteCount++;
001848  90021E     MOV [W14+2], W4
00184A  E80204     INC W4, W4
00184C  980714     MOV W4, [W14+2]
216:               			if (NewByte == '\n') //Check if got linefeed
00184E  90426E     MOV.B [W14+6], W4
001850  524FEA     SUB.B W4, #0xA, [W15]
001852  32000C     BRA Z, 0x186C
217:               				break; //If linefeed then we have what we want
00186C  000000     NOP
218:               		}
219:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001854  B3C020     MOV.B #0x2, W0
001856  0705F1     RCALL TimerDone
001858  784200     MOV.B W0, W4
00185A  524FE0     SUB.B W4, #0x0, [W15]
00185C  320002     BRA Z, 0x1862
220:               			return false; //If timed out then return failure
00185E  EB4200     CLR.B W4
001860  370036     BRA 0x18CE
221:               	}
222:               
223:               	BufPtr = Buffer;
00186E  470267     ADD W14, #0x7, W4
001870  980724     MOV W4, [W14+4]
224:               	for (i = 0; i < ByteCount; i++) //Compare all bytes received
001872  EB0200     CLR W4
001874  780F04     MOV W4, [W14]
001876  370026     BRA 0x18C4
0018C2  E80F1E     INC [W14], [W14]
0018C4  90021E     MOV [W14+2], W4
0018C6  78029E     MOV [W14], W5
0018C8  528F84     SUB W5, W4, [W15]
0018CA  39FFD6     BRA NC, 0x1878
225:               	{
226:               		if (*data == '\0') //See if reached end of string with no bytes different
001878  901A5E     MOV [W14+58], W4
00187A  784214     MOV.B [W4], W4
00187C  524FE0     SUB.B W4, #0x0, [W15]
00187E  3A0002     BRA NZ, 0x1884
227:               			return true; //No bytes were different so return success
001880  B3C014     MOV.B #0x1, W4
001882  370025     BRA 0x18CE
228:               		else if (*data == Wildcard) //else see if expected response byte is a wildcard
001884  901A5E     MOV [W14+58], W4
001886  784294     MOV.B [W4], W5
001888  907A4E     MOV.B [W14+60], W4
00188A  52CF84     SUB.B W5, W4, [W15]
00188C  3A0007     BRA NZ, 0x189C
229:               		{
230:               			data++; //Increment past wildcard byte
00188E  901A5E     MOV [W14+58], W4
001890  E80204     INC W4, W4
001892  981F54     MOV W4, [W14+58]
231:               			BufPtr++; //Increment to ignore byte correspinding to wildcard
001894  90022E     MOV [W14+4], W4
001896  E80204     INC W4, W4
001898  980724     MOV W4, [W14+4]
00189A  370013     BRA 0x18C2
232:               		} else if (*data++ != *BufPtr++) //else see if the bytes are different
00189C  901A5E     MOV [W14+58], W4
00189E  784294     MOV.B [W4], W5
0018A0  90022E     MOV [W14+4], W4
0018A2  784214     MOV.B [W4], W4
0018A4  6AC204     XOR.B W5, W4, W4
0018A6  FB8204     ZE W4, W4
0018A8  EA0204     NEG W4, W4
0018AA  DE224F     LSR W4, #15, W4
0018AC  784204     MOV.B W4, W4
0018AE  901ADE     MOV [W14+58], W5
0018B0  E80285     INC W5, W5
0018B2  981F55     MOV W5, [W14+58]
0018B4  9002AE     MOV [W14+4], W5
0018B6  E80285     INC W5, W5
0018B8  980725     MOV W5, [W14+4]
0018BA  524FE0     SUB.B W4, #0x0, [W15]
0018BC  320002     BRA Z, 0x18C2
233:               			return false; //Bytes differ so return failure
0018BE  EB4200     CLR.B W4
0018C0  370006     BRA 0x18CE
234:               	}
235:               	return true; //All bytes matched or were ignored so return success
0018CC  B3C014     MOV.B #0x1, W4
236:               }
0018CE  784004     MOV.B W4, W0
0018D0  FA8000     ULNK
0018D2  060000     RETURN
237:               
238:               //**********************************************************************************************************************
239:               // Set up the RN4020 module
240:               
241:               bool BT_SetupModule(void)
242:               {
0018D4  FA001C     LNK #0x1C
243:               	BT_SendCommand("sf,2\r", false); //Get RN4020 module feature settings
0018D6  EB4080     CLR.B W1
0018D8  294400     MOV #0x9440, W0
0018DA  07FEC8     RCALL BT_SendCommand
244:               	if (!BT_CheckResponse(AOK)) {
0018DC  294460     MOV #0x9446, W0
0018DE  07FF4B     RCALL BT_CheckResponse
0018E0  784200     MOV.B W0, W4
0018E2  A20404     BTG.B W4, #0
0018E4  524FE0     SUB.B W4, #0x0, [W15]
0018E6  320002     BRA Z, 0x18EC
245:               		return false;
0018E8  EB4200     CLR.B W4
0018EA  370097     BRA 0x1A1A
246:               	}
247:               
248:               	//Send "GR" to get feature settings
249:               	BT_SendCommand("gr\r", false); //Get RN4020 module feature settings
0018EC  EB4080     CLR.B W1
0018EE  2944C0     MOV #0x944C, W0
0018F0  07FEBD     RCALL BT_SendCommand
250:               	if (!BT_CheckResponse("22000000\r\n")) //Check if features are set for auto advertize and flow control
0018F2  294500     MOV #0x9450, W0
0018F4  07FF40     RCALL BT_CheckResponse
0018F6  784200     MOV.B W0, W4
0018F8  A20404     BTG.B W4, #0
0018FA  524FE0     SUB.B W4, #0x0, [W15]
0018FC  32000B     BRA Z, 0x1914
251:               	{ //auto enable MLDP, suppress messages during MLDP
252:               		BT_SendCommand("sr,22000000\r", false); //Features not correect so set features
0018FE  EB4080     CLR.B W1
001900  2945B0     MOV #0x945B, W0
001902  07FEB4     RCALL BT_SendCommand
253:               		if (!BT_CheckResponse(AOK)) {
001904  294460     MOV #0x9446, W0
001906  07FF37     RCALL BT_CheckResponse
001908  784200     MOV.B W0, W4
00190A  A20404     BTG.B W4, #0
00190C  524FE0     SUB.B W4, #0x0, [W15]
00190E  320002     BRA Z, 0x1914
254:               			return false;
001910  EB4200     CLR.B W4
001912  370083     BRA 0x1A1A
255:               		}
256:               	}
257:               
258:               	char macAddr[16];
259:               	BT_SendCommand("gds\r", false); // Get mac address
001914  EB4080     CLR.B W1
001916  294680     MOV #0x9468, W0
001918  07FEA9     RCALL BT_SendCommand
260:               	while (!BT_ReceivePacket(macAddr));
00191A  000000     NOP
00191C  78000E     MOV W14, W0
00191E  07FE68     RCALL BT_ReceivePacket
001920  784200     MOV.B W0, W4
001922  A20404     BTG.B W4, #0
001924  524FE0     SUB.B W4, #0x0, [W15]
001926  3AFFFA     BRA NZ, 0x191C
261:               
262:               	char message[12];
263:               	macAddr[12] = '\0';
001928  EB4200     CLR.B W4
00192A  984F44     MOV.B W4, [W14+12]
264:               	sprintf(message, "sn,%s_BT\r", &macAddr[8]);
00192C  470270     ADD W14, #0x10, W4
00192E  4702E8     ADD W14, #0x8, W5
001930  781F85     MOV W5, [W15++]
001932  2946D5     MOV #0x946D, W5
001934  781F85     MOV W5, [W15++]
001936  780004     MOV W4, W0
001938  07F6F9     RCALL 0x72C
00193A  5787E4     SUB W15, #0x4, W15
265:               
266:               	BT_SendCommand(message, false); //Set advertise name
00193C  470270     ADD W14, #0x10, W4
00193E  EB4080     CLR.B W1
001940  780004     MOV W4, W0
001942  07FE94     RCALL BT_SendCommand
267:               	if (!BT_CheckResponse(AOK)) {
001944  294460     MOV #0x9446, W0
001946  07FF17     RCALL BT_CheckResponse
001948  784200     MOV.B W0, W4
00194A  A20404     BTG.B W4, #0
00194C  524FE0     SUB.B W4, #0x0, [W15]
00194E  320002     BRA Z, 0x1954
268:               		return false;
001950  EB4200     CLR.B W4
001952  370063     BRA 0x1A1A
269:               	}
270:               
271:               	BT_SendCommand("gs\r", false);
001954  EB4080     CLR.B W1
001956  294770     MOV #0x9477, W0
001958  07FE89     RCALL BT_SendCommand
272:               	if (!BT_CheckResponse("80000001\r\n")) {
00195A  2947B0     MOV #0x947B, W0
00195C  07FF0C     RCALL BT_CheckResponse
00195E  784200     MOV.B W0, W4
001960  A20404     BTG.B W4, #0
001962  524FE0     SUB.B W4, #0x0, [W15]
001964  32000B     BRA Z, 0x197C
273:               		//Send "SS" to set user defined private profiles
274:               		BT_SendCommand("ss,80000001\r", false);
001966  EB4080     CLR.B W1
001968  294860     MOV #0x9486, W0
00196A  07FE80     RCALL BT_SendCommand
275:               		if (!BT_CheckResponse(AOK)) {
00196C  294460     MOV #0x9446, W0
00196E  07FF03     RCALL BT_CheckResponse
001970  784200     MOV.B W0, W4
001972  A20404     BTG.B W4, #0
001974  524FE0     SUB.B W4, #0x0, [W15]
001976  320002     BRA Z, 0x197C
276:               			return false;
001978  EB4200     CLR.B W4
00197A  37004F     BRA 0x1A1A
277:               		}
278:               	}
279:               
280:               	// Clear all settings of private service and private characteristic
281:               	BT_SendCommand("pz\r", false);
00197C  EB4080     CLR.B W1
00197E  294930     MOV #0x9493, W0
001980  07FE75     RCALL BT_SendCommand
282:               	if (!BT_CheckResponse(AOK)) {
001982  294460     MOV #0x9446, W0
001984  07FEF8     RCALL BT_CheckResponse
001986  784200     MOV.B W0, W4
001988  A20404     BTG.B W4, #0
00198A  524FE0     SUB.B W4, #0x0, [W15]
00198C  320002     BRA Z, 0x1992
283:               		return false;
00198E  EB4200     CLR.B W4
001990  370044     BRA 0x1A1A
284:               	}
285:               
286:               	//Send "ps" to set user defined service UUID
287:               	BT_SendCommand("ps,"PRIVATE_SERVICE",\r", false);
001992  EB4080     CLR.B W1
001994  294970     MOV #0x9497, W0
001996  07FE6A     RCALL BT_SendCommand
288:               	if (!BT_CheckResponse(AOK)) {
001998  294460     MOV #0x9446, W0
00199A  07FEED     RCALL BT_CheckResponse
00199C  784200     MOV.B W0, W4
00199E  A20404     BTG.B W4, #0
0019A0  524FE0     SUB.B W4, #0x0, [W15]
0019A2  320002     BRA Z, 0x19A8
289:               		return false;
0019A4  EB4200     CLR.B W4
0019A6  370039     BRA 0x1A1A
290:               	}
291:               
292:               	// Custom button characteristic with generated UUID
293:               	BT_SendCommand("pc,"PRIVATE_CHAR_SWITCHES",22,02\r", false); //Indicate, Read
0019A8  EB4080     CLR.B W1
0019AA  294BD0     MOV #0x94BD, W0
0019AC  07FE5F     RCALL BT_SendCommand
294:               	if (!BT_CheckResponse(AOK)) {
0019AE  294460     MOV #0x9446, W0
0019B0  07FEE2     RCALL BT_CheckResponse
0019B2  784200     MOV.B W0, W4
0019B4  A20404     BTG.B W4, #0
0019B6  524FE0     SUB.B W4, #0x0, [W15]
0019B8  320002     BRA Z, 0x19BE
295:               		return false;
0019BA  EB4200     CLR.B W4
0019BC  37002E     BRA 0x1A1A
296:               	}
297:               
298:               	// Custom potentiometer characteristic with generated UUID
299:               	BT_SendCommand("pc,"PRIVATE_CHAR_POTENTIOMETER",22,02\r", false); //Indicate, Read
0019BE  EB4080     CLR.B W1
0019C0  294E80     MOV #0x94E8, W0
0019C2  07FE54     RCALL BT_SendCommand
300:               	if (!BT_CheckResponse(AOK)) {
0019C4  294460     MOV #0x9446, W0
0019C6  07FED7     RCALL BT_CheckResponse
0019C8  784200     MOV.B W0, W4
0019CA  A20404     BTG.B W4, #0
0019CC  524FE0     SUB.B W4, #0x0, [W15]
0019CE  320002     BRA Z, 0x19D4
301:               		return false;
0019D0  EB4200     CLR.B W4
0019D2  370023     BRA 0x1A1A
302:               	}
303:               
304:               	// Custom LED characteristic with generated UUID
305:               	BT_SendCommand("pc,"PRIVATE_CHAR_LEDS",0A,04\r", false); //Write w/ACK, Read
0019D4  EB4080     CLR.B W1
0019D6  295130     MOV #0x9513, W0
0019D8  07FE49     RCALL BT_SendCommand
306:               	if (!BT_CheckResponse(AOK)) {
0019DA  294460     MOV #0x9446, W0
0019DC  07FECC     RCALL BT_CheckResponse
0019DE  784200     MOV.B W0, W4
0019E0  A20404     BTG.B W4, #0
0019E2  524FE0     SUB.B W4, #0x0, [W15]
0019E4  320002     BRA Z, 0x19EA
307:               		return false;
0019E6  EB4200     CLR.B W4
0019E8  370018     BRA 0x1A1A
308:               	}
309:               
310:               	// Custom RELAY characteristic with generated UUID
311:               	BT_SendCommand("pc,"PRIVATE_CHAR_RELAYS",0A,04\r", false); //Write w/ACK, Read
0019EA  EB4080     CLR.B W1
0019EC  2953E0     MOV #0x953E, W0
0019EE  07FE3E     RCALL BT_SendCommand
312:               	if (!BT_CheckResponse(AOK)) {
0019F0  294460     MOV #0x9446, W0
0019F2  07FEC1     RCALL BT_CheckResponse
0019F4  784200     MOV.B W0, W4
0019F6  A20404     BTG.B W4, #0
0019F8  524FE0     SUB.B W4, #0x0, [W15]
0019FA  320002     BRA Z, 0x1A00
313:               		return false;
0019FC  EB4200     CLR.B W4
0019FE  37000D     BRA 0x1A1A
314:               	}
315:               
316:               	BT_SendCommand("wc\r", false); //Command to clear script, just in case there is a script
001A00  EB4080     CLR.B W1
001A02  295690     MOV #0x9569, W0
001A04  07FE33     RCALL BT_SendCommand
317:               	if (!BT_CheckResponse(AOK)) {
001A06  294460     MOV #0x9446, W0
001A08  07FEB6     RCALL BT_CheckResponse
001A0A  784200     MOV.B W0, W4
001A0C  A20404     BTG.B W4, #0
001A0E  524FE0     SUB.B W4, #0x0, [W15]
001A10  320002     BRA Z, 0x1A16
318:               		return false;
001A12  EB4200     CLR.B W4
001A14  370002     BRA 0x1A1A
319:               	}
320:               
321:               	//Send "R,1" to save changes and reboot
322:               	return BT_RebootEnFlow();
001A16  070004     RCALL BT_RebootEnFlow
001A18  784200     MOV.B W0, W4
323:               }
001A1A  784004     MOV.B W4, W0
001A1C  FA8000     ULNK
001A1E  060000     RETURN
324:               
325:               //**********************************************************************************************************************
326:               // Reboot the module and enable flow control on PIC UART
327:               
328:               bool BT_RebootEnFlow(void)
329:               {
001A20  FA0000     LNK #0x0
330:               	//Send "R,1" to save changes and reboot
331:               	BT_SendCommand("r,1\r", false); //Force reboot
001A22  EB4080     CLR.B W1
001A24  2956D0     MOV #0x956D, W0
001A26  07FE22     RCALL BT_SendCommand
332:               	if (!BT_CheckResponse("Reboot\r\n")) {
001A28  295720     MOV #0x9572, W0
001A2A  07FEA5     RCALL BT_CheckResponse
001A2C  784200     MOV.B W0, W4
001A2E  A20404     BTG.B W4, #0
001A30  524FE0     SUB.B W4, #0x0, [W15]
001A32  320002     BRA Z, 0x1A38
333:               		return false;
001A34  EB4200     CLR.B W4
001A36  370044     BRA 0x1AC0
334:               	}
335:               
336:               	//Disable UART while TX line from RN is low during reset and bootup
337:               	StartTimer(TMR_RN_COMMS, 1000);
001A38  203E81     MOV #0x3E8, W1
001A3A  B3C020     MOV.B #0x2, W0
001A3C  0704F1     RCALL StartTimer
338:               	U1MODE &= 0x7FFF;
001A3E  801105     MOV U1MODE, W5
001A40  27FFF4     MOV #0x7FFF, W4
001A42  628204     AND W5, W4, W4
001A44  881104     MOV W4, U1MODE
339:               	while (U1RX_PORT) {
001A46  370005     BRA 0x1A52
001A52  801654     MOV PORTB, W4
001A54  620264     AND W4, #0x4, W4
001A56  520FE0     SUB W4, #0x0, [W15]
001A58  3AFFF7     BRA NZ, 0x1A48
001A5A  370001     BRA 0x1A5E
340:               		if (TimerDone(TMR_RN_COMMS)) {
001A48  B3C020     MOV.B #0x2, W0
001A4A  0704F7     RCALL TimerDone
001A4C  784200     MOV.B W0, W4
001A4E  524FE0     SUB.B W4, #0x0, [W15]
001A50  3A0005     BRA NZ, 0x1A5C
341:               			break;
001A5C  000000     NOP
342:               		}
343:               	}
344:               	StartTimer(TMR_RN_COMMS, 4000);
001A5E  20FA01     MOV #0xFA0, W1
001A60  B3C020     MOV.B #0x2, W0
001A62  0704DE     RCALL StartTimer
345:               	while (!U1RX_PORT) {
001A64  370005     BRA 0x1A70
001A70  801654     MOV PORTB, W4
001A72  620264     AND W4, #0x4, W4
001A74  520FE0     SUB W4, #0x0, [W15]
001A76  32FFF7     BRA Z, 0x1A66
001A78  370001     BRA 0x1A7C
346:               		if (TimerDone(TMR_RN_COMMS)) {
001A66  B3C020     MOV.B #0x2, W0
001A68  0704E8     RCALL TimerDone
001A6A  784200     MOV.B W0, W4
001A6C  524FE0     SUB.B W4, #0x0, [W15]
001A6E  3A0005     BRA NZ, 0x1A7A
347:               			break;
001A7A  000000     NOP
348:               		}
349:               	}
350:               	UART_RX_IF = 0; //Clear UART Receive interrupt flag
001A7C  A96085     BCLR 0x85, #3
351:               	U1MODE |= 0x8200; //Enable UART, use RTC/CTS flow control
001A7E  801105     MOV U1MODE, W5
001A80  282004     MOV #0x8200, W4
001A82  720205     IOR W4, W5, W4
001A84  881104     MOV W4, U1MODE
352:               	U1STA |= 0x0400; //Enable transmit
001A86  801115     MOV U1STA, W5
001A88  204004     MOV #0x400, W4
001A8A  720205     IOR W4, W5, W4
001A8C  881114     MOV W4, U1STA
353:               
354:               	//Clear out NULL char(s) and other garbage if present after reboot, wait for first char of CMD\r\n response
355:               	StartTimer(TMR_RN_COMMS, 4000);
001A8E  20FA01     MOV #0xFA0, W1
001A90  B3C020     MOV.B #0x2, W0
001A92  0704C6     RCALL StartTimer
356:               	while (UART_ReadRxBuffer() != 'C') {
001A94  37000D     BRA 0x1AB0
001AB0  070301     RCALL UART_ReadRxBuffer
001AB2  784200     MOV.B W0, W4
001AB4  B3C435     MOV.B #0x43, W5
001AB6  524F85     SUB.B W4, W5, [W15]
001AB8  3AFFF5     BRA NZ, 0x1AA4
357:               		while (!UART_IsNewRxData()) {
001AA4  000000     NOP
001AA6  0702F9     RCALL UART_IsNewRxData
001AA8  784200     MOV.B W0, W4
001AAA  A20404     BTG.B W4, #0
001AAC  524FE0     SUB.B W4, #0x0, [W15]
001AAE  3AFFF3     BRA NZ, 0x1A96
358:               			if (TimerDone(TMR_RN_COMMS)) { //Check if timed out
001A96  B3C020     MOV.B #0x2, W0
001A98  0704D0     RCALL TimerDone
001A9A  784200     MOV.B W0, W4
001A9C  524FE0     SUB.B W4, #0x0, [W15]
001A9E  320003     BRA Z, 0x1AA6
359:               				return false; //If timed out then return failure
001AA0  EB4200     CLR.B W4
001AA2  37000E     BRA 0x1AC0
360:               			}
361:               		}
362:               	}
363:               
364:               	return BT_CheckResponse("MD\r\n"); //Check that we received CMD indicating reboot is done
001ABA  2957B0     MOV #0x957B, W0
001ABC  07FE5C     RCALL BT_CheckResponse
001ABE  784200     MOV.B W0, W4
365:               }
001AC0  784004     MOV.B W4, W0
001AC2  FA8000     ULNK
001AC4  060000     RETURN
366:               
367:               #ifdef VERIFY_RN_FW_VER
368:               //Retrieve firmware version on module and check against the required version
369:               //Returns true if version is correct; false if not or communication failure
370:               
371:               bool BT_CheckFwVer(void)
372:               {
001AC6  FA0082     LNK #0x82
373:               	char fpVer[20];
374:               	char *pfpVer = fpVer;
001AC8  470F64     ADD W14, #0x4, [W14]
375:               	char strVer[100];
376:               	char *pstrVer = strVer;
001ACA  470278     ADD W14, #0x18, W4
001ACC  980714     MOV W4, [W14+2]
377:               	uint16_t verMajor,
378:               		verMinor,
379:               		verPatch;
380:               
381:               	//flush UART RX buffer just in case there's old data
382:               	while (UART_IsNewRxData()) { //While buffer contains old data
001ACE  370003     BRA 0x1AD6
001AD6  0702E1     RCALL UART_IsNewRxData
001AD8  784200     MOV.B W0, W4
001ADA  524FE0     SUB.B W4, #0x0, [W15]
001ADC  3AFFF9     BRA NZ, 0x1AD0
383:               		UART_ReadRxBuffer(); //Keep reading until empty
001AD0  0702F1     RCALL UART_ReadRxBuffer
384:               		WaitMs(100);
001AD2  200640     MOV #0x64, W0
001AD4  0704C2     RCALL WaitMs
385:               	}
386:               
387:               	StartTimer(TMR_RN_COMMS, 2000);
001ADE  207D01     MOV #0x7D0, W1
001AE0  B3C020     MOV.B #0x2, W0
001AE2  07049E     RCALL StartTimer
388:               	BT_SendCommand("v\r", false); // Get firmware ver
001AE4  EB4080     CLR.B W1
001AE6  295800     MOV #0x9580, W0
001AE8  07FDC1     RCALL BT_SendCommand
389:               	while (!BT_ReceivePacket(strVer)) {
001AEA  370007     BRA 0x1AFA
001AFA  470278     ADD W14, #0x18, W4
001AFC  780004     MOV W4, W0
001AFE  07FD78     RCALL BT_ReceivePacket
001B00  784200     MOV.B W0, W4
001B02  A20404     BTG.B W4, #0
001B04  524FE0     SUB.B W4, #0x0, [W15]
001B06  3AFFF2     BRA NZ, 0x1AEC
390:               		if (TimerDone(TMR_RN_COMMS)) {
001AEC  B3C020     MOV.B #0x2, W0
001AEE  0704A5     RCALL TimerDone
001AF0  784200     MOV.B W0, W4
001AF2  524FE0     SUB.B W4, #0x0, [W15]
001AF4  320002     BRA Z, 0x1AFA
391:               			return false;
001AF6  EB4200     CLR.B W4
001AF8  370055     BRA 0x1BA4
392:               		}
393:               	}
394:               
395:               	//Skip to first digit
396:               	while ((*pstrVer < '0' || *pstrVer > '9') && *pstrVer != NULL) {
001B08  370003     BRA 0x1B10
001B10  90021E     MOV [W14+2], W4
001B12  784294     MOV.B [W4], W5
001B14  B3C2F4     MOV.B #0x2F, W4
001B16  52CF84     SUB.B W5, W4, [W15]
001B18  340005     BRA LE, 0x1B24
001B1A  90021E     MOV [W14+2], W4
001B1C  784294     MOV.B [W4], W5
001B1E  B3C394     MOV.B #0x39, W4
001B20  52CF84     SUB.B W5, W4, [W15]
001B22  34000E     BRA LE, 0x1B40
001B24  90021E     MOV [W14+2], W4
001B26  784214     MOV.B [W4], W4
001B28  524FE0     SUB.B W4, #0x0, [W15]
001B2A  3AFFEF     BRA NZ, 0x1B0A
397:               		pstrVer++;
001B0A  90021E     MOV [W14+2], W4
001B0C  E80204     INC W4, W4
001B0E  980714     MOV W4, [W14+2]
398:               	}
399:               	//Extract version number
400:               	while ((*pstrVer >= '0' && *pstrVer <= '9') || *pstrVer == '.') {
001B2C  37000A     BRA 0x1B42
001B40  000000     NOP
001B42  90021E     MOV [W14+2], W4
001B44  784294     MOV.B [W4], W5
001B46  B3C2F4     MOV.B #0x2F, W4
001B48  52CF84     SUB.B W5, W4, [W15]
001B4A  340005     BRA LE, 0x1B56
001B4C  90021E     MOV [W14+2], W4
001B4E  784294     MOV.B [W4], W5
001B50  B3C394     MOV.B #0x39, W4
001B52  52CF84     SUB.B W5, W4, [W15]
001B54  34FFEC     BRA LE, 0x1B2E
001B56  90021E     MOV [W14+2], W4
001B58  784294     MOV.B [W4], W5
001B5A  B3C2E4     MOV.B #0x2E, W4
001B5C  52CF84     SUB.B W5, W4, [W15]
001B5E  32FFE7     BRA Z, 0x1B2E
401:               		*pfpVer = *pstrVer;
001B2E  90021E     MOV [W14+2], W4
001B30  784214     MOV.B [W4], W4
001B32  78029E     MOV [W14], W5
001B34  784A84     MOV.B W4, [W5]
402:               		pfpVer++;
001B36  E80F1E     INC [W14], [W14]
403:               		pstrVer++;
001B38  90021E     MOV [W14+2], W4
001B3A  E80204     INC W4, W4
001B3C  980714     MOV W4, [W14+2]
001B3E  370001     BRA 0x1B42
404:               	}
405:               	*pfpVer = '\0';
001B60  78029E     MOV [W14], W5
001B62  EB4200     CLR.B W4
001B64  784A84     MOV.B W4, [W5]
406:               
407:               	//Tokenize and convert to unsigned
408:               	sscanf(fpVer, "%u.%u.%u", &verMajor, &verMinor, &verPatch);
001B66  470264     ADD W14, #0x4, W4
001B68  200805     MOV #0x80, W5
001B6A  42828E     ADD W5, W14, W5
001B6C  781F85     MOV W5, [W15++]
001B6E  2007E5     MOV #0x7E, W5
001B70  42828E     ADD W5, W14, W5
001B72  781F85     MOV W5, [W15++]
001B74  2007C5     MOV #0x7C, W5
001B76  42828E     ADD W5, W14, W5
001B78  781F85     MOV W5, [W15++]
001B7A  295835     MOV #0x9583, W5
001B7C  781F85     MOV W5, [W15++]
001B7E  780004     MOV W4, W0
001B80  07F447     RCALL 0x410
001B82  5787E8     SUB W15, #0x8, W15
409:               
410:               	//Verify version number
411:               	if (verMajor != RN_FW_VER_MAJOR) {
001B84  903A6E     MOV [W14+124], W4
001B86  520FE1     SUB W4, #0x1, [W15]
001B88  320002     BRA Z, 0x1B8E
412:               		return false;
001B8A  EB4200     CLR.B W4
001B8C  37000B     BRA 0x1BA4
413:               	}
414:               	if (verMinor != RN_FW_VER_MINOR) {
001B8E  903A7E     MOV [W14+126], W4
001B90  520FF7     SUB W4, #0x17, [W15]
001B92  320002     BRA Z, 0x1B98
415:               		return false;
001B94  EB4200     CLR.B W4
001B96  370006     BRA 0x1BA4
416:               	}
417:               	if (verPatch != RN_FW_VER_PATCH) {
001B98  90820E     MOV [W14+128], W4
001B9A  520FE5     SUB W4, #0x5, [W15]
001B9C  320002     BRA Z, 0x1BA2
418:               		return false;
001B9E  EB4200     CLR.B W4
001BA0  370001     BRA 0x1BA4
419:               	}
420:               
421:               	return true;
001BA2  B3C014     MOV.B #0x1, W4
422:               }
001BA4  784004     MOV.B W4, W0
001BA6  FA8000     ULNK
001BA8  060000     RETURN
423:               #endif //VERIFY_RN_FW_VER
---  /sdd/work/fac_relay_clone/app.c  -------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        app.c
29:                 * Date:        July 24, 2014
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 */
33:                
34:                // *****************************************************************************
35:                // *****************************************************************************
36:                // Section: Included Files
37:                // *****************************************************************************
38:                // *****************************************************************************
39:                
40:                #include <xc.h>
41:                #include <stdint.h>
42:                #include <stdbool.h>
43:                #include <stdio.h>
44:                #include <string.h>
45:                #include "app.h"
46:                #include "config.h"
47:                #include "timers.h"
48:                #include "uart.h"
49:                #include "bluetooth.h"
50:                #include "adc.h"
51:                #include "leds.h"
52:                #include "switches.h"
53:                #include "comparator.h"
54:                #include "rtcc.h"
55:                #include "sleep.h"
56:                
57:                APP_DATA appData;
58:                
59:                //Primary application state machine
60:                
61:                void APP_Tasks(void)
62:                {
001BAA  FA0000     LNK #0x0
63:                #ifdef USE_SLEEP                //see config.h, Application setting section
64:                	APP_STATE_T savedState;
65:                	int16_t potDiff;
66:                
67:                	//Has inactivity timer expired?
68:                	if (appData.sleepFlag) {
69:                		savedState = appData.state; //Save context
70:                		appData.state = APP_SLEEP; //Enter sleep state
71:                	}
72:                #endif
73:                
74:                	//Update LED outputs
75:                	LED_Tasks();
001BAC  07016C     RCALL LED_Tasks
76:                
77:                	//Time to check battery/input voltage?
78:                	if (TimerDone(TMR_BAT_CHECK) && appData.state != APP_INITIALIZE) {
001BAE  B3C0A0     MOV.B #0xA, W0
001BB0  070444     RCALL TimerDone
001BB2  784200     MOV.B W0, W4
001BB4  524FE0     SUB.B W4, #0x0, [W15]
001BB6  320008     BRA Z, 0x1BC8
001BB8  805064     MOV appData, W4
001BBA  520FE0     SUB W4, #0x0, [W15]
001BBC  320005     BRA Z, 0x1BC8
79:                		StartTimer(TMR_BAT_CHECK, CMP_Tasks()); //Run tasks and restart timer
001BBE  0704DE     RCALL CMP_Tasks
001BC0  780200     MOV W0, W4
001BC2  780084     MOV W4, W1
001BC4  B3C0A0     MOV.B #0xA, W0
001BC6  07042C     RCALL StartTimer
80:                	}
81:                
82:                	switch (appData.state) {
001BC8  805064     MOV appData, W4
001BCA  200005     MOV #0x0, W5
001BCC  200036     MOV #0x3, W6
001BCE  200007     MOV #0x0, W7
001BD0  520F86     SUB W4, W6, [W15]
001BD2  5A8F87     SUBB W5, W7, [W15]
001BD4  3E0097     BRA GTU, 0x1D04
001BD6  016004     BRA W4
001BD8  370003     BRA 0x1BE0
001BDA  37000C     BRA 0x1BF4
001BDC  37000E     BRA 0x1BFA
001BDE  370016     BRA 0x1C0C
83:                		//Initial state
84:                	case APP_INITIALIZE:
85:                		if (APP_Initialize()) {
001BE0  07009A     RCALL APP_Initialize
001BE2  784200     MOV.B W0, W4
001BE4  524FE0     SUB.B W4, #0x0, [W15]
001BE6  320003     BRA Z, 0x1BEE
86:                			appData.state = APP_BLUETOOTH_ADVERTISE;
001BE8  200024     MOV #0x2, W4
001BEA  885064     MOV W4, appData
87:                		} else {
88:                			appData.state = APP_INITIALIZATION_ERROR;
001BEE  200014     MOV #0x1, W4
001BF0  885064     MOV W4, appData
89:                		}
90:                		break;
001BEC  370092     BRA 0x1D12
001BF2  37008F     BRA 0x1D12
91:                
92:                		//Initialization failed
93:                	case APP_INITIALIZATION_ERROR:
94:                		LED_SET_LightShow(LED_ERROR);
001BF4  200030     MOV #0x3, W0
001BF6  070203     RCALL LED_SET_LightShow
95:                		break;
001BF8  37008C     BRA 0x1D12
96:                
97:                		//We're not connected to a device - advertise mode
98:                	case APP_BLUETOOTH_ADVERTISE:
99:                		LED_SET_LightShow(LED_BTLE_ADVERTISING);
001BFA  200010     MOV #0x1, W0
001BFC  070200     RCALL LED_SET_LightShow
100:               		if (BT_CONNECTED) {
001BFE  801614     MOV PORTA, W4
001C00  620262     AND W4, #0x2, W4
001C02  520FE0     SUB W4, #0x0, [W15]
001C04  320081     BRA Z, 0x1D08
101:               			appData.state = APP_BLUETOOTH_PAIRED;
001C06  200034     MOV #0x3, W4
001C08  885064     MOV W4, appData
102:               		}
103:               		break;
001C0A  370083     BRA 0x1D12
001D08  000000     NOP
001D0A  370003     BRA 0x1D12
104:               
105:               		//We are connected to a BTLE device
106:               	case APP_BLUETOOTH_PAIRED:
107:               		//Update LEDs
108:               		LED_SET_LightShow(LED_BTLE_PAIRED);
001C0C  200020     MOV #0x2, W0
001C0E  0701F7     RCALL LED_SET_LightShow
109:               		//Check to see if we are still connected; return to advertise state if not
110:               		if (!BT_CONNECTED) {
001C10  801614     MOV PORTA, W4
001C12  620262     AND W4, #0x2, W4
001C14  520FE0     SUB W4, #0x0, [W15]
001C16  3A0005     BRA NZ, 0x1C22
111:               			LED_SET_LightShow(LED_BTLE_ADVERTISING);
001C18  200010     MOV #0x1, W0
001C1A  0701F1     RCALL LED_SET_LightShow
112:               			appData.state = APP_BLUETOOTH_ADVERTISE;
001C1C  200024     MOV #0x2, W4
001C1E  885064     MOV W4, appData
113:               			break;
001C20  370078     BRA 0x1D12
114:               		}
115:               
116:               		//Check if switches have changed and debounce timers are expired
117:               		Switch_Tasks();
001C22  070450     RCALL Switch_Tasks
118:               		if (appData.sendSwitches) { //New switch status to send?
001C24  20AD74     MOV #0xAD7, W4
001C26  784214     MOV.B [W4], W4
001C28  524FE0     SUB.B W4, #0x0, [W15]
001C2A  32001F     BRA Z, 0x1C6A
119:               			//Form message
120:               			sprintf(appData.transmit_packet, "suw,"PRIVATE_CHAR_SWITCHES",%d%d%d%d\r", appData.sw1, appData.sw2, appData.sw3, appData.sw4);
001C2C  20AE34     MOV #0xAE3, W4
001C2E  784214     MOV.B [W4], W4
001C30  FB8384     ZE W4, W7
001C32  20AE24     MOV #0xAE2, W4
001C34  784214     MOV.B [W4], W4
001C36  FB8304     ZE W4, W6
001C38  20AE14     MOV #0xAE1, W4
001C3A  784214     MOV.B [W4], W4
001C3C  FB8284     ZE W4, W5
001C3E  20AE04     MOV #0xAE0, W4
001C40  784214     MOV.B [W4], W4
001C42  FB8204     ZE W4, W4
001C44  781F87     MOV W7, [W15++]
001C46  781F86     MOV W6, [W15++]
001C48  781F85     MOV W5, [W15++]
001C4A  781F84     MOV W4, [W15++]
001C4C  2958C4     MOV #0x958C, W4
001C4E  781F84     MOV W4, [W15++]
001C50  20A720     MOV #0xA72, W0
001C52  07F56C     RCALL 0x72C
001C54  5787EA     SUB W15, #0xA, W15
121:               			//Try to transmit the message; reset flag if successful
122:               			if (BT_SendCommand(appData.transmit_packet, true)) {
001C56  B3C011     MOV.B #0x1, W1
001C58  20A720     MOV #0xA72, W0
001C5A  07FD08     RCALL BT_SendCommand
001C5C  784200     MOV.B W0, W4
001C5E  524FE0     SUB.B W4, #0x0, [W15]
001C60  320004     BRA Z, 0x1C6A
123:               				appData.sendSwitches = false;
001C62  EB4200     CLR.B W4
001C64  FD0200     EXCH W0, W4
001C66  B7EAD7     MOV.B WREG, 0xAD7
001C68  FD0200     EXCH W0, W4
124:               			}
125:               		}
126:               
127:               		//Process ADC accumulator value if oversampling is complete
128:               		if (appData.accumReady) {
001C6A  20AE94     MOV #0xAE9, W4
001C6C  784214     MOV.B [W4], W4
001C6E  524FE0     SUB.B W4, #0x0, [W15]
001C70  320007     BRA Z, 0x1C80
129:               			ADC_ProcAccum();
001C72  07047B     RCALL ADC_ProcAccum
130:               #ifdef USE_SLEEP                //see config.h, Application setting section
131:               			potDiff = appData.potValue - appData.potValueOld; //Reset the inactivity sleep timer if pot has changed
132:               			if (potDiff > POT_KEEP_AWAKE_DELTA || potDiff < -POT_KEEP_AWAKE_DELTA) {
133:               				SleepTimerReset();
134:               			}
135:               #endif
136:               			appData.accumReady = false; //Clear app flags
001C74  EB4200     CLR.B W4
001C76  780004     MOV W4, W0
001C78  B7EAE9     MOV.B WREG, 0xAE9
137:               			appData.ADCinUse = false;
001C7A  EB4200     CLR.B W4
001C7C  780004     MOV W4, W0
001C7E  B7EAEA     MOV.B WREG, 0xAEA
138:               		}
139:               
140:               		//Start new ADC read if timer expired, not currently sampling, and not waiting to process accumulator
141:               		if (TimerDone(TMR_ADC) && appData.ADCinUse == false) {
001C80  B3C030     MOV.B #0x3, W0
001C82  0703DB     RCALL TimerDone
001C84  784200     MOV.B W0, W4
001C86  524FE0     SUB.B W4, #0x0, [W15]
001C88  32000C     BRA Z, 0x1CA2
001C8A  20AEA4     MOV #0xAEA, W4
001C8C  784214     MOV.B [W4], W4
001C8E  A20404     BTG.B W4, #0
001C90  524FE0     SUB.B W4, #0x0, [W15]
001C92  320007     BRA Z, 0x1CA2
142:               			if (ADC_Tasks()) {
001C94  070465     RCALL ADC_Tasks
001C96  784200     MOV.B W0, W4
001C98  524FE0     SUB.B W4, #0x0, [W15]
001C9A  320003     BRA Z, 0x1CA2
143:               				StartTimer(TMR_ADC, ADC_REFRESH_MS);
001C9C  200321     MOV #0x32, W1
001C9E  B3C030     MOV.B #0x3, W0
001CA0  0703BF     RCALL StartTimer
144:               			} //Restart timer once module is up and running
145:               		}
146:               
147:               		//Transmit new potentiometer reading?
148:               		if (TimerDone(TMR_POT)) {
001CA2  B3C040     MOV.B #0x4, W0
001CA4  0703CA     RCALL TimerDone
001CA6  784200     MOV.B W0, W4
001CA8  524FE0     SUB.B W4, #0x0, [W15]
001CAA  32001A     BRA Z, 0x1CE0
149:               			//Send message only if pot value has changed
150:               			if (appData.potValue != appData.potValueLastTX) {
001CAC  805775     MOV 0xAEE, W5
001CAE  805794     MOV 0xAF2, W4
001CB0  528F84     SUB W5, W4, [W15]
001CB2  320013     BRA Z, 0x1CDA
151:               				//Form message
152:               				sprintf(appData.transmit_packet, "suw,"PRIVATE_CHAR_POTENTIOMETER",%04d\r", appData.potValue);
001CB4  805774     MOV 0xAEE, W4
001CB6  781F84     MOV W4, [W15++]
001CB8  295BB4     MOV #0x95BB, W4
001CBA  781F84     MOV W4, [W15++]
001CBC  20A720     MOV #0xA72, W0
001CBE  07F536     RCALL 0x72C
001CC0  5787E4     SUB W15, #0x4, W15
153:               				//Try to transmit the message; reset timer if successful
154:               				if (BT_SendCommand(appData.transmit_packet, true)) {
001CC2  B3C011     MOV.B #0x1, W1
001CC4  20A720     MOV #0xA72, W0
001CC6  07FCD2     RCALL BT_SendCommand
001CC8  784200     MOV.B W0, W4
001CCA  524FE0     SUB.B W4, #0x0, [W15]
001CCC  320009     BRA Z, 0x1CE0
155:               					appData.potValueLastTX = appData.potValue;
001CCE  805774     MOV 0xAEE, W4
001CD0  885794     MOV W4, 0xAF2
156:               					StartTimer(TMR_POT, POT_TX_MS);
001CD2  201F41     MOV #0x1F4, W1
001CD4  B3C040     MOV.B #0x4, W0
001CD6  0703A4     RCALL StartTimer
001CD8  370003     BRA 0x1CE0
157:               				}
158:               			} else {
159:               				StartTimer(TMR_POT, POT_TX_MS);
001CDA  201F41     MOV #0x1F4, W1
001CDC  B3C040     MOV.B #0x4, W0
001CDE  0703A0     RCALL StartTimer
160:               			} //value not changed - skip this transmission
161:               		}
162:               
163:               		//Process any new messages received from RN module
164:               		appData.got_packet = BT_ReceivePacket(appData.receive_packet); //Get new message if one has been received from the RN4020
001CE0  20A0E0     MOV #0xA0E, W0
001CE2  07FC86     RCALL BT_ReceivePacket
001CE4  784200     MOV.B W0, W4
001CE6  FD0200     EXCH W0, W4
001CE8  B7EAD6     MOV.B WREG, 0xAD6
001CEA  FD0200     EXCH W0, W4
165:               		if (appData.got_packet == true) { //true if new packet received
001CEC  20AD64     MOV #0xAD6, W4
001CEE  784214     MOV.B [W4], W4
001CF0  524FE0     SUB.B W4, #0x0, [W15]
001CF2  32000C     BRA Z, 0x1D0C
166:               			if (strstr(appData.receive_packet, "WV,001E,")) { //Check for LED update message
001CF4  295E61     MOV #0x95E6, W1
001CF6  20A0E0     MOV #0xA0E, W0
001CF8  07F355     RCALL 0x3A4
001CFA  780200     MOV W0, W4
001CFC  520FE0     SUB W4, #0x0, [W15]
001CFE  320008     BRA Z, 0x1D10
167:               				GetNewLEDs(); //Latch new LED values
001D00  070184     RCALL GetNewLEDs
168:               			}
169:               			//
170:               			//Other message handling can be added here
171:               			//
172:               		}
173:               		break;
001D02  370007     BRA 0x1D12
001D0C  000000     NOP
001D0E  370001     BRA 0x1D12
001D10  000000     NOP
174:               
175:               #ifdef USE_SLEEP                //see config.h, Application setting section        
176:               		//Put micro and RN module to sleep - any button press will cause wake up
177:               	case APP_SLEEP:
178:               		appData.sleepFlag = 0; //clear flag and call sleep function
179:               		APP_SleepNow();
180:               		appData.state = savedState; //Woken from sleep; restore state
181:               		break;
182:               #endif //USE_SLEEP
183:               
184:               	default:
185:               		break;
001D04  000000     NOP
001D06  370005     BRA 0x1D12
186:               	} //end switch(appData.state)
187:               } //end APP_Tasks()
001D12  FA8000     ULNK
001D14  060000     RETURN
188:               
189:               //Sets up the RN module
190:               
191:               bool APP_Initialize(void)
192:               {
001D16  FA0000     LNK #0x0
193:               	/****************************************************************************
194:               	 * Initialize appData structure
195:               	 ***************************************************************************/
196:               	appData.error_code = ERROR_NONE;
001D18  B3C014     MOV.B #0x1, W4
001D1A  FD0200     EXCH W0, W4
001D1C  B7EADF     MOV.B WREG, 0xADF
001D1E  FD0200     EXCH W0, W4
197:               	appData.got_packet = false;
001D20  EB4200     CLR.B W4
001D22  FD0200     EXCH W0, W4
001D24  B7EAD6     MOV.B WREG, 0xAD6
001D26  FD0200     EXCH W0, W4
198:               	appData.potValue = 0;
001D28  EB0200     CLR W4
001D2A  885774     MOV W4, 0xAEE
199:               	appData.potValueOld = 0xFFFF;
001D2C  EB8200     SETM W4
001D2E  885784     MOV W4, 0xAF0
200:               	appData.potValueLastTX = 0xFFFF;
001D30  EB8200     SETM W4
001D32  885794     MOV W4, 0xAF2
201:               	appData.state = APP_INITIALIZE;
001D34  EB0200     CLR W4
001D36  885064     MOV W4, appData
202:               	appData.sw1 = false;
001D38  EB4200     CLR.B W4
001D3A  FD0200     EXCH W0, W4
001D3C  B7EAE0     MOV.B WREG, 0xAE0
001D3E  FD0200     EXCH W0, W4
203:               	appData.sw2 = false;
001D40  EB4200     CLR.B W4
001D42  FD0200     EXCH W0, W4
001D44  B7EAE1     MOV.B WREG, 0xAE1
001D46  FD0200     EXCH W0, W4
204:               	appData.sw3 = false;
001D48  EB4200     CLR.B W4
001D4A  FD0200     EXCH W0, W4
001D4C  B7EAE2     MOV.B WREG, 0xAE2
001D4E  FD0200     EXCH W0, W4
205:               	appData.sw4 = false;
001D50  EB4200     CLR.B W4
001D52  FD0200     EXCH W0, W4
001D54  B7EAE3     MOV.B WREG, 0xAE3
001D56  FD0200     EXCH W0, W4
206:               	appData.led1 = 0;
001D58  EB4200     CLR.B W4
001D5A  FD0200     EXCH W0, W4
001D5C  B7EAD9     MOV.B WREG, 0xAD9
001D5E  FD0200     EXCH W0, W4
207:               	appData.led2 = 0;
001D60  EB4200     CLR.B W4
001D62  FD0200     EXCH W0, W4
001D64  B7EADA     MOV.B WREG, 0xADA
001D66  FD0200     EXCH W0, W4
208:               	appData.led3 = 0;
001D68  EB4200     CLR.B W4
001D6A  FD0200     EXCH W0, W4
001D6C  B7EADB     MOV.B WREG, 0xADB
001D6E  FD0200     EXCH W0, W4
209:               	appData.led4 = 0;
001D70  EB4200     CLR.B W4
001D72  FD0200     EXCH W0, W4
001D74  B7EADC     MOV.B WREG, 0xADC
001D76  FD0200     EXCH W0, W4
210:               	appData.led5 = 0;
001D78  EB4200     CLR.B W4
001D7A  FD0200     EXCH W0, W4
001D7C  B7EADD     MOV.B WREG, 0xADD
001D7E  FD0200     EXCH W0, W4
211:               	appData.led6 = 0;
001D80  EB4200     CLR.B W4
001D82  FD0200     EXCH W0, W4
001D84  B7EADE     MOV.B WREG, 0xADE
001D86  FD0200     EXCH W0, W4
212:               	appData.sw1Changed = false;
001D88  EB4200     CLR.B W4
001D8A  FD0200     EXCH W0, W4
001D8C  B7EAE4     MOV.B WREG, 0xAE4
001D8E  FD0200     EXCH W0, W4
213:               	appData.sw2Changed = false;
001D90  EB4200     CLR.B W4
001D92  FD0200     EXCH W0, W4
001D94  B7EAE5     MOV.B WREG, 0xAE5
001D96  FD0200     EXCH W0, W4
214:               	appData.sw3Changed = false;
001D98  EB4200     CLR.B W4
001D9A  FD0200     EXCH W0, W4
001D9C  B7EAE6     MOV.B WREG, 0xAE6
001D9E  FD0200     EXCH W0, W4
215:               	appData.sw4Changed = false;
001DA0  EB4200     CLR.B W4
001DA2  FD0200     EXCH W0, W4
001DA4  B7EAE7     MOV.B WREG, 0xAE7
001DA6  FD0200     EXCH W0, W4
216:               	appData.sendSwitches = false;
001DA8  EB4200     CLR.B W4
001DAA  FD0200     EXCH W0, W4
001DAC  B7EAD7     MOV.B WREG, 0xAD7
001DAE  FD0200     EXCH W0, W4
217:               	appData.ADCcalFlag = false;
001DB0  EB4200     CLR.B W4
001DB2  FD0200     EXCH W0, W4
001DB4  B7EAD8     MOV.B WREG, 0xAD8
001DB6  FD0200     EXCH W0, W4
218:               	appData.sleepFlag = false;
001DB8  EB4200     CLR.B W4
001DBA  FD0200     EXCH W0, W4
001DBC  B7EAED     MOV.B WREG, 0xAED
001DBE  FD0200     EXCH W0, W4
219:               	appData.RTCCalarm = false;
001DC0  EB4200     CLR.B W4
001DC2  FD0200     EXCH W0, W4
001DC4  B7EAE8     MOV.B WREG, 0xAE8
001DC6  FD0200     EXCH W0, W4
220:               	appData.accumReady = false;
001DC8  EB4200     CLR.B W4
001DCA  FD0200     EXCH W0, W4
001DCC  B7EAE9     MOV.B WREG, 0xAE9
001DCE  FD0200     EXCH W0, W4
221:               	appData.ADCinUse = false;
001DD0  EB4200     CLR.B W4
001DD2  FD0200     EXCH W0, W4
001DD4  B7EAEA     MOV.B WREG, 0xAEA
001DD6  FD0200     EXCH W0, W4
222:               	appData.timer1Flag = false;
001DD8  EB4200     CLR.B W4
001DDA  FD0200     EXCH W0, W4
001DDC  B7EAEB     MOV.B WREG, 0xAEB
001DDE  FD0200     EXCH W0, W4
223:               
224:               	/****************************************************************************
225:               	 * Peripherals Init
226:               	 ***************************************************************************/
227:               	ADC_Init(); //Initialize the pADC
001DE0  0703BC     RCALL ADC_Init
228:               	UART_Init(); //Initialize the UART
001DE2  07013E     RCALL UART_Init
229:               	Timers_Init(); //Initialize the timers
001DE4  07030E     RCALL Timers_Init
230:               	CMP_Init(); //Initialize CVref and CMP2
001DE6  0703CF     RCALL CMP_Init
231:               
232:               #ifdef USE_SLEEP            //see config.h, Application settings section
233:               #ifdef SLEEP_MODE_RTCC
234:               	RTCC_Init();
235:               #endif  //SLEEP_MODE_RTCC
236:               #endif  //USE_SLEEP
237:               
238:               	BT_WAKE_SW = 1; //wake module
001DE8  A862CD     BSET 0x2CD, #3
239:               	//Wait for WS status high
240:               	StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
001DEA  20FA01     MOV #0xFA0, W1
001DEC  B3C020     MOV.B #0x2, W0
001DEE  070318     RCALL StartTimer
241:               	while (BT_WS == 0) {
001DF0  37000B     BRA 0x1E08
001E08  801614     MOV PORTA, W4
001E0A  620264     AND W4, #0x4, W4
001E0C  520FE0     SUB W4, #0x0, [W15]
001E0E  32FFF1     BRA Z, 0x1DF2
242:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001DF2  B3C020     MOV.B #0x2, W0
001DF4  070322     RCALL TimerDone
001DF6  784200     MOV.B W0, W4
001DF8  524FE0     SUB.B W4, #0x0, [W15]
001DFA  320006     BRA Z, 0x1E08
243:               		{
244:               			appData.error_code = ERROR_INITIALIZATION;
001DFC  B3CFE4     MOV.B #0xFE, W4
001DFE  FD0200     EXCH W0, W4
001E00  B7EADF     MOV.B WREG, 0xADF
001E02  FD0200     EXCH W0, W4
245:               			return false;
001E04  EB4200     CLR.B W4
001E06  37003C     BRA 0x1E80
246:               		}
247:               	}
248:               
249:               	//Wait for end of "CMD\r\n" - we don't check for full "CMD\r\n" string because we may 
250:               	//miss some bits or bytes at the beginning while the UART starts up
251:               	StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
001E10  20FA01     MOV #0xFA0, W1
001E12  B3C020     MOV.B #0x2, W0
001E14  070305     RCALL StartTimer
252:               	while (UART_ReadRxBuffer() != '\n') {
001E16  37000B     BRA 0x1E2E
001E2E  070142     RCALL UART_ReadRxBuffer
001E30  784200     MOV.B W0, W4
001E32  524FEA     SUB.B W4, #0xA, [W15]
001E34  3AFFF1     BRA NZ, 0x1E18
253:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001E18  B3C020     MOV.B #0x2, W0
001E1A  07030F     RCALL TimerDone
001E1C  784200     MOV.B W0, W4
001E1E  524FE0     SUB.B W4, #0x0, [W15]
001E20  320006     BRA Z, 0x1E2E
254:               		{
255:               			appData.error_code = ERROR_INITIALIZATION;
001E22  B3CFE4     MOV.B #0xFE, W4
001E24  FD0200     EXCH W0, W4
001E26  B7EADF     MOV.B WREG, 0xADF
001E28  FD0200     EXCH W0, W4
256:               			return false;
001E2A  EB4200     CLR.B W4
001E2C  370029     BRA 0x1E80
257:               		}
258:               	}
259:               	//Module is now in command mode and ready for input
260:               	if (!BT_SetupModule()) { //Setup RN4020 module
001E36  07FD4E     RCALL BT_SetupModule
001E38  784200     MOV.B W0, W4
001E3A  A20404     BTG.B W4, #0
001E3C  524FE0     SUB.B W4, #0x0, [W15]
001E3E  320006     BRA Z, 0x1E4C
261:               		appData.error_code = ERROR_INITIALIZATION;
001E40  B3CFE4     MOV.B #0xFE, W4
001E42  FD0200     EXCH W0, W4
001E44  B7EADF     MOV.B WREG, 0xADF
001E46  FD0200     EXCH W0, W4
262:               		return false;
001E48  EB4200     CLR.B W4
001E4A  37001A     BRA 0x1E80
263:               	}
264:               
265:               #ifdef VERIFY_RN_FW_VER
266:               	//Verify RN4020 module's firmware version
267:               	if (!BT_CheckFwVer()) {
001E4C  07FE3C     RCALL BT_CheckFwVer
001E4E  784200     MOV.B W0, W4
001E50  A20404     BTG.B W4, #0
001E52  524FE0     SUB.B W4, #0x0, [W15]
001E54  32000F     BRA Z, 0x1E74
268:               		appData.error_code = ERROR_RN_FW;
001E56  B3CFD4     MOV.B #0xFD, W4
001E58  FD0200     EXCH W0, W4
001E5A  B7EADF     MOV.B WREG, 0xADF
001E5C  FD0200     EXCH W0, W4
269:               		return false;
001E5E  EB4200     CLR.B W4
001E60  37000F     BRA 0x1E80
270:               	}
271:               #endif // VERIFY_RN_FW_VER  
272:               
273:               	//flush UART RX buffer as a precaution before starting app state machine
274:               	while (UART_IsNewRxData()) { //While buffer contains old data
001E74  000000     NOP
001E76  070111     RCALL UART_IsNewRxData
001E78  784200     MOV.B W0, W4
001E7A  524FE0     SUB.B W4, #0x0, [W15]
001E7C  3AFFF2     BRA NZ, 0x1E62
275:               		UART_ReadRxBuffer(); //Keep reading until empty
001E62  070128     RCALL UART_ReadRxBuffer
276:               		if (!UART_IsNewRxData()) {
001E64  07011A     RCALL UART_IsNewRxData
001E66  784200     MOV.B W0, W4
001E68  A20404     BTG.B W4, #0
001E6A  524FE0     SUB.B W4, #0x0, [W15]
001E6C  320004     BRA Z, 0x1E76
277:               			WaitMs(100);
001E6E  200640     MOV #0x64, W0
001E70  0702F4     RCALL WaitMs
001E72  370001     BRA 0x1E76
278:               		}
279:               	}
280:               
281:               	return true;
001E7E  B3C014     MOV.B #0x1, W4
282:               }
001E80  784004     MOV.B W4, W0
001E82  FA8000     ULNK
001E84  060000     RETURN
---  /sdd/work/fac_relay_clone/adc.c  -------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        adc.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 *
33:                 */
34:                
35:                #include <xc.h>
36:                #include <stdint.h>
37:                #include <stdbool.h>
38:                #include "adc.h"
39:                #include "app.h"
40:                #include "config.h"
41:                #include "timers.h"
42:                
43:                extern APP_DATA appData;
44:                
45:                /******************************************************************************
46:                 * Function:        void ADC_Init()
47:                 *
48:                 * PreCondition:    None
49:                 *
50:                 * Input:           None
51:                 *
52:                 * Output:          None
53:                 *
54:                 * Side Effects:    None
55:                 *
56:                 * Overview:        This routine initializes the ADC 
57:                 *                 
58:                 * Note:
59:                 *
60:                 *****************************************************************************/
61:                
62:                void ADC_Init()
63:                {
00255A  FA0000     LNK #0x0
64:                
65:                }
00255C  FA8000     ULNK
00255E  060000     RETURN
66:                
67:                //State machine for restarting ADC and taking new readings from pot
68:                //Returns true when module is on, calibrated, and started sampling; false otherwise
69:                
70:                bool ADC_Tasks(void)
71:                {
002560  FA0000     LNK #0x0
72:                	return true;
002562  B3C014     MOV.B #0x1, W4
73:                }
002564  784004     MOV.B W4, W0
002566  FA8000     ULNK
002568  060000     RETURN
74:                
75:                //Process the accumulator value once it is ready
76:                //And update stored potentiometer values
77:                
78:                void ADC_ProcAccum(void)
79:                {
00256A  FA0000     LNK #0x0
80:                
81:                }
00256C  FA8000     ULNK
00256E  060000     RETURN
82:                
83:                //ADC ISR
84:                
85:                void _ISR_NO_AUTO_PSV _ISR _ADC1Interrupt(void)
86:                {
002570  781F80     MOV W0, [W15++]
002572  FA0000     LNK #0x0
87:                	IFS0bits.AD1IF = 0;
002574  A9A085     BCLR 0x85, #5
88:                	//Accumulation complete
89:                
90:                }
002576  FA8000     ULNK
002578  78004F     MOV [--W15], W0
00257A  064000     RETFIE
