Disassembly Listing for blecm_dk
Generated From:
/root/MPLABXProjects/fac_relay_clone/blecm_dk.X/dist/default/production/blecm_dk.X.production.elf
Feb 28, 2019 1:57:32 PM

---  /root/MPLABXProjects/fac_relay_clone/uart.c  -------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        uart.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Uart functions
33:                 * 
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdbool.h>
39:                #include <stddef.h>
40:                #include "uart.h"
41:                #include "config.h"
42:                
43:                //UART receive buffer type
44:                
45:                typedef struct {
46:                	volatile uint8_t buffer[SIZE_RxBuffer];
47:                	volatile uint8_t volatile *head;
48:                	volatile uint8_t *tail;
49:                	volatile uint16_t byteCount;
50:                } UART_RX_BUFFER_T;
51:                
52:                //UART transmit buffer type
53:                
54:                typedef struct {
55:                	volatile uint8_t buffer[SIZE_TxBuffer];
56:                	volatile uint8_t *head;
57:                	volatile uint8_t volatile *tail;
58:                	volatile uint16_t byteCount;
59:                } UART_TX_BUFFER_T;
60:                
61:                //Buffer instances
62:                static UART_RX_BUFFER_T rxBuf;
63:                static UART_TX_BUFFER_T txBuf;
64:                
65:                //**********************************************************************************************************************
66:                // Initialize the UART to communicate with the Bluetooth module
67:                
68:                void UART_Init(void)
69:                {
70:                	rxBuf.tail = &rxBuf.buffer[0]; //Initialize the pointers
00233E  208000     MOV #0x800, W0
002340  884810     MOV W0, .L63
71:                	rxBuf.head = &rxBuf.buffer[0];
002342  884800     MOV W0, 0x900
72:                	txBuf.tail = &txBuf.buffer[0];
002344  209060     MOV #0x906, W0
002346  885040     MOV W0, 0xA08
73:                	txBuf.head = &txBuf.buffer[0];
002348  885030     MOV W0, 0xA06
74:                	txBuf.byteCount = rxBuf.byteCount = 0;
00234A  EF2904     CLR 0x904
00234C  F80904     PUSH 0x904
00234E  F90A0A     POP 0xA0A
75:                
76:                	U1BRG = 34; //Baud rate 115,200 - actually 115,384 baud 0.16% error
002350  200220     MOV #0x22, W0
002352  881140     MOV W0, U1BRG
77:                	//	U1BRG = 7;
78:                	U1MODE = 0x8008; //Enable UART, no flow control, BRGH = 1 for high speed baud mode
002354  280080     MOV #0x8008, W0
002356  881100     MOV W0, U1MODE
79:                	U1MODEbits.UEN0=0; // set uart enable bits
002358  A90221     BCLR 0x221, #0
80:                	U1MODEbits.UEN1=1; // enable RTS/CTS
00235A  A82221     BSET 0x221, #1
81:                	U1MODEbits.RTSMD = 0; // pin is in flow control mode
00235C  A96221     BCLR 0x221, #3
82:                	U1STA = 0x0400; //Enable transmit
00235E  204000     MOV #0x400, W0
002360  881110     MOV W0, U1STA
83:                	UART_RX_IF = 0; //Clear UART interrupt flags
002362  A96085     BCLR 0x85, #3
84:                	UART_ER_IF = 0;
002364  A9208C     BCLR IFS4, #1
85:                	UART_RX_IE = 1; //Enable UART Receive and Error interrupt
002366  A86095     BSET 0x95, #3
86:                	UART_ER_IE = 1;
002368  A8209C     BSET IEC4, #1
87:                }
00236A  060000     RETURN
88:                
89:                //**********************************************************************************************************************
90:                // Start transmission by enabling the UART transmit interrupt
91:                
92:                inline void UART_TxStart(void)
93:                {
94:                	UART_TX_IE = 1; //Enable transmit interrupts
00236C  A88095     BSET 0x95, #4
95:                }
00236E  060000     RETURN
96:                
97:                //**********************************************************************************************************************
98:                // See if there are one or more bytes in the receive buffer
99:                
100:               bool UART_IsNewRxData(void)
101:               {
102:               	__builtin_disi(0x3FFF); //disable interrupts
002370  FC3FFF     DISI #0x3FFF
103:               	if (rxBuf.byteCount == 0) { //Check if data in buffer
002372  E20904     CP0 0x904
002374  3A0003     BRA NZ, .L4
104:               		__builtin_disi(0); //enable interrupts
002376  FC0000     DISI #0x0
105:               		return(false); //No bytes in the buffer so return false
002378  EB4000     CLR.B W0
00237A  370002     BRA .L5
106:               	}
107:               	__builtin_disi(0); //enable interrupts
00237C  FC0000     DISI #0x0
108:               	return(true); //There are bytes in the buffer
00237E  B3C010     MOV.B #0x1, W0
109:               }
002380  060000     RETURN
110:               
111:               //**********************************************************************************************************************
112:               // Read a byte from the receive buffer
113:               
114:               uint8_t UART_ReadRxBuffer(void)
115:               {
116:               	uint8_t Temp;
117:               
118:               	__builtin_disi(0x3FFF); //disable interrupts
002382  FC3FFF     DISI #0x3FFF
119:               	if (rxBuf.byteCount == 0) { //For safety, do not allow read of empty buffer
002384  E20904     CP0 0x904
002386  3A0003     BRA NZ, .L7
120:               		__builtin_disi(0); //enable interrupts
002388  FC0000     DISI #0x0
121:               		return(0); //Return zero if there is nothing in the buffer
00238A  EB4000     CLR.B W0
00238C  37000A     BRA .L8
122:               	}
123:               
124:               	rxBuf.byteCount--; //Decrement byte count
00238E  ED2904     DEC 0x904
125:               	__builtin_disi(0); //enable interrupts
002390  FC0000     DISI #0x0
126:               	Temp = *rxBuf.tail++; //Get the byte and increment the pointer
002392  804811     MOV .L63, W1
002394  784031     MOV.B [W1++], W0
002396  884811     MOV W1, .L63
127:               	if (rxBuf.tail > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if at end of buffer
002398  208FF2     MOV #0x8FF, W2
00239A  508F82     SUB W1, W2, [W15]
00239C  360002     BRA LEU, .L8
128:               		rxBuf.tail = &rxBuf.buffer[0]; //then wrap the pointer to beginning
00239E  208001     MOV #0x800, W1
0023A0  884811     MOV W1, .L63
129:               	}
130:               	return(Temp);
131:               }
0023A2  060000     RETURN
132:               
133:               //**********************************************************************************************************************
134:               // Write a byte to the transmit buffer
135:               
136:               void UART_WriteTxBuffer(const uint8_t TxByte)
137:               {
138:               	*txBuf.head++ = TxByte; //Put the byte in the transmit buffer and increment the pointer
0023A4  805031     MOV 0xA06, W1
0023A6  785880     MOV.B W0, [W1++]
0023A8  885031     MOV W1, 0xA06
139:               	if (txBuf.head > &txBuf.buffer[SIZE_TxBuffer - 1]) { //Check if at end of buffer
0023AA  20A050     MOV #0xA05, W0
0023AC  508F80     SUB W1, W0, [W15]
0023AE  360002     BRA LEU, .L10
140:               		txBuf.head = &txBuf.buffer[0]; //Wrap pointer to beginning
0023B0  209060     MOV #0x906, W0
0023B2  885030     MOV W0, 0xA06
141:               	}
142:               	__builtin_disi(0x3FFF); //disable interrupts
0023B4  FC3FFF     DISI #0x3FFF
143:               	if (txBuf.byteCount < SIZE_TxBuffer) { //Increment byte count
0023B6  200FF0     MOV #0xFF, W0
0023B8  E30A0A     CP 0xA0A
0023BA  3E0001     BRA GTU, .L11
144:               		txBuf.byteCount++;
0023BC  EC2A0A     INC 0xA0A
145:               	}
146:               	__builtin_disi(0); //enable interrupts
0023BE  FC0000     DISI #0x0
147:               }
0023C0  060000     RETURN
148:               
149:               //**********************************************************************************************************************
150:               // Return the number of bytes free in the TX buffer
151:               
152:               uint16_t UART_GetTXBufferFreeSpace(void)
153:               {
154:               	uint16_t space;
155:               
156:               	__builtin_disi(0x3FFF); //disable interrupts            
0023C2  FC3FFF     DISI #0x3FFF
157:               	space = SIZE_TxBuffer - txBuf.byteCount;
0023C4  805050     MOV 0xA0A, W0
0023C8  201001     MOV #0x100, W1
0023CA  508000     SUB W1, W0, W0
158:               	__builtin_disi(0); //enable interrupts
0023C6  FC0000     DISI #0x0
159:               	return space;
160:               }
0023CC  060000     RETURN
161:               
162:               //Peek at buffer tail
163:               
164:               uint8_t UART_PeekRxBuffer(void)
165:               {
166:               	__builtin_disi(0x3FFF); //disable interrupts
0023CE  FC3FFF     DISI #0x3FFF
167:               	if (rxBuf.byteCount == 0) { //Check if pointers are the same
0023D0  E20904     CP0 0x904
0023D2  3A0003     BRA NZ, .L14
168:               		__builtin_disi(0); //enable interrupts
0023D4  FC0000     DISI #0x0
169:               		return(NULL); //No bytes in the buffer so return NULL
0023D6  EB4000     CLR.B W0
0023D8  370003     BRA .L15
170:               	} else {
171:               		__builtin_disi(0); //enable interrupts
0023DA  FC0000     DISI #0x0
172:               		return *rxBuf.tail;
0023DC  804810     MOV .L63, W0
0023DE  784010     MOV.B [W0], W0
173:               	}
174:               }
0023E0  060000     RETURN
175:               
176:               //**********************************************************************************************************************
177:               // Interrupt routine for UART receive interrupts
178:               
179:               void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt(void)
180:               {
0002F8  BE9F80     MOV.D W0, [W15++]
181:               	UART_RX_IF = 0; //Clear UART Receive interrupt flag
0002FA  A96085     BCLR 0x85, #3
182:               	*rxBuf.head++ = UART_RX_BUF; //Put received byte in the buffer
0002FC  801131     MOV U1RXREG, W1
0002FE  804800     MOV 0x900, W0
000300  785801     MOV.B W1, [W0++]
000302  884800     MOV W0, 0x900
183:               	if (rxBuf.head > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if end of buffer
000304  208FF1     MOV #0x8FF, W1
000306  500F81     SUB W0, W1, [W15]
000308  360002     BRA LEU, .L17
184:               		rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
00030A  208000     MOV #0x800, W0
00030C  884800     MOV W0, 0x900
185:               	}
186:               	if (rxBuf.byteCount < SIZE_RxBuffer) { //Increment byte count
00030E  200FF0     MOV #0xFF, W0
000310  E30904     CP 0x904
000312  3E0001     BRA GTU, .L16
187:               		rxBuf.byteCount++;
000314  EC2904     INC 0x904
188:               	}
189:               }
000316  BE004F     MOV.D [--W15], W0
000318  064000     RETFIE
190:               
191:               //**********************************************************************************************************************
192:               // Interrupt routine for UART transmit interrupts
193:               
194:               void __attribute__((interrupt, no_auto_psv)) _U1TXInterrupt(void)
195:               {
00031A  BE9F80     MOV.D W0, [W15++]
196:               	if (txBuf.byteCount > 0) //Check if more data is in the buffer
00031C  E20A0A     CP0 0xA0A
00031E  32000E     BRA Z, .L20
197:               	{
198:               		//Only do anything if hardware buffer has space
199:               		if (!UART_FULL) {
000320  AB2223     BTST 0x223, #1
000322  3A000D     BRA NZ, .L19
200:               			UART_TX_IF = 0; //Clear UART 1 TX interrupt flag
000324  A98085     BCLR 0x85, #4
201:               			UART_TX_BUF = *txBuf.tail++; //Load next byte into the TX buffer
000326  805040     MOV 0xA08, W0
000328  FB80B0     ZE [W0++], W1
00032A  881121     MOV W1, U1TXREG
00032C  885040     MOV W0, 0xA08
202:               			if (txBuf.tail > &txBuf.buffer[SIZE_TxBuffer - 1]) { //Check if end of buffer
00032E  20A051     MOV #0xA05, W1
000330  500F81     SUB W0, W1, [W15]
000332  360002     BRA LEU, .L22
203:               				txBuf.tail = &txBuf.buffer[0]; //Wrap pointer to beginning
000334  209060     MOV #0x906, W0
000336  885040     MOV W0, 0xA08
204:               			}
205:               			txBuf.byteCount--; //Decrement byte count
000338  ED2A0A     DEC 0xA0A
00033A  370001     BRA .L19
206:               		}
207:               	} else {
208:               		UART_TX_IE = 0; //No more data to transmit, so stop interrupts
00033C  A98095     BCLR 0x95, #4
209:               	}
210:               }
00033E  BE004F     MOV.D [--W15], W0
000340  064000     RETFIE
211:               
212:               //**********************************************************************************************************************
213:               // Interrupt routine for UART error interrupts
214:               
215:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void)
216:               {
000342  BE9F80     MOV.D W0, [W15++]
217:               	IFS4bits.U1ERIF = 0; //Clear interrupt flag
000344  A9208C     BCLR IFS4, #1
218:               
219:               	//Handle an overflow error by reading next byte and clearing flag
220:               	if (U1STAbits.OERR == 1) {
000346  AB2222     BTST U1STA, #1
000348  32000E     BRA Z, .L24
221:               		*rxBuf.head++ = UART_RX_BUF; //Put received byte in the buffer
00034A  801131     MOV U1RXREG, W1
00034C  804800     MOV 0x900, W0
00034E  785801     MOV.B W1, [W0++]
000350  884800     MOV W0, 0x900
222:               		if (rxBuf.head > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if end of buffer
000352  208FF1     MOV #0x8FF, W1
000354  500F81     SUB W0, W1, [W15]
000356  360002     BRA LEU, .L25
223:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
000358  208000     MOV #0x800, W0
00035A  884800     MOV W0, 0x900
224:               		}
225:               		if (rxBuf.byteCount < SIZE_RxBuffer) { //Increment byte count
00035C  200FF0     MOV #0xFF, W0
00035E  E30904     CP 0x904
000360  3E0001     BRA GTU, .L26
226:               			rxBuf.byteCount++;
000362  EC2904     INC 0x904
227:               		}
228:               		U1STAbits.OERR = 0;
000364  A92222     BCLR U1STA, #1
229:               	}
230:               
231:               	//Clear any other error bits
232:               	U1STAbits.FERR = 0;
000366  A94222     BCLR U1STA, #2
233:               	U1STAbits.PERR = 0;
000368  A96222     BCLR U1STA, #3
234:               }
00036A  BE004F     MOV.D [--W15], W0
00036C  064000     RETFIE
---  /root/MPLABXProjects/fac_relay_clone/timers.c  -----------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        timers.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Timer functions
33:                 *
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdbool.h>
39:                #include "config.h"
40:                #include "timers.h"
41:                #include "app.h"
42:                
43:                extern APP_DATA appData;
44:                
45:                static volatile uint16_t tickCount[TMR_COUNT] = {0};
46:                
47:                //**********************************************************************************************************************
48:                // Initialize the timers
49:                
50:                void Timers_Init(void)
51:                {
52:                	//Timer 1 is used for interrupt based software timers counting 1ms intervals to a resolution of 500us
53:                	T1CON = TIMER_OFF; //Timer 1 off
00247A  EF2104     CLR T1CON
54:                	TMR1 = 0; //Clear timer 1
00247C  EF2100     CLR TMR1
55:                	PR1 = TIMER_500US_PERIOD; //Set the period value for 500us
00247E  21F3F0     MOV #0x1F3F, W0
002480  880810     MOV W0, PR1
56:                	T1CON |= TIMER_ON_PRESCALE1; //using 1:1 prescaler and turn on timer 1
002482  A8E105     BSET 0x105, #7
57:                	IFS0bits.T1IF = 0; //Clear the interrupt flag
002484  A96084     BCLR IFS0, #3
58:                	IEC0bits.T1IE = 1; //Enable the timer 1 interrupt
002486  A86094     BSET IEC0, #3
59:                
60:                #ifdef USE_SLEEP                //see config.h, Application setting section
61:                	//Timer 2/3 is used in 32-bit mode as inactivity timer to trigger sleep mode
62:                	T2CON = TIMER_OFF; //Timer 3 off
63:                	TMR3 = 0; //Clear timer 3
64:                	TMR2 = 0; //Clear timer 2
65:                	T2CONbits.T32 = 1; //Enable 32-bit mode
66:                	PR3 = (uint16_t) (SLEEP_TIME >> 16); //Set the period value - msw
67:                	PR2 = (uint16_t) (SLEEP_TIME | 0x0000FFFF); //lsw
68:                	T2CON |= TIMER_ON_PRESCALE256; //using 1:256 prescaler and turn on timer 3
69:                	IFS0bits.T3IF = 0; //Clear the interrupt flag
70:                	IEC0bits.T3IE = 1; //Enable the timer 3 interrupt
71:                
72:                #ifndef SLEEP_MODE_RTCC         //we'll be using Timer 1 for periodic wakeup
73:                	T1CON = 0x0000; //Timer 1 off
74:                	T1CONbits.T1ECS = 0b10; //Clock source LPRC
75:                	T1CONbits.TCS = 1;
76:                	T1CONbits.TCKPS = 0b11; //using 1:256 prescaler
77:                	TMR1 = 0; //Clear timer 1
78:                	PR1 = T1_SLEEP_PERIOD; //Set the period for sleep
79:                	IFS0bits.T1IF = 0; //Clear the interrupt flag
80:                	IEC0bits.T1IE = 1; //Enable the timer 1 interrupt
81:                #endif //not SLEEP_MODE_RTCC    
82:                #endif //USE_SLEEP
83:                }
002488  060000     RETURN
84:                
85:                //**********************************************************************************************************************
86:                // Start one of the software timers
87:                
88:                inline void StartTimer(uint8_t timer, uint16_t count)
89:                {
90:                	tickCount[timer] = count << 1; //Interrupt is every 500us but StartTimer() takes multiple of 1ms so multiply by 2
00248A  FB8000     ZE W0, W0
00248C  400000     ADD W0, W0, W0
00248E  20C6A2     MOV #0xC6A, W2
002490  410000     ADD W2, W0, W0
002492  408801     ADD W1, W1, [W0]
0024A8  400000     ADD W0, W0, W0
0024AA  886350     MOV W0, tickCount
91:                }
002494  060000     RETURN
92:                
93:                //**********************************************************************************************************************
94:                // Check if one of the software software timers has timed out
95:                
96:                inline bool TimerDone(uint8_t timer)
00249E  A7F000     BTSC W0, #15
0024A0  EA0000     NEG W0, W0
0024A2  E90000     DEC W0, W0
0024A4  DE004F     LSR W0, #15, W0
97:                {
98:                	if (tickCount[timer] == 0) { //Check if counted down to zero
002496  FB8000     ZE W0, W0
002498  400000     ADD W0, W0, W0
00249A  20C6A1     MOV #0xC6A, W1
00249C  780061     MOV [W1+W0], W0
99:                		return true; //then return true
100:               	}
101:               	return false; //else return false
102:               }
0024A6  060000     RETURN
103:               
104:               //**********************************************************************************************************************
105:               // Simple delay for n milliseconds (blocking)
106:               
107:               void WaitMs(uint16_t numMilliseconds)
108:               {
109:               	StartTimer(TMR_INTERNAL, numMilliseconds); //Start software timer and wait for it to count down
110:               	while (!TimerDone(TMR_INTERNAL)) {
0024AC  E20C6A     CP0 tickCount
0024AE  320003     BRA Z, .L4
0024B2  E20C6A     CP0 tickCount
0024B4  3AFFFD     BRA NZ, .L7
111:               		Idle();
0024B0  FE4001     PWRSAV #1
112:               	} //Enter idle mode to reduce power while waiting
113:               } //(timer interrupt will wake part from idle)
0024B6  060000     RETURN
114:               
115:               #ifdef USE_SLEEP                //see config.h, Application setting section
116:               //Reset the inactivity sleep timer
117:               
118:               inline void SleepTimerReset(void)
119:               {
120:               	TMR3 = 0; //Clear timer 3
121:               	TMR2 = 0; //Clear timer 2
122:               }
123:               #endif
124:               
125:               //**********************************************************************************************************************
126:               // Timer 1 interrupt routine - software timers
127:               
128:               void _ISR_NO_AUTO_PSV _T1Interrupt(void)
129:               {
0002D0  BE9F80     MOV.D W0, [W15++]
0002D2  BE9F82     MOV.D W2, [W15++]
130:               	uint8_t i;
131:               
132:               	IFS0bits.T1IF = 0; //Clear the interrupt flag
0002D4  A96084     BCLR IFS0, #3
0002D6  EB0000     CLR W0
133:               	//Decrement each software timer
134:               	for (i = 0; i < TMR_COUNT; i++) {
0002EE  500FF1     SUB W0, #0x11, [W15]
0002F0  3AFFF3     BRA NZ, .L11
135:               		if (tickCount[i] != 0) {
0002D8  400100     ADD W0, W0, W2
0002DA  20C6A3     MOV #0xC6A, W3
0002DC  790163     MOV [W3+W2], W2
0002DE  E00002     CP0 W2
0002E0  320005     BRA Z, .L10
136:               			tickCount[i]--;
0002E2  400080     ADD W0, W0, W1
0002E4  780103     MOV W3, W2
0002E6  7881E2     MOV [W2+W1], W3
0002E8  410081     ADD W2, W1, W1
0002EA  E90883     DEC W3, [W1]
0002EC  E80000     INC W0, W0
137:               		}
138:               	}
139:               }
0002F2  BE014F     MOV.D [--W15], W2
0002F4  BE004F     MOV.D [--W15], W0
0002F6  064000     RETFIE
140:               
141:               #ifdef USE_SLEEP                //see config.h, Application setting section
142:               //**********************************************************************************************************************
143:               // Timer 3 interrupt routine - inactivity timer
144:               
145:               void _ISR_NO_AUTO_PSV _T3Interrupt(void)
146:               {
147:               	IFS0bits.T3IF = 0; //Clear the interrupt flag    
148:               	appData.sleepFlag = true;
149:               }
150:               #ifndef SLEEP_MODE_RTCC
151:               //**********************************************************************************************************************
152:               // Timer 1 interrupt routine - periodic wakeup timer
153:               
154:               void _ISR_NO_AUTO_PSV _T1Interrupt(void)
155:               {
156:               	IFS0bits.T1IF = 0; //Clear the interrupt flag
157:               	appData.timer1Flag = true;
158:               }
159:               #endif //not SLEEP_MODE_RTCC
160:               #endif //USE_SLEEP
---  /root/MPLABXProjects/fac_relay_clone/switches.c  ---------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2015 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        switches.c
29:                 * Date:        September 17, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 *
33:                 */
34:                
35:                #include <xc.h>
36:                #include "app.h"
37:                #include "config.h"
38:                #include "timers.h"
39:                
40:                extern APP_DATA appData;
41:                
42:                //Switches state machine
43:                
44:                void Switch_Tasks(void)
45:                {
46:                	//Check if switches have changed and debounce timers are expired
47:                	if (appData.sw1Changed && TimerDone(TMR_SW1_DEBOUNCE)) {
002430  E24BA3     CP0.B 0xBA3
002432  320007     BRA Z, .L2
002434  B3C050     MOV.B #0x5, W0
002436  07002F     RCALL .LFE1, .LFB2, _TimerDone
002438  E00400     CP0.B W0
00243A  320003     BRA Z, .L2
48:                
49:                		appData.sw1Changed = false; //clear individual flag
00243C  EF6BA3     CLR.B 0xBA3
50:                		appData.sendSwitches = true; //set group flag to request TX
00243E  B3C010     MOV.B #0x1, W0
002440  B7EB90     MOV.B WREG, .L65
51:                	}
52:                	if (appData.sw2Changed && TimerDone(TMR_SW2_DEBOUNCE)) {
002442  E24BA4     CP0.B 0xBA4
002444  320007     BRA Z, .L3
002446  B3C060     MOV.B #0x6, W0
002448  070026     RCALL .LFE1, .LFB2, _TimerDone
00244A  E00400     CP0.B W0
00244C  320003     BRA Z, .L3
53:                
54:                		appData.sw2Changed = false;
00244E  EF6BA4     CLR.B 0xBA4
55:                		appData.sendSwitches = true;
002450  B3C010     MOV.B #0x1, W0
002452  B7EB90     MOV.B WREG, .L65
56:                	}
57:                	if (appData.sw3Changed && TimerDone(TMR_SW3_DEBOUNCE)) {
002454  E24BA5     CP0.B 0xBA5
002456  320007     BRA Z, .L4
002458  B3C070     MOV.B #0x7, W0
00245A  07001D     RCALL .LFE1, .LFB2, _TimerDone
00245C  E00400     CP0.B W0
00245E  320003     BRA Z, .L4
58:                
59:                		appData.sw3Changed = false;
002460  EF6BA5     CLR.B 0xBA5
60:                		appData.sendSwitches = true;
002462  B3C010     MOV.B #0x1, W0
002464  B7EB90     MOV.B WREG, .L65
61:                	}
62:                	if (appData.sw4Changed && TimerDone(TMR_SW4_DEBOUNCE)) {
002466  E24BA6     CP0.B .L41
002468  320007     BRA Z, .L1
00246A  B3C080     MOV.B #0x8, W0
00246C  070014     RCALL .LFE1, .LFB2, _TimerDone
00246E  E00400     CP0.B W0
002470  320003     BRA Z, .L1
63:                
64:                		appData.sw4Changed = false;
002472  EF6BA6     CLR.B .L41
65:                		appData.sendSwitches = true;
002474  B3C010     MOV.B #0x1, W0
002476  B7EB90     MOV.B WREG, .L65
66:                	}
67:                }
002478  060000     RETURN
68:                
69:                //Change notification interrupt
70:                //Process and start debounce timers for switch changes
71:                //The switches are well debounced in hardware
72:                //Adding the software debounce limits unneeded switch update messages
73:                //and groups together multiple switch presses that occur within the debounce period
74:                
75:                void _ISR_NO_AUTO_PSV _CNInterrupt(void)
76:                {
77:                	IFS1bits.CNIF = 0; //Clear IF
0002CC  A96086     BCLR IFS1, #3
78:                
79:                #ifdef USE_SLEEP                //see config.h, Application setting section
80:                	appData.CNint = true;
81:                	SleepTimerReset(); //Reset the inactivity sleep timer
82:                #endif
83:                
84:                }
0002CE  064000     RETFIE
---  /root/MPLABXProjects/fac_relay_clone/spi.c  --------------------------------------------------------
1:                 /* SPI Master Driver */
2:                 
3:                 #include <xc.h>
4:                 #include <stdint.h>
5:                 #include <stdbool.h>
6:                 #include <stddef.h>
7:                 #include "spi.h"
8:                 #include "config.h"
9:                 
10:                //SPI receive buffer type
11:                
12:                typedef struct {
13:                	volatile uint8_t buffer[SIZE_SPI_Buffer];
14:                	volatile uint8_t volatile *head;
15:                	volatile uint8_t *tail;
16:                	volatile uint16_t byteCount;
17:                } SPI_RX_BUFFER_T;
18:                
19:                //SPI transmit buffer type
20:                
21:                typedef struct {
22:                	volatile uint8_t buffer[SIZE_SPI_Buffer];
23:                	volatile uint8_t *head;
24:                	volatile uint8_t volatile *tail;
25:                	volatile uint16_t byteCount;
26:                } SPI_TX_BUFFER_T;
27:                
28:                //Buffer instances
29:                static SPI_RX_BUFFER_T rxBuf;
30:                static SPI_TX_BUFFER_T txBuf;
31:                
32:                void SPI_Init(void)
33:                {
34:                	SPI_SDO = 0;
00209E  A9C2C8     BCLR TRISB, #6
35:                	SPI_SCK = 0;
0020A0  A9A2C8     BCLR TRISB, #5
36:                	SPI_SDI = 1;
0020A2  A8E2C0     BSET TRISA, #7
37:                	SPI_CS0 = 1;
0020A4  A862C4     BSET LATA, #3
38:                	SPI_CS1 = 1;
0020A6  A8E2CD     BSET 0x2CD, #7
39:                	rxBuf.tail = &rxBuf.buffer[0]; //Initialize the pointers
0020A8  20BDE0     MOV #0xBDE, W0
0020AA  886100     MOV W0, .L80
40:                	rxBuf.head = &rxBuf.buffer[0];
0020AC  8860F0     MOV W0, 0xC1E
41:                	txBuf.tail = &txBuf.buffer[0];
0020AE  20C240     MOV #0xC24, W0
0020B0  886330     MOV W0, 0xC66
42:                	txBuf.head = &txBuf.buffer[0];
0020B2  886320     MOV W0, .L84
43:                	txBuf.byteCount = 0;
0020B4  EF2C68     CLR 0xC68
44:                	rxBuf.byteCount = 0;
0020B6  EF2C22     CLR 0xC22
45:                	SPI_X_IF = 0; //Clear SPI interrupt flags
0020B8  A9208A     BCLR IFS3, #1
46:                	SPI_E_IF = 0;
0020BA  A9408A     BCLR IFS3, #2
47:                	SPI_X_IE = 0; //Setup SPI Receive and Error interrupt
0020BC  A9209A     BCLR IEC3, #1
48:                	SPI_E_IE = 1;
0020BE  A8409A     BSET IEC3, #2
49:                }
0020C0  060000     RETURN
50:                
51:                void SPI_Speed(const uint8_t speed)
52:                {
53:                	switch (speed) {
0020C2  504FE1     SUB.B W0, #0x1, [W15]
0020C4  3A0005     BRA NZ, .L6
54:                	case 1:
55:                		SSP2CON1bits.SSPM = 1; // SPI MASTER SCK speed 16MHz
0020C6  2FFF00     MOV #0xFFF0, W0
0020C8  B60212     AND SSP2CON1, WREG
0020CA  A00000     BSET W0, #0
0020CC  881090     MOV W0, SSP2CON1
56:                		break;
0020CE  370004     BRA .L2
57:                	default:
58:                		SSP2CON1bits.SSPM = 2; // SPI MASTER SCK speed 1MHz
0020D0  2FFF00     MOV #0xFFF0, W0
0020D2  B60212     AND SSP2CON1, WREG
0020D4  A01000     BSET W0, #1
0020D6  881090     MOV W0, SSP2CON1
59:                		break;
60:                	}
61:                }
0020D8  060000     RETURN
62:                
63:                void SPI_ClearBufs(void)
64:                {
65:                	__builtin_disi(0x3FFF); //disable interrupts
0020DA  FC3FFF     DISI #0x3FFF
66:                	rxBuf.tail = &rxBuf.buffer[0]; //Initialize the pointers
0020DC  20BDE0     MOV #0xBDE, W0
0020DE  886100     MOV W0, .L80
67:                	rxBuf.head = &rxBuf.buffer[0];
0020E0  8860F0     MOV W0, 0xC1E
68:                	txBuf.tail = &txBuf.buffer[0];
0020E2  20C240     MOV #0xC24, W0
0020E4  886330     MOV W0, 0xC66
69:                	txBuf.head = &txBuf.buffer[0];
0020E6  886320     MOV W0, .L84
70:                	txBuf.byteCount = 0;
0020E8  EF2C68     CLR 0xC68
71:                	rxBuf.byteCount = 0;
0020EA  EF2C22     CLR 0xC22
72:                	__builtin_disi(0); //enable interrupts
0020EC  FC0000     DISI #0x0
73:                }
0020EE  060000     RETURN
74:                
75:                void SPI_TxStart(void)
76:                {
77:                	__builtin_disi(0x3FFF); //disable interrupts
0020F0  FC3FFF     DISI #0x3FFF
78:                	if (txBuf.byteCount) { // prime the transmit interrupt
0020F2  E20C68     CP0 0xC68
0020F4  32000E     BRA Z, .L9
79:                		/* write data here */
80:                		SPI_X_IF = 0; //Clear interrupt flag
0020F6  A9208A     BCLR IFS3, #1
81:                		SPI_BUF = *txBuf.tail++; //Load next byte into the TX buffer
0020F8  806330     MOV 0xC66, W0
0020FA  FB80B0     ZE [W0++], W1
0020FC  881081     MOV W1, SSP2BUF
0020FE  886330     MOV W0, 0xC66
82:                		if (txBuf.tail > &txBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
002100  20C631     MOV #0xC63, W1
002102  500F81     SUB W0, W1, [W15]
002104  360002     BRA LEU, .L10
83:                			txBuf.tail = &txBuf.buffer[0]; //Wrap pointer to beginning
002106  20C240     MOV #0xC24, W0
002108  886330     MOV W0, 0xC66
84:                		}
85:                		txBuf.byteCount--; //Decrement byte count
00210A  ED2C68     DEC 0xC68
86:                		SPI_X_IE = 1; //Enable transmit interrupts
00210C  A8209A     BSET IEC3, #1
87:                		__builtin_disi(0); //enable interrupts
00210E  FC0000     DISI #0x0
88:                		return;
002110  370001     BRA .L8
89:                	}
90:                	__builtin_disi(0); //enable interrupts
002112  FC0000     DISI #0x0
91:                	return;
92:                }
002114  060000     RETURN
93:                
94:                bool SPI_IsNewRxData(void)
95:                {
96:                	__builtin_disi(0x3FFF); //disable interrupts
002116  FC3FFF     DISI #0x3FFF
97:                	if (rxBuf.byteCount == 0) { //Check if data in buffer
002118  E20C22     CP0 0xC22
00211A  3A0003     BRA NZ, .L13
98:                		__builtin_disi(0); //enable interrupts
00211C  FC0000     DISI #0x0
99:                		return(false); //No bytes in the buffer so return false
00211E  EB4000     CLR.B W0
002120  370002     BRA .L14
100:               	}
101:               	__builtin_disi(0); //enable interrupts
002122  FC0000     DISI #0x0
102:               	return(true); //There are bytes in the buffer
002124  B3C010     MOV.B #0x1, W0
103:               }
002126  060000     RETURN
104:               
105:               uint8_t SPI_ReadRxBuffer(void)
106:               {
107:               	uint8_t Temp;
108:               
109:               	__builtin_disi(0x3FFF); //disable interrupts
002128  FC3FFF     DISI #0x3FFF
110:               	if (rxBuf.byteCount == 0) { //For safety, do not allow read of empty buffer
00212A  E20C22     CP0 0xC22
00212C  3A0003     BRA NZ, .L16
111:               		__builtin_disi(0); //enable interrupts
00212E  FC0000     DISI #0x0
112:               		return(0); //Return zero if there is nothing in the buffer
002130  EB4000     CLR.B W0
002132  37000A     BRA .L17
113:               	}
114:               
115:               	rxBuf.byteCount--; //Decrement byte count
002134  ED2C22     DEC 0xC22
116:               	__builtin_disi(0); //enable interrupts
002136  FC0000     DISI #0x0
117:               	Temp = *rxBuf.tail++; //Get the byte and increment the pointer
002138  806101     MOV .L80, W1
00213A  784031     MOV.B [W1++], W0
00213C  886101     MOV W1, .L80
118:               	if (rxBuf.tail > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if at end of buffer
00213E  20C1D2     MOV #0xC1D, W2
002140  508F82     SUB W1, W2, [W15]
002142  360002     BRA LEU, .L17
119:               		rxBuf.tail = &rxBuf.buffer[0]; //then wrap the pointer to beginning
002144  20BDE1     MOV #0xBDE, W1
002146  886101     MOV W1, .L80
120:               	}
121:               	return(Temp);
122:               }
002148  060000     RETURN
123:               
124:               bool SPI_IsTxData(void)
125:               {
126:               	__builtin_disi(0x3FFF); //disable interrupts
00214A  FC3FFF     DISI #0x3FFF
127:               	if (txBuf.byteCount == 0) { //Check if data in buffer
00214C  E20C68     CP0 0xC68
00214E  3A0003     BRA NZ, .L19
128:               		__builtin_disi(0); //enable interrupts
002150  FC0000     DISI #0x0
129:               		return(false); //No bytes in the buffer so return false
002152  EB4000     CLR.B W0
002154  370002     BRA .L20
130:               	}
131:               	__builtin_disi(0); //enable interrupts
002156  FC0000     DISI #0x0
132:               	return(true); //There are bytes in the buffer
002158  B3C010     MOV.B #0x1, W0
133:               }
00215A  060000     RETURN
134:               
135:               void SPI_WriteTxBuffer(const uint8_t TxByte)
136:               {
137:               	*txBuf.head++ = TxByte; //Put the byte in the transmit buffer and increment the pointer
00215C  806321     MOV .L84, W1
00215E  785880     MOV.B W0, [W1++]
002160  886321     MOV W1, .L84
138:               	if (txBuf.head > &txBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if at end of buffer
002162  20C630     MOV #0xC63, W0
002164  508F80     SUB W1, W0, [W15]
002166  360002     BRA LEU, .L22
139:               		txBuf.head = &txBuf.buffer[0]; //Wrap pointer to beginning
002168  20C240     MOV #0xC24, W0
00216A  886320     MOV W0, .L84
140:               	}
141:               	__builtin_disi(0x3FFF); //disable interrupts
00216C  FC3FFF     DISI #0x3FFF
142:               	if (txBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
00216E  2003F0     MOV #0x3F, W0
002170  E30C68     CP 0xC68
002172  3E0001     BRA GTU, .L23
143:               		txBuf.byteCount++;
002174  EC2C68     INC 0xC68
144:               	}
145:               	__builtin_disi(0); //enable interrupts
002176  FC0000     DISI #0x0
146:               }
002178  060000     RETURN
147:               
148:               //**********************************************************************************************************************
149:               // Return the number of bytes free in the TX buffer
150:               
151:               uint16_t SPI_GetTXBufferFreeSpace(void)
152:               {
153:               	uint16_t space;
154:               
155:               	__builtin_disi(0x3FFF); //disable interrupts            
00217A  FC3FFF     DISI #0x3FFF
156:               	space = SIZE_SPI_Buffer - txBuf.byteCount;
00217C  806340     MOV 0xC68, W0
002180  200401     MOV #0x40, W1
002182  508000     SUB W1, W0, W0
157:               	__builtin_disi(0); //enable interrupts
00217E  FC0000     DISI #0x0
158:               	return space;
159:               }
002184  060000     RETURN
160:               
161:               //Peek at buffer tail
162:               
163:               uint8_t SPI_PeekRxBuffer(void)
164:               {
165:               	__builtin_disi(0x3FFF); //disable interrupts
002186  FC3FFF     DISI #0x3FFF
166:               	if (rxBuf.byteCount == 0) { //Check if pointers are the same
002188  E20C22     CP0 0xC22
00218A  3A0003     BRA NZ, .L26
167:               		__builtin_disi(0); //enable interrupts
00218C  FC0000     DISI #0x0
168:               		return(NULL); //No bytes in the buffer so return NULL
00218E  EB4000     CLR.B W0
002190  370003     BRA .L27
169:               	} else {
170:               		__builtin_disi(0); //enable interrupts
002192  FC0000     DISI #0x0
171:               		return *rxBuf.tail;
002194  806100     MOV .L80, W0
002196  784010     MOV.B [W0], W0
172:               	}
173:               }
002198  060000     RETURN
174:               
175:               void __attribute__((interrupt, no_auto_psv)) _MSSP2Interrupt(void)
176:               {
00036E  BE9F80     MOV.D W0, [W15++]
177:               	SPI_X_IF = 0; //Clear interrupt flag
000370  A9208A     BCLR IFS3, #1
178:               	if (txBuf.byteCount > 0) { //Check if more data is in the buffer
000372  E20C68     CP0 0xC68
000374  320018     BRA Z, .L29
179:               		/* read data HERE */
180:               		*rxBuf.head++ = SPI_BUF; //Put received byte in the buffer
000376  801081     MOV SSP2BUF, W1
000378  8060F0     MOV 0xC1E, W0
00037A  785801     MOV.B W1, [W0++]
00037C  8860F0     MOV W0, 0xC1E
181:               		if (rxBuf.head > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
00037E  20C1D1     MOV #0xC1D, W1
000380  500F81     SUB W0, W1, [W15]
000382  360002     BRA LEU, .L30
182:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
000384  20BDE0     MOV #0xBDE, W0
000386  8860F0     MOV W0, 0xC1E
183:               		}
184:               		if (rxBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
000388  2003F0     MOV #0x3F, W0
00038A  E30C22     CP 0xC22
00038C  3E0001     BRA GTU, .L31
185:               			rxBuf.byteCount++;
00038E  EC2C22     INC 0xC22
186:               		}
187:               
188:               		/* write data here */
189:               		SPI_BUF = *txBuf.tail++; //Load next byte into the TX buffer
000390  806330     MOV 0xC66, W0
000392  FB80B0     ZE [W0++], W1
000394  881081     MOV W1, SSP2BUF
000396  886330     MOV W0, 0xC66
190:               		if (txBuf.tail > &txBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
000398  20C631     MOV #0xC63, W1
00039A  500F81     SUB W0, W1, [W15]
00039C  360002     BRA LEU, .L32
191:               			txBuf.tail = &txBuf.buffer[0]; //Wrap pointer to beginning
00039E  20C240     MOV #0xC24, W0
0003A0  886330     MOV W0, 0xC66
192:               		}
193:               		txBuf.byteCount--; //Decrement byte count
0003A2  ED2C68     DEC 0xC68
0003A4  370010     BRA .L28
194:               	} else {
195:               		/* read data HERE */
196:               		*rxBuf.head++ = SPI_BUF; //Put received byte in the buffer
0003A6  801081     MOV SSP2BUF, W1
0003A8  8060F0     MOV 0xC1E, W0
0003AA  785801     MOV.B W1, [W0++]
0003AC  8860F0     MOV W0, 0xC1E
197:               		if (rxBuf.head > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
0003AE  20C1D1     MOV #0xC1D, W1
0003B0  500F81     SUB W0, W1, [W15]
0003B2  360002     BRA LEU, .L34
198:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
0003B4  20BDE0     MOV #0xBDE, W0
0003B6  8860F0     MOV W0, 0xC1E
199:               		}
200:               		if (rxBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
0003B8  2003F0     MOV #0x3F, W0
0003BA  E30C22     CP 0xC22
0003BC  3E0001     BRA GTU, .L35
201:               			rxBuf.byteCount++;
0003BE  EC2C22     INC 0xC22
202:               		}
203:               		SPI_X_IE = 0; //No more data to transmit, so stop interrupts
0003C0  A9209A     BCLR IEC3, #1
204:               		SPI_CS0 = 1; // deselect all devices here
0003C2  A862C4     BSET LATA, #3
205:               		SPI_CS1 = 1;
0003C4  A8E2CD     BSET 0x2CD, #7
206:               	}
207:               }
0003C6  BE004F     MOV.D [--W15], W0
0003C8  064000     RETFIE
208:               
209:               void __attribute__((interrupt, no_auto_psv)) _MSSP2BCInterrupt(void)
210:               {
0003CA  BE9F80     MOV.D W0, [W15++]
211:               	SPI_E_IF = 0; //Clear interrupt flag
0003CC  A9408A     BCLR IFS3, #2
212:               
213:               	//Handle an overflow error by reading next byte and clearing flags
214:               	if (SSP2CON1bits.WCOL || SSP2CON1bits.SSPOV) {
0003CE  ABE212     BTST SSP2CON1, #7
0003D0  3A0002     BRA NZ, .L37
0003D2  ABC212     BTST SSP2CON1, #6
0003D4  32000F     BRA Z, .L36
215:               		*rxBuf.head++ = SPI_BUF; //Put received byte in the buffer
0003D6  801081     MOV SSP2BUF, W1
0003D8  8060F0     MOV 0xC1E, W0
0003DA  785801     MOV.B W1, [W0++]
0003DC  8860F0     MOV W0, 0xC1E
216:               		if (rxBuf.head > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
0003DE  20C1D1     MOV #0xC1D, W1
0003E0  500F81     SUB W0, W1, [W15]
0003E2  360002     BRA LEU, .L39
217:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
0003E4  20BDE0     MOV #0xBDE, W0
0003E6  8860F0     MOV W0, 0xC1E
218:               		}
219:               		if (rxBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
0003E8  2003F0     MOV #0x3F, W0
0003EA  E30C22     CP 0xC22
0003EC  3E0001     BRA GTU, .L40
220:               			rxBuf.byteCount++;
0003EE  EC2C22     INC 0xC22
221:               		}
222:               		SSP2CON1bits.WCOL = 0;
0003F0  A9E212     BCLR SSP2CON1, #7
223:               		SSP2CON1bits.SSPOV = 0;
0003F2  A9C212     BCLR SSP2CON1, #6
224:               	}
225:               
226:               	//Clear any other error bits
227:               
228:               }
0003F4  BE004F     MOV.D [--W15], W0
0003F6  064000     RETFIE
---  /root/MPLABXProjects/fac_relay_clone/main.c  -------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        main.c
29:                 * Date:        Oct 27, 2016
30:                 * Compiler:    XC16 v1.26
31:                 * 
32:                 * Remote Relay mods Oct 2018 FGB@MCHP
33:                 * ported to PIC24FV 
34:                 * Version updates
35:                 * V2.1 DFU OTA mode added, input port shared with relay #4 output
36:                 * V3.5 RN4871 support added by source #define in config.h
37:                 */
38:                
39:                #include <xc.h>
40:                #include <stdint.h>
41:                #include "app.h"
42:                #include "config.h"
43:                #include "spi.h"
44:                #include "timers.h"
45:                
46:                void initBoard(void);
47:                
48:                // PIC24FV16KM202 Configuration Bit Settings
49:                
50:                // 'C' source line config statements
51:                
52:                // FBS
53:                #pragma config BWRP = OFF               // Boot Segment Write Protect (Disabled)
54:                #pragma config BSS = OFF                // Boot segment Protect (No boot program flash segment)
55:                
56:                // FGS
57:                #pragma config GWRP = OFF               // General Segment Write Protect (General segment may be written)
58:                #pragma config GCP = OFF                // General Segment Code Protect (No Protection)
59:                
60:                // FOSCSEL
61:                #pragma config FNOSC = FRCPLL           // Oscillator Select (Fast RC Oscillator with Postscaler and PLL Module (FRCDIV+PLL))
62:                #pragma config SOSCSRC = DIG            // SOSC Source Type (Digital Mode for use with external source)
63:                #pragma config LPRCSEL = HP             // LPRC Oscillator Power and Accuracy (High Power, High Accuracy Mode)
64:                #pragma config IESO = OFF               // Internal External Switch Over bit (Internal External Switchover mode disabled (Two-speed Start-up disabled))
65:                
66:                // FOSC
67:                #pragma config POSCMOD = NONE           // Primary Oscillator Configuration bits (Primary oscillator disabled)
68:                #pragma config OSCIOFNC = IO            // CLKO Enable Configuration bit (Port I/O enabled (CLKO disabled))
69:                #pragma config POSCFREQ = LS            // Primary Oscillator Frequency Range Configuration bits (Primary oscillator/external clock input frequency less than 100kHz)
70:                #pragma config SOSCSEL = SOSCLP         // SOSC Power Selection Configuration bits (Secondary Oscillator configured for low-power operation)
71:                #pragma config FCKSM = CSECME           // Clock Switching and Monitor Selection (Both Clock Switching and Fail-safe Clock Monitor are enabled)
72:                
73:                // FWDT
74:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscale Select bits (1:32768)
75:                #pragma config FWPSA = PR128            // WDT Prescaler bit (WDT prescaler ratio of 1:128)
76:                #pragma config FWDTEN = ON              // Watchdog Timer Enable bits (WDT enabled in hardware)
77:                #pragma config WINDIS = OFF             // Windowed Watchdog Timer Disable bit (Standard WDT selected(windowed WDT disabled))
78:                
79:                // FPOR
80:                #pragma config BOREN = BOR3             // Brown-out Reset Enable bits
81:                #pragma config RETCFG = OFF             //  (Retention regulator is not available)
82:                #pragma config PWRTEN = ON              // Power-up Timer Enable bit (PWRT enabled)
83:                #pragma config I2C1SEL = SEC            // Alternate I2C1 Pin Mapping bit (Use  Alternate ASCL1/ASDA1 Pins For I2C1)
84:                #pragma config BORV = V30               // Brown-out Reset Voltage bits
85:                #pragma config MCLRE = ON               // MCLR Pin Enable bit (RA5 input pin disabled, MCLR pin enabled)
86:                
87:                // FICD
88:                #pragma config ICS = PGx1               // ICD Pin Placement Select bits (EMUC/EMUD share PGC1/PGD1)
89:                
90:                // #pragma config statements should precede project file includes.
91:                // Use project enums instead of #define for ON and OFF.
92:                
93:                //**********************************************************************************************************************
94:                // Main routine - start of executable code
95:                
96:                int main(void)
97:                {
98:                	initBoard(); //Initialize the pins and peripherals
002092  07FF82     RCALL initBoard
99:                
100:               	while (1) {
101:               		APP_Tasks();
002094  07FDCC     RCALL APP_Tasks
102:               		Idle(); //Idle until an interrupt is generated
002096  FE4001     PWRSAV #1
103:               		RCONbits.IDLE = 0;
002098  A94740     BCLR RCON, #2
104:               		ClrWdt();
00209A  FE6000     CLRWDT
00209C  37FFFB     BRA .L3
105:               	}
106:               
107:               	//End of while(1) main loop
108:               	return(true);
109:               }
110:               
111:               //**********************************************************************************************************************
112:               // Initialize the pins and peripherals
113:               
114:               void initBoard(void)
115:               { /****************************************************************************
116:               	 * Oscillator Init
117:               	 * Clocking is setup at 32MHz sys clock and to allow USB functionality
118:               	 * Self-tune on SOF is enabled if USB is enabled and connected to host
119:               	 ***************************************************************************/
120:               	// DOZEN disabled; DOZE 1:16; CPDIV 1:1; RCDIV FRC/1; PLLEN disabled; ROI disabled;
121:               	CLKDIVbits.RCDIV = 0;
001F98  2F8FF1     MOV #0xF8FF, W1
001F9A  207440     MOV #0x744, W0
001F9C  608810     AND W1, [W0], [W0]
122:               	OSCCONbits.COSC = 0x1;
001F9E  28FFF0     MOV #0x8FFF, W0
001FA0  803A13     MOV OSCCON, W3
001FA2  600103     AND W0, W3, W2
001FA4  A0C002     BSET W2, #12
001FA6  883A12     MOV W2, OSCCON
123:               	OSCCONbits.NOSC = 0x1;
001FA8  803A14     MOV OSCCON, W4
001FAA  608104     AND W1, W4, W2
001FAC  A08002     BSET W2, #8
001FAE  883A12     MOV W2, OSCCON
124:               
125:               	// STSRC USB; STEN enabled; STOR disabled; STORPOL Interrupt when STOR is 1; STLOCK disabled; STLPOL Interrupt when STLOCK is 1; STSIDL disabled; TUN Center frequency; 
126:               	OSCTUN = 0x0;
001FB0  EF2748     CLR OSCTUN
127:               
128:               	//Enable low voltage retention sleep mode
129:               	RCONbits.RETEN = 1;
001FB2  A88741     BSET 0x741, #4
130:               
131:               	RCONbits.SWDTEN = 0;
001FB4  A9A740     BCLR RCON, #5
132:               
133:               #ifdef SET_PMD_BITS    //see config.h, Application settings section
134:               	/****************************************************************************
135:               	 * PMD bits - setting a bit disables clocking to that peripheral
136:               	 * (drops operating current by about 2 mA when used in this app)
137:               	 ***************************************************************************/
138:               	PMD1bits.T4MD = 1;
139:               
140:               #if !defined (USE_SLEEP) || defined (SLEEP_MODE_RTCC)    //see config.h, Application settings section
141:               	PMD1bits.T1MD = 1;
142:               #endif
143:               
144:               	PMD1bits.I2C1MD = 1;
145:               	PMD1bits.U2MD = 1;
146:               	PMD1bits.SPI2MD = 1;
147:               	PMD1bits.SPI1MD = 1;
148:               	PMD3bits.TXMMD = 1;
149:               
150:               #if !defined (USE_SLEEP) || !defined (SLEEP_MODE_RTCC)    //see config.h, Application settings section
151:               	PMD3bits.RTCCMD = 1;
152:               #endif
153:               
154:               	PMD3bits.PMPMD = 1;
155:               	PMD3bits.CRCMD = 1;
156:               	PMD3bits.DAC1MD = 1;
157:               	PMD3bits.U3MD = 1;
158:               	PMD3bits.I2C2MD = 1;
159:               	PMD2 = 0xFFFF;
160:               	PMD4bits.UPWMMD = 1;
161:               	PMD4bits.U4MD = 1;
162:               	PMD4bits.REFOMD = 1;
163:               	PMD4bits.CTMUMD = 1;
164:               	PMD4bits.HLVDMD = 1;
165:               	PMD5 = 0xFFFF;
166:               	PMD6 = 0xFFFF;
167:               	PMD7 = 0xFFFF;
168:               #endif
169:               
170:               	/****************************************************************************
171:               	 * GPIO Init
172:               	 ***************************************************************************/
173:               	ANSA = 0x00;
001FB6  EF24E0     CLR ANSA
174:               	ANSB = 0x00;
001FB8  EF24E2     CLR ANSB
175:               
176:               	CNPU1 = 0;
001FBA  EF206E     CLR CNPU1
177:               	CNPU2 = 0;
001FBC  EF2070     CLR CNPU2
178:               
179:               	CNPD1 = 0;
001FBE  EF2056     CLR CNPD1
180:               	CNPD2 = 0;
001FC0  EF2058     CLR CNPD2
181:               
182:               	CNEN1 = 0x0000;
001FC2  EF2062     CLR CNEN1
183:               	CNEN2 = 0x0000;
001FC4  EF2064     CLR CNEN2
184:               
185:               	ODCB = 0x0000;
001FC6  EF22CE     CLR ODCB
186:               
187:               	//	IEC1bits.CNIE = 1;
188:               
189:               	// SSR are outputs and open-drain
190:               	ODCBbits.ODB13 = 1;
001FC8  A8A2CF     BSET 0x2CF, #5
191:               	ODCBbits.ODB12 = 1;
001FCA  A882CF     BSET 0x2CF, #4
192:               	ODCBbits.ODB4 = 1;
001FCC  A882CE     BSET ODCB, #4
193:               	ODCBbits.ODB3 = 1;
001FCE  A862CE     BSET ODCB, #3
194:               
195:               	// LEDs are outputs and off
196:               	RELAY1 = 1;
001FD0  A8A2CD     BSET 0x2CD, #5
197:               	RELAY2 = 1;
001FD2  A882CD     BSET 0x2CD, #4
198:               	RELAY3 = 1;
001FD4  A882CC     BSET LATB, #4
199:               	RELAY4 = 1;
001FD6  A862CC     BSET LATB, #3
200:               	LED5 = 0;
001FD8  A902CC     BCLR LATB, #0
201:               	LED6 = 0;
001FDA  A902CC     BCLR LATB, #0
202:               	LED7 = 0;
001FDC  A902CC     BCLR LATB, #0
203:               	LED_TRIS1 = 0;
001FDE  A9A2C9     BCLR 0x2C9, #5
204:               	LED_TRIS2 = 0;
001FE0  A982C9     BCLR 0x2C9, #4
205:               	LED_TRIS3 = 0;
001FE2  A982C8     BCLR TRISB, #4
206:               	LED_TRIS4 = 0;
001FE4  A962C8     BCLR TRISB, #3
207:               	SLED = 0;
001FE6  A9C2CD     BCLR 0x2CD, #6
208:               	SLED_TRIS = 0;
001FE8  A9C2C9     BCLR 0x2C9, #6
209:               
210:               	//RN4020 module - UART1
211:               	BT_WAKE_HW = 1; //Dormant line is set high
001FEA  A842CD     BSET 0x2CD, #2
212:               	BT_WAKE_HW_TRIS = 0; //Dormant line is output
001FEC  A942C9     BCLR 0x2C9, #2
213:               
214:               #ifdef	BT_RN4020
215:               	BT_WAKE_SW = 0; //keep low until after UART is initialized
216:               	BT_WAKE_SW_TRIS = 0;
217:               #endif
218:               
219:               #ifdef	BT_RN4871
220:               	BT_WAKE_SW_TRIS = 1; // make input for RN4871 click BO chip
001FEE  A862C9     BSET 0x2C9, #3
221:               #endif
222:               
223:               	BT_CMD = 0; //Command mode on
001FF0  A902C4     BCLR LATA, #0
224:               	BT_CMD_TRIS = 0;
001FF2  A902C0     BCLR TRISA, #0
225:               
226:               	BT_WS_TRIS = 1;
001FF4  A842C0     BSET TRISA, #2
227:               	BT_MLDP_EV_TRIS = 1;
001FF6  A882C0     BSET TRISA, #4
228:               	BT_CONNECTED_TRIS = 1;
001FF8  A822C0     BSET TRISA, #1
229:               
230:               	U1CTS_TRIS = 1;
001FFA  A802C9     BSET 0x2C9, #0
231:               	U1RX_TRIS = 1;
001FFC  A842C8     BSET TRISB, #2
232:               	U1RTS_LAT = 0;
001FFE  A922CD     BCLR 0x2CD, #1
233:               	U1RTS_TRIS = 0;
002000  A922C9     BCLR 0x2C9, #1
234:               	U1TX_TRIS = 0;
002002  A9E2C8     BCLR TRISB, #7
235:               
236:               	// SPI Master Devices
237:               	SPI_CS0_TRIS = 0;
002004  A962C0     BCLR TRISA, #3
238:               	SPI_CS1_TRIS = 0;
002006  A9E2C9     BCLR 0x2C9, #7
239:               
240:               	/* SPI2 HW setup */
241:               	SSP2CON1bits.SSPM = 2; // SPI MASTER SCK speed
002008  2FFF02     MOV #0xFFF0, W2
00200A  801093     MOV SSP2CON1, W3
00200C  610103     AND W2, W3, W2
00200E  A01002     BSET W2, #1
002010  881092     MOV W2, SSP2CON1
242:               	SSP2CON1bits.CKP = 0; // SCK polarity mode 0,0
002012  A98212     BCLR SSP2CON1, #4
243:               	SSP2STATbits.CKE = 0; // SCK select 
002014  A9C218     BCLR SSP2STAT, #6
244:               	SSP2STATbits.SMP = 0; // sample mid
002016  A9E218     BCLR SSP2STAT, #7
245:               	SSP2CON1bits.SSPEN = 1; // enable spi ports
002018  A8A212     BSET SSP2CON1, #5
246:               	PADCFG1bits.SCK2DIS = 0;
00201A  A942FD     BCLR 0x2FD, #2
247:               	PADCFG1bits.SDA2DIS = 0;
00201C  A962FD     BCLR 0x2FD, #3
248:               
249:               	/****************************************************************************
250:               	 * PPS Init - Peripheral Pin Select
251:               	 * Click Boards using PPS-controlled peripherals will require additional
252:               	 * setup here
253:               	 ***************************************************************************/
254:               	__builtin_disi(0x3FFF); //disable interrupts
00201E  FC3FFF     DISI #0x3FFF
255:               
256:               	//unlock registers
257:               	__builtin_write_OSCCONL(OSCCON & 0xBF);
002020  200BF4     MOV #0xBF, W4
002022  803A12     MOV OSCCON, W2
002024  620202     AND W4, W2, W4
002026  200462     MOV #0x46, W2
002028  200573     MOV #0x57, W3
00202A  207425     MOV #0x742, W5
00202C  784A82     MOV.B W2, [W5]
00202E  784A83     MOV.B W3, [W5]
002030  784A84     MOV.B W4, [W5]
258:               
259:               	__builtin_write_OSCCONL(OSCCON | 0x40);
002032  803A14     MOV OSCCON, W4
002034  A06004     BSET W4, #6
002036  207425     MOV #0x742, W5
002038  784A82     MOV.B W2, [W5]
00203A  784A83     MOV.B W3, [W5]
00203C  784A84     MOV.B W4, [W5]
260:               
261:               	__builtin_disi(0); //enable interrupts
00203E  FC0000     DISI #0x0
262:               
263:               	/****************************************************************************
264:               	 * Interrupt Priorities
265:               	 * Interrupt-enabled peripherals being used for Click Boards should be
266:               	 * configured here as well
267:               	 ***************************************************************************/
268:               
269:               	// SPI
270:               	// error vector
271:               	IPC12bits.BCL2IP = 6;
002040  8005E4     MOV IPC12, W4
002042  608184     AND W1, W4, W3
002044  206002     MOV #0x600, W2
002046  710103     IOR W2, W3, W2
002048  8805E2     MOV W2, IPC12
272:               	// spi_buf
273:               	IPC12bits.SSP2IP = 5;
00204A  2FF8F2     MOV #0xFF8F, W2
00204C  8005E4     MOV IPC12, W4
00204E  610184     AND W2, W4, W3
002050  B30503     IOR #0x50, W3
002052  8805E3     MOV W3, IPC12
274:               
275:               	//    UERI: U1E - UART1 Error
276:               	//    Priority: 6
277:               	IPC16bits.U1ERIP = 6;
002054  800624     MOV IPC16, W4
002056  610184     AND W2, W4, W3
002058  B30603     IOR #0x60, W3
00205A  880623     MOV W3, IPC16
278:               
279:               	//    UTXI: U1TX - UART1 Transmitter
280:               	//    Priority: 5
281:               	IPC3bits.U1TXIP = 5;
00205C  2FFF83     MOV #0xFFF8, W3
00205E  800554     MOV IPC3, W4
002060  618184     AND W3, W4, W3
002062  B30053     IOR #0x5, W3
002064  880553     MOV W3, IPC3
282:               
283:               	//    URXI: U1RX - UART1 Receiver
284:               	//    Priority: 5
285:               	IPC2bits.U1RXIP = 5;
002066  800543     MOV IPC2, W3
002068  600203     AND W0, W3, W4
00206A  250003     MOV #0x5000, W3
00206C  718184     IOR W3, W4, W3
00206E  880543     MOV W3, IPC2
286:               
287:               
288:               	//    TI: T1 - Timer1
289:               	//    Priority: 3
290:               	IPC0bits.T1IP = 3;
002070  800523     MOV IPC0, W3
002072  600203     AND W0, W3, W4
002074  230003     MOV #0x3000, W3
002076  718184     IOR W3, W4, W3
002078  880523     MOV W3, IPC0
291:               
292:               	//    RTCI: RTCC - Real-Time Clock and Calendar
293:               	//    Priority: 2
294:               	IPC15bits.RTCIP = 2;
00207A  800614     MOV IPC15, W4
00207C  608084     AND W1, W4, W1
00207E  A09001     BSET W1, #9
002080  880611     MOV W1, IPC15
295:               
296:               	//    CN: Switches - change notification
297:               	//    Priority: 2
298:               	IPC4bits.CNIP = 2;
002082  B600AC     AND IPC4, WREG
002084  A0D000     BSET W0, #13
002086  880560     MOV W0, IPC4
299:               
300:               	//    ADI: ADC1 - Pipeline A/D Converter 1
301:               	//    Priority: 1
302:               	IPC3bits.AD1IP = 1;
002088  800550     MOV IPC3, W0
00208A  610100     AND W2, W0, W2
00208C  A04002     BSET W2, #4
00208E  880552     MOV W2, IPC3
303:               }
002090  060000     RETURN
---  /root/MPLABXProjects/fac_relay_clone/link.c  -------------------------------------------------------
1:                 #include <xc.h>
2:                 #include <string.h>
3:                 #include <stdint.h>
4:                 #include <stdio.h>
5:                 #include <stdbool.h>
6:                 #include "config.h"
7:                 #include "app.h"
8:                 #include "spi.h"
9:                 #include "link.h"
10:                
11:                static struct LINK_DATA l_data = {LINK_BYTES};
12:                
13:                bool Write_Link_Packet(const uint8_t *data, bool start)
0023F4  4404E7     ADD W8, #0x7, W9
14:                {
0023E2  BE9F88     MOV.D W8, [W15++]
0023E4  781F8A     MOV W10, [W15++]
0023E6  780400     MOV W0, W8
0023E8  784501     MOV.B W1, W10
15:                	uint16_t i;
16:                
17:                	if (!SPI_IsTxData()) {
0023EA  07FEAF     RCALL SPI_IsTxData
0023EC  784080     MOV.B W0, W1
0023F0  E00401     CP0.B W1
0023F2  3A0013     BRA NZ, .L2
18:                		for (i = 0; i < LINK_BYTES; i++) { // start with SOF char then data bytes
002400  540F89     SUB W8, W9, [W15]
002402  3AFFF9     BRA NZ, .L3
19:                			if (SPI_GetTXBufferFreeSpace() < 2)
0023F6  07FEC1     RCALL SPI_GetTXBufferFreeSpace
0023F8  500FE1     SUB W0, #0x1, [W15]
0023FA  36000E     BRA LEU, .L5
20:                				return false;
002418  EB4000     CLR.B W0
21:                			SPI_WriteTxBuffer(*data++); //Load byte into the transmit buffer
0023FC  784038     MOV.B [W8++], W0
0023FE  07FEAE     RCALL SPI_WriteTxBuffer
22:                		}
23:                		SPI_WriteTxBuffer(SPI_CHECKMARK); //checkmark for EOF
002404  B3C570     MOV.B #0x57, W0
002406  07FEAA     RCALL SPI_WriteTxBuffer
24:                
25:                		if (start) {
00240A  E0040A     CP0.B W10
00240C  320006     BRA Z, .L2
26:                			SPI_Speed(1); // high speed
00240E  07FE59     RCALL SPI_Speed
27:                			SPI_CS1 = 0; // select the PIC slave
002410  A9E2CD     BCLR 0x2CD, #7
28:                			SPI_TxStart(); //Start transmitting the bytes
002412  07FE6E     RCALL SPI_TxStart
29:                		}
30:                		return true;
002408  B3C010     MOV.B #0x1, W0
002414  B3C010     MOV.B #0x1, W0
002416  370001     BRA .L2
31:                	} else
32:                		return false;
0023EE  EB4000     CLR.B W0
33:                }
00241A  78054F     MOV [--W15], W10
00241C  BE044F     MOV.D [--W15], W8
00241E  060000     RETURN
34:                
35:                struct LINK_DATA* Read_Link_Packet(const uint8_t *data)
36:                {
37:                	return memcpy(&l_data, data, LINK_BYTES);
002420  20C8C1     MOV #0xC8C, W1
002422  090006     REPEAT #0x6
002424  7858B0     MOV.B [W0++], [W1++]
002426  B10070     SUB #0x7, W0
38:                }
002428  20C8C0     MOV #0xC8C, W0
00242A  060000     RETURN
39:                
40:                struct LINK_DATA* Get_Link_Packet(void)
41:                {
42:                	return &l_data;
43:                }
00242C  20C8C0     MOV #0xC8C, W0
---  /root/MPLABXProjects/fac_relay_clone/leds.c  -------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        leds.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 * add relay outputs
32:                 *
33:                 * LED functions
34:                 *
35:                 */
36:                
37:                #include "timers.h"
38:                #include "config.h"
39:                #include "leds.h"
40:                #include "app.h"
41:                
42:                extern APP_DATA appData;
43:                extern ADC_DATA adcData;
44:                static LED_LIGHTSHOW_T lightShow = LED_IDLE;
45:                
46:                void LED_Tasks()
47:                {
48:                	switch (lightShow) {
001E72  8064D0     MOV lightShow, W0
001E74  500FE2     SUB W0, #0x2, [W15]
001E76  32001F     BRA Z, .L5
001E78  3E0005     BRA GTU, .L8
001E7A  E00000     CP0 W0
001E7C  320008     BRA Z, .L3
001E7E  500FE1     SUB W0, #0x1, [W15]
001E80  3A004D     BRA NZ, .L1
001E82  370008     BRA .L13
001E84  500FE3     SUB W0, #0x3, [W15]
001E86  32003A     BRA Z, .L6
001E88  500FE4     SUB W0, #0x4, [W15]
001E8A  3A0048     BRA NZ, .L1
001E8C  370045     BRA .L14
49:                	case LED_IDLE:
50:                		SLED = 1;
001E8E  A8C2CD     BSET 0x2CD, #6
51:                		LED6 = 0;
001E90  A902CC     BCLR LATB, #0
52:                		break;
001E92  370044     BRA .L1
53:                
54:                	case LED_BTLE_ADVERTISING:
55:                		if (TimerDone(TMR_LEDS)) {
001E94  B3C010     MOV.B #0x1, W0
001E96  0702FF     RCALL .LFE1, .LFB2, _TimerDone
001E98  E00400     CP0.B W0
001E9A  320040     BRA Z, .L1
56:                			SLED ^= 1;
001E9C  801660     MOV LATB, W0
001E9E  DE004E     LSR W0, #14, W0
001EA0  EA8000     COM W0, W0
001EA2  600061     AND W0, #0x1, W0
001EA4  DD004E     SL W0, #14, W0
001EA6  801661     MOV LATB, W1
001EA8  A1E001     BCLR W1, #14
001EAA  700081     IOR W0, W1, W1
001EAC  881661     MOV W1, LATB
57:                			StartTimer(TMR_LEDS, LED_BLINK_MS);
001EAE  203841     MOV #0x384, W1
001EB0  B3C010     MOV.B #0x1, W0
001EB2  0702EB     RCALL .LFE0, .LFB1, _StartTimer
001EB4  370033     BRA .L1
58:                		}
59:                		break;
60:                
61:                	case LED_BTLE_PAIRED:
62:                		RELAY1 = !appData.led1; // logic low turns on relay
001EB6  BFCB92     MOV.B 0xB92, WREG
001EB8  A20400     BTG.B W0, #0
001EBA  600061     AND W0, #0x1, W0
001EBC  DD004D     SL W0, #13, W0
001EBE  801661     MOV LATB, W1
001EC0  A1D001     BCLR W1, #13
001EC2  700081     IOR W0, W1, W1
001EC4  881661     MOV W1, LATB
63:                		RELAY2 = !appData.led2;
001EC6  BFCB93     MOV.B 0xB93, WREG
001EC8  A20400     BTG.B W0, #0
001ECA  600061     AND W0, #0x1, W0
001ECC  DD004C     SL W0, #12, W0
001ECE  801661     MOV LATB, W1
001ED0  A1C001     BCLR W1, #12
001ED2  700081     IOR W0, W1, W1
001ED4  881661     MOV W1, LATB
64:                		RELAY3 = !appData.led3;
001ED6  BFCB94     MOV.B 0xB94, WREG
001ED8  A20400     BTG.B W0, #0
001EDA  600061     AND W0, #0x1, W0
001EDC  DD0044     SL W0, #4, W0
001EDE  801661     MOV LATB, W1
001EE0  A14001     BCLR W1, #4
001EE2  700081     IOR W0, W1, W1
001EE4  881661     MOV W1, LATB
65:                		RELAY4 = !appData.led4;
001EE6  BFCB95     MOV.B 0xB95, WREG
001EE8  A20400     BTG.B W0, #0
001EEA  600061     AND W0, #0x1, W0
001EEC  DD0043     SL W0, #3, W0
001EEE  801661     MOV LATB, W1
001EF0  A13001     BCLR W1, #3
001EF2  700081     IOR W0, W1, W1
001EF4  881661     MOV W1, LATB
66:                		SLED = 1;
001EF6  A8C2CD     BSET 0x2CD, #6
67:                		LED6 = 0;
001EF8  A902CC     BCLR LATB, #0
68:                		break;
001EFA  370010     BRA .L1
69:                
70:                	case LED_ERROR:
71:                		switch (appData.error_code) {
001EFC  BFCB9E     MOV.B 0xB9E, WREG
001EFE  404FE3     ADD.B W0, #0x3, [W15]
001F00  320005     BRA Z, .L10
001F02  404FE2     ADD.B W0, #0x2, [W15]
001F04  3A0006     BRA NZ, .L12
72:                		case ERROR_INITIALIZATION:
73:                			SLED = 0;
001F06  A9C2CD     BCLR 0x2CD, #6
74:                			LED6 = 1;
001F08  A802CC     BSET LATB, #0
75:                			break;
001F0A  370008     BRA .L1
76:                		case ERROR_RN_FW:
77:                			SLED = 0;
001F0C  A9C2CD     BCLR 0x2CD, #6
78:                			LED6 = 1;
001F0E  A802CC     BSET LATB, #0
79:                			break;
001F10  370005     BRA .L1
80:                		default:
81:                			SLED = 0;
001F12  A9C2CD     BCLR 0x2CD, #6
82:                			LED6 = 1;
001F14  A802CC     BSET LATB, #0
83:                			break;
001F16  370002     BRA .L1
84:                		}
85:                		break;
86:                
87:                	case LED_SLEEP:
88:                		SLED = 0;
001F18  A9C2CD     BCLR 0x2CD, #6
89:                		LED6 = 1;
001F1A  A802CC     BSET LATB, #0
90:                		break;
91:                
92:                	default:
93:                		break;
94:                	}
95:                }
001F1C  060000     RETURN
96:                
97:                inline void LED_SET_LightShow(LED_LIGHTSHOW_T setting)
98:                {
99:                	lightShow = setting;
001F1E  8864D0     MOV W0, lightShow
100:               }
001F20  060000     RETURN
101:               
102:               //Update LEDs with status from LED update message
103:               
104:               void GetNewLEDs(char * receive_packet)
105:               {
106:               	if (!appData.update_packet) {
001F22  E24B8F     CP0.B 0xB8F
001F24  3A0011     BRA NZ, .L17
107:               		appData.led1 = appData.oled1;
001F26  20B981     MOV #0xB98, W1
001F28  784091     MOV.B [W1], W1
001F2A  20B922     MOV #0xB92, W2
001F2C  784901     MOV.B W1, [W2]
108:               		appData.led2 = appData.oled2;
001F2E  20B993     MOV #0xB99, W3
001F30  784193     MOV.B [W3], W3
001F32  20B934     MOV #0xB93, W4
001F34  784A03     MOV.B W3, [W4]
109:               		appData.led3 = appData.oled3;
001F36  20B9A5     MOV #0xB9A, W5
001F38  784295     MOV.B [W5], W5
001F3A  20B946     MOV #0xB94, W6
001F3C  784B05     MOV.B W5, [W6]
110:               		appData.led4 = appData.oled4;
001F3E  20B9B1     MOV #0xB9B, W1
001F40  784091     MOV.B [W1], W1
001F42  20B952     MOV #0xB95, W2
001F44  784901     MOV.B W1, [W2]
001F46  370027     BRA .L16
111:               	} else {
112:               		appData.led1 = receive_packet[9] == '1' ? 1 : 0;
001F48  904A10     MOV.B [W0+9], W4
001F4A  B3C311     MOV.B #0x31, W1
001F4C  6A4201     XOR.B W4, W1, W4
001F4E  FB8204     ZE W4, W4
001F50  E90204     DEC W4, W4
001F52  DE224F     LSR W4, #15, W4
001F54  20B923     MOV #0xB92, W3
001F56  784984     MOV.B W4, [W3]
113:               		appData.led2 = receive_packet[11] == '1' ? 1 : 0;
001F58  9049B0     MOV.B [W0+11], W3
001F5A  69C181     XOR.B W3, W1, W3
001F5C  FB8183     ZE W3, W3
001F5E  E90183     DEC W3, W3
001F60  DE19CF     LSR W3, #15, W3
001F62  20B936     MOV #0xB93, W6
001F64  784B03     MOV.B W3, [W6]
114:               		appData.led3 = receive_packet[13] == '1' ? 1 : 0;
001F66  904950     MOV.B [W0+13], W2
001F68  694101     XOR.B W2, W1, W2
001F6A  FB8102     ZE W2, W2
001F6C  E90102     DEC W2, W2
001F6E  DE114F     LSR W2, #15, W2
001F70  20B945     MOV #0xB94, W5
001F72  784A82     MOV.B W2, [W5]
115:               		appData.led4 = receive_packet[15] == '1' ? 1 : 0;
001F74  904870     MOV.B [W0+15], W0
001F76  684081     XOR.B W0, W1, W1
001F78  FB8081     ZE W1, W1
001F7A  E90081     DEC W1, W1
001F7C  DE08CF     LSR W1, #15, W1
001F7E  20B950     MOV #0xB95, W0
001F80  784801     MOV.B W1, [W0]
116:               		appData.oled1 = appData.led1;
001F82  784004     MOV.B W4, W0
001F84  B7EB98     MOV.B WREG, .L27
117:               		appData.oled2 = appData.led2;
001F86  784283     MOV.B W3, W5
001F88  20B994     MOV #0xB99, W4
001F8A  784A05     MOV.B W5, [W4]
118:               		appData.oled3 = appData.led3;
001F8C  784002     MOV.B W2, W0
001F8E  B7EB9A     MOV.B WREG, 0xB9A
119:               		appData.oled4 = appData.led4;
001F90  784181     MOV.B W1, W3
001F92  20B9B2     MOV #0xB9B, W2
001F94  784903     MOV.B W3, [W2]
120:               	}
121:               }
001F96  060000     RETURN
---  /root/MPLABXProjects/fac_relay_clone/bluetooth.c  --------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        bluetooth.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Functions to communicate with a RN4020 Bluetooth LE module over a UART
33:                 * 
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdio.h>
39:                #include <stdbool.h>
40:                #include "bluetooth.h"
41:                #include "config.h"
42:                #include "app.h"
43:                #include "uart.h"
44:                #include "timers.h"
45:                #include <stdlib.h>
46:                #include <string.h>
47:                
48:                extern APP_DATA appData;
49:                
50:                uint16_t BT_CheckFwVer(void);
51:                
52:                // dump serial buffer and clean possible lockup flags
53:                void clear_bt_port(void)
54:                {
00157C  781F88     MOV W8, [W15++]
55:                	while (UART_IsNewRxData()) { //While buffer contains old data
001580  370006     BRA .L7
00158E  0706F0     RCALL UART_IsNewRxData
001590  E00400     CP0.B W0
001592  3AFFF7     BRA NZ, .L4
56:                		UART_ReadRxBuffer(); //Keep reading until empty
001582  0706FF     RCALL UART_ReadRxBuffer
57:                		if (!UART_IsNewRxData()) {
001584  0706F5     RCALL UART_IsNewRxData
001586  E00400     CP0.B W0
001588  3A0002     BRA NZ, .L7
58:                			WaitMs(100);
00157E  200648     MOV #0x64, W8
00158A  780008     MOV W8, W0
00158C  07078D     RCALL WaitMs
59:                		}
60:                	}
61:                	//Clear any UART error bits
62:                	U1STAbits.FERR = 0;
001594  A94222     BCLR U1STA, #2
63:                	U1STAbits.PERR = 0;
001596  A96222     BCLR U1STA, #3
64:                }
001598  78044F     MOV [--W15], W8
00159A  060000     RETURN
65:                
66:                //**********************************************************************************************************************
67:                // Receive a message over the Bluetooth link
68:                
69:                bool BT_ReceivePacket(char * Message)
70:                {
00159C  BE9F88     MOV.D W8, [W15++]
00159E  780400     MOV W0, W8
71:                	static enum BluetoothDecodeState btDecodeState = WaitForCR; //Static so maintains state on reentry   //Byte read from the UART buffer
72:                	static uint16_t i = 0;
73:                
74:                	if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
0015A0  0706E7     RCALL UART_IsNewRxData
0015A2  784080     MOV.B W0, W1
0015A6  E00401     CP0.B W1
0015A8  320035     BRA Z, .L9
75:                	{
76:                		Message[i++] = UART_ReadRxBuffer();
0015AA  8064A9     MOV i, W9
0015AC  0706EA     RCALL UART_ReadRxBuffer
0015AE  7CF400     MOV.B W0, [W8+W9]
0015B0  E80489     INC W9, W9
0015B2  8864A9     MOV W9, i
77:                		if (i == BT_RX_PKT_SZ) {
0015B4  201000     MOV #0x100, W0
0015B6  548F80     SUB W9, W0, [W15]
0015B8  3A0001     BRA NZ, .L10
78:                			i = 0;
0015BA  EF2C94     CLR i
79:                		}
80:                
81:                		if (!appData.rn_4871_packets) {
0015BC  E24B9D     CP0.B 0xB9D
0015BE  3A001E     BRA NZ, .L11
82:                			switch (btDecodeState) {
0015C0  8064B0     MOV btDecodeState, W0
0015C2  E00000     CP0 W0
0015C4  320003     BRA Z, .L13
0015C6  500FE1     SUB W0, #0x1, [W15]
0015C8  3A0016     BRA NZ, .L19
0015CA  37000A     BRA .L20
83:                			case WaitForCR:
84:                				if (Message[i - 1] == '\r') { //See if this is the CR
0015CC  8064A0     MOV i, W0
0015CE  440400     ADD W8, W0, W8
0015D0  97F8F8     MOV.B [W8-1], W1
0015D4  50CFED     SUB.B W1, #0xD, [W15]
0015D6  3A001E     BRA NZ, .L9
85:                					btDecodeState = WaitForLF; //Is CR so wait for LF
0015D8  200010     MOV #0x1, W0
0015DA  8864B0     MOV W0, btDecodeState
86:                				}
87:                				break;
88:                
89:                			case WaitForLF:
90:                				btDecodeState = WaitForCR; //Will be looking for a new packet next
0015E0  EF2C96     CLR btDecodeState
91:                				if (Message[i - 1] == '\n') //See if this is the LF
0015E2  8064A1     MOV i, W1
0015E4  440001     ADD W8, W1, W0
0015E6  97F970     MOV.B [W0-1], W2
0015EA  514FEA     SUB.B W2, #0xA, [W15]
0015EC  3A0013     BRA NZ, .L9
92:                				{
93:                					Message[i] = NULL; //Got a complete message!
0015EE  78F400     MOV.B W0, [W8+W1]
94:                					i = 0;
0015F0  EF2C94     CLR i
95:                					return true;
0015F2  B3C010     MOV.B #0x1, W0
0015F4  37000F     BRA .L9
96:                				}
97:                				break;
98:                
99:                			default: //Invalid state so start looking for a new start of frame
100:               				btDecodeState = WaitForCR;
0015F6  EF2C96     CLR btDecodeState
101:               			}
102:               
103:               		} else {
104:               			appData.rn_4871_packets = false;
0015FC  EF6B9D     CLR.B 0xB9D
105:               			if (Message[i - 1] == '#') //See if this is the end
0015FE  8064A1     MOV i, W1
001600  440001     ADD W8, W1, W0
001602  97F9F0     MOV.B [W0-1], W3
001606  B3C232     MOV.B #0x23, W2
001608  51CF82     SUB.B W3, W2, [W15]
00160A  3A0004     BRA NZ, .L9
106:               			{
107:               				btDecodeState = WaitForCR; //Will be looking for a new packet next
00160C  EF2C96     CLR btDecodeState
108:               				Message[i] = NULL; //Got a complete message!
00160E  78F400     MOV.B W0, [W8+W1]
109:               				i = 0;
001610  EF2C94     CLR i
110:               				return true;
001612  B3C010     MOV.B #0x1, W0
111:               			}
112:               		}
113:               	}
114:               	return false;
0015A4  EB4000     CLR.B W0
0015D2  EB4000     CLR.B W0
0015DC  EB4000     CLR.B W0
0015DE  37001A     BRA .L9
0015E8  EB4000     CLR.B W0
0015F8  EB4000     CLR.B W0
0015FA  37000C     BRA .L9
001604  EB4000     CLR.B W0
115:               }
001614  BE044F     MOV.D [--W15], W8
001616  060000     RETURN
116:               
117:               //**********************************************************************************************************************
118:               // Send a command to the RN4020 module
119:               //Return true for success, false for busy
120:               
121:               bool BT_SendCommand(const char *data, bool wait)
001652  200FF9     MOV #0xFF, W9
001654  448488     ADD W9, W8, W9
001656  37FFEF     BRA .L27
122:               {
001618  BE9F88     MOV.D W8, [W15++]
00161A  780400     MOV W0, W8
00161C  784481     MOV.B W1, W9
123:               	uint16_t i;
124:               	//Only transmit a message if TX timer expired, or wait flag is set to false
125:               	//We limit transmission frequency to avoid overwhelming the BTLE link
126:               	if (TimerDone(TMR_BT_TX) || wait == false) {
00161E  B3C090     MOV.B #0x9, W0
001620  07073A     RCALL .LFE1, .LFB2, _TimerDone
001622  E00400     CP0.B W0
001624  320004     BRA Z, .L22
001630  E00409     CP0.B W9
001632  32FFF9     BRA Z, .L25
001634  37000B     BRA .L26
127:               		for (i = 0; i < SIZE_TxBuffer; i++) {
00163E  540F89     SUB W8, W9, [W15]
001640  3AFFFA     BRA NZ, .L27
128:               			if (*data != '\0') //Keep loading bytes until end of string
001626  784018     MOV.B [W8], W0
001628  E00400     CP0.B W0
00162A  3A0012     BRA NZ, .L23
00162C  37000A     BRA .L24
001636  784058     MOV.B [++W8], W0
001638  E00400     CP0.B W0
00163A  320003     BRA Z, .L24
129:               				UART_WriteTxBuffer(*data++); //Load byte into the transmit buffer
00163C  0706B3     RCALL UART_WriteTxBuffer
001650  0706A9     RCALL UART_WriteTxBuffer
130:               			else
131:               				break;
132:               		}
133:               		UART_TxStart(); //Start transmitting the bytes
001642  070694     RCALL UART_TxStart
134:               		StartTimer(TMR_BT_TX, BT_TX_MS); //Restart transmit timer
001644  2003C1     MOV #0x3C, W1
001646  B3C090     MOV.B #0x9, W0
001648  070720     RCALL .LFE0, .LFB1, _StartTimer
135:               		return true;
00164A  B3C010     MOV.B #0x1, W0
136:               	}
137:               	return false;
00162E  EB4000     CLR.B W0
138:               }
00164C  BE044F     MOV.D [--W15], W8
00164E  060000     RETURN
001650  0706A9     RCALL UART_WriteTxBuffer
001652  200FF9     MOV #0xFF, W9
001654  448488     ADD W9, W8, W9
001656  37FFEF     BRA .L27
139:               
140:               //**********************************************************************************************************************
141:               // Send a byte to the RN4020 module
142:               
143:               void BT_SendByte(char data)
144:               {
145:               	UART_WriteTxBuffer(data); //Load byte into the transmit buffer
001658  0706A5     RCALL UART_WriteTxBuffer
146:               	UART_TxStart(); //Start transmitting the byte
00165A  070688     RCALL UART_TxStart
147:               }
00165C  060000     RETURN
148:               
149:               //**********************************************************************************************************************
150:               // Get a response from the RN4020 module
151:               
152:               bool BT_GetResponse(char *data)
153:               {
00165E  BE9F88     MOV.D W8, [W15++]
001660  BE9F8A     MOV.D W10, [W15++]
001662  780480     MOV W0, W9
154:               	uint16_t byteCount = 0;
00166A  EB0400     CLR W8
155:               	char newByte;
156:               
157:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
001664  202581     MOV #0x258, W1
001666  B3C020     MOV.B #0x2, W0
001668  070710     RCALL .LFE0, .LFB1, _StartTimer
158:               
159:               	while (byteCount < BT_RX_PKT_SZ) //Don't accept more than the buffer size
00166E  200FFB     MOV #0xFF, W11
00168A  540F8B     SUB W8, W11, [W15]
00168C  36FFF1     BRA LEU, .L33
00168E  370003     BRA .L32
160:               	{
161:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
001670  07067F     RCALL UART_IsNewRxData
001672  E00400     CP0.B W0
001674  320006     BRA Z, .L31
162:               		{
163:               			newByte = UART_ReadRxBuffer(); //Read the data byte for processing
001676  070685     RCALL UART_ReadRxBuffer
164:               			*data++ = newByte; //Add it to the buffer
001678  784C80     MOV.B W0, [W9]
00167E  E80489     INC W9, W9
165:               			byteCount++; //Keep track of the number of bytes received
001680  E80408     INC W8, W8
166:               			if (newByte == '\n') //Check if got linefeed
00167A  504FEA     SUB.B W0, #0xA, [W15]
00167C  320009     BRA Z, .L34
167:               				return true; //If linefeed then return success
001690  B3C010     MOV.B #0x1, W0
001692  370001     BRA .L32
168:               		}
169:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
00166C  B3C02A     MOV.B #0x2, W10
001682  78400A     MOV.B W10, W0
001684  070708     RCALL .LFE1, .LFB2, _TimerDone
001686  E00400     CP0.B W0
001688  3A0005     BRA NZ, .L35
170:               			return false; //If timed out then return failure
001694  EB4000     CLR.B W0
171:               	}
172:               	return false;
173:               }
001696  BE054F     MOV.D [--W15], W10
001698  BE044F     MOV.D [--W15], W8
00169A  060000     RETURN
174:               
175:               //**********************************************************************************************************************
176:               // Compare the buffer with the response with one of the expected responses
177:               
178:               bool BT_CompareResponse(const char *data1, const char *data2)
0016AC  B00311     ADD #0x31, W1
179:               {
180:               	uint16_t i;
181:               
182:               	for (i = 0; i < 50; i++) //Compare up to 50 bytes
0016B8  510F81     SUB W2, W1, [W15]
0016BA  320006     BRA Z, .L44
183:               	{
184:               		if (*data1 == '\0') //See if reached end of string with no bytes different
00169C  784190     MOV.B [W0], W3
0016A0  E00403     CP0.B W3
0016A2  320013     BRA Z, .L38
0016AE  7841D0     MOV.B [++W0], W3
0016B0  E00403     CP0.B W3
0016B2  320006     BRA Z, .L42
185:               			return true; //No bytes were different so return success
00169E  B3C012     MOV.B #0x1, W2
0016C0  B3C012     MOV.B #0x1, W2
0016C2  370003     BRA .L38
186:               		else if (*data1++ != *data2++) //else see if the bytes are different
0016A6  51CF91     SUB.B W3, [W1], [W15]
0016A8  3A0010     BRA NZ, .L38
0016AA  E80101     INC W1, W2
0016B4  51CF92     SUB.B W3, [W2], [W15]
0016B6  3A0006     BRA NZ, .L43
0016BC  E80102     INC W2, W2
0016BE  37FFF7     BRA .L39
187:               			return false; //Bytes differ so return failure
0016A4  EB4100     CLR.B W2
0016C4  EB4100     CLR.B W2
0016C6  370001     BRA .L38
188:               	}
189:               	return false; //Did not reach end of string so return failure
0016C8  EB4100     CLR.B W2
190:               }
0016CA  784002     MOV.B W2, W0
0016CC  060000     RETURN
191:               
192:               //**********************************************************************************************************************
193:               // Get a response from the RNxxxx module and compare with an expected response
194:               
195:               bool BT_CheckResponse(const char *data)
196:               {
0016CE  B0034F     ADD #0x34, W15
0016D0  BE9F88     MOV.D W8, [W15++]
0016D2  BE9F8A     MOV.D W10, [W15++]
0016D4  781F8E     MOV W14, [W15++]
0016D6  780580     MOV W0, W11
197:               	uint16_t i, ByteCount = 0;
0016E2  EB0400     CLR W8
198:               	char NewByte, Buffer[50], *BufPtr;
199:               
200:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
0016D8  202581     MOV #0x258, W1
0016DA  B3C020     MOV.B #0x2, W0
0016DC  0706D6     RCALL .LFE0, .LFB1, _StartTimer
201:               
202:               	BufPtr = Buffer;
0016DE  2FFC4E     MOV #0xFFC4, W14
0016E0  47070F     ADD W14, W15, W14
203:               	while (ByteCount < 50) //Don't accept more than the buffer size
0016E6  20031A     MOV #0x31, W10
001702  540F8A     SUB W8, W10, [W15]
001704  36FFF1     BRA LEU, .L49
204:               	{
205:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
0016E8  070643     RCALL UART_IsNewRxData
0016EA  E00400     CP0.B W0
0016EC  320006     BRA Z, .L46
206:               		{
207:               			NewByte = (char) UART_ReadRxBuffer(); //Read the data byte for processing
0016EE  070649     RCALL UART_ReadRxBuffer
208:               			*BufPtr++ = NewByte; //Add it to the buffer
0016F0  784F00     MOV.B W0, [W14]
0016F8  E8070E     INC W14, W14
209:               			ByteCount++;
0016F2  E80408     INC W8, W8
210:               			if (NewByte == '\n') //Check if got linefeed
0016F4  504FEA     SUB.B W0, #0xA, [W15]
0016F6  320007     BRA Z, .L47
211:               				break; //If linefeed then we have what we want
212:               		}
213:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
0016E4  B3C029     MOV.B #0x2, W9
0016FA  784009     MOV.B W9, W0
0016FC  0706CC     RCALL .LFE1, .LFB2, _TimerDone
0016FE  E00400     CP0.B W0
001700  3A001A     BRA NZ, .L52
214:               			return false; //If timed out then return failure
001736  EB4000     CLR.B W0
001738  370003     BRA .L48
215:               	}
216:               
217:               	BufPtr = Buffer;
218:               	for (i = 0; i < ByteCount; i++) //Compare all bytes received
001708  E00008     CP0 W8
00170A  32001A     BRA Z, .L48
00171E  EB0000     CLR W0
001720  370005     BRA .L50
00172C  E80000     INC W0, W0
00172E  540F80     SUB W8, W0, [W15]
001730  3EFFF8     BRA GTU, .L51
219:               	{
220:               		if (*data == '\0') //See if reached end of string with no bytes different
00170C  78409B     MOV.B [W11], W1
00170E  E00401     CP0.B W1
001710  320017     BRA Z, .L48
001722  7840DB     MOV.B [++W11], W1
001724  E00401     CP0.B W1
001726  320009     BRA Z, .L56
221:               			return true; //No bytes were different so return success
00173A  B3C010     MOV.B #0x1, W0
00173C  370001     BRA .L48
222:               		else if (*data++ != *BufPtr++) //else see if the bytes are different
001714  97C14F     MOV.B [W15-60], W2
001716  50CF82     SUB.B W1, W2, [W15]
001718  3A0013     BRA NZ, .L48
00171A  2FFC4E     MOV #0xFFC4, W14
00171C  47070F     ADD W14, W15, W14
001728  50CFDE     SUB.B W1, [++W14], [W15]
00172A  3A0009     BRA NZ, .L57
223:               			return false; //Bytes differ so return failure
001712  EB4000     CLR.B W0
00173E  EB4000     CLR.B W0
224:               	}
225:               	return true; //All bytes matched so return success
001706  B3C010     MOV.B #0x1, W0
001732  B3C010     MOV.B #0x1, W0
001734  370005     BRA .L48
226:               }
001740  78074F     MOV [--W15], W14
001742  BE054F     MOV.D [--W15], W10
001744  BE044F     MOV.D [--W15], W8
001746  B1034F     SUB #0x34, W15
001748  060000     RETURN
227:               
228:               //**********************************************************************************************************************
229:               // Get a response from the RN4020 module and compare with an expected response
230:               //   All incoming bytes in the position of the wildcard character are ignored
231:               //   Use this to ignore text that changes, like MAC addresses.
232:               
233:               bool BT_CheckResponseWithWildcard(const char *data, char Wildcard)
001792  E8060C     INC W12, W12
234:               {
00174A  B0034F     ADD #0x34, W15
00174C  BE9F88     MOV.D W8, [W15++]
00174E  BE9F8A     MOV.D W10, [W15++]
001750  781F8C     MOV W12, [W15++]
001752  781F8E     MOV W14, [W15++]
001754  780600     MOV W0, W12
001756  784581     MOV.B W1, W11
235:               	uint16_t i, ByteCount = 0;
001762  EB0400     CLR W8
236:               	char NewByte, Buffer[50], *BufPtr;
237:               
238:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
001758  202581     MOV #0x258, W1
00175A  B3C020     MOV.B #0x2, W0
00175C  070696     RCALL .LFE0, .LFB1, _StartTimer
239:               
240:               	BufPtr = Buffer;
00175E  2FFC2E     MOV #0xFFC2, W14
001760  47070F     ADD W14, W15, W14
241:               	while (ByteCount < 50) //Don't accept more than the buffer size
001766  20031A     MOV #0x31, W10
001782  540F8A     SUB W8, W10, [W15]
001784  36FFF1     BRA LEU, .L63
242:               	{
243:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
001768  070603     RCALL UART_IsNewRxData
00176A  E00400     CP0.B W0
00176C  320006     BRA Z, .L60
244:               		{
245:               			NewByte = UART_ReadRxBuffer(); //Read the data byte for processing
00176E  070609     RCALL UART_ReadRxBuffer
246:               			*BufPtr++ = NewByte; //Add it to the buffer
001770  784F00     MOV.B W0, [W14]
001778  E8070E     INC W14, W14
247:               			ByteCount++;
001772  E80408     INC W8, W8
248:               			if (NewByte == '\n') //Check if got linefeed
001774  504FEA     SUB.B W0, #0xA, [W15]
001776  320007     BRA Z, .L61
249:               				break; //If linefeed then we have what we want
250:               		}
251:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001764  B3C029     MOV.B #0x2, W9
00177A  784009     MOV.B W9, W0
00177C  07068C     RCALL .LFE1, .LFB2, _TimerDone
00177E  E00400     CP0.B W0
001780  3A001E     BRA NZ, .L68
252:               			return false; //If timed out then return failure
0017BE  EB4000     CLR.B W0
0017C0  370003     BRA .L62
253:               	}
254:               
255:               	BufPtr = Buffer;
256:               	for (i = 0; i < ByteCount; i++) //Compare all bytes received
001788  E00008     CP0 W8
00178A  32001E     BRA Z, .L62
001794  EB0000     CLR W0
001796  370004     BRA .L64
0017B4  E80000     INC W0, W0
0017B6  540F80     SUB W8, W0, [W15]
0017B8  3EFFEF     BRA GTU, .L67
257:               	{
258:               		if (*data == '\0') //See if reached end of string with no bytes different
00178C  78409C     MOV.B [W12], W1
00178E  E00401     CP0.B W1
001790  32001B     BRA Z, .L62
001798  784091     MOV.B [W1], W1
00179A  E8060C     INC W12, W12
00179C  E00401     CP0.B W1
00179E  320011     BRA Z, .L71
259:               			return true; //No bytes were different so return success
0017C2  B3C010     MOV.B #0x1, W0
0017C4  370001     BRA .L62
260:               		else if (*data == Wildcard) //else see if expected response byte is a wildcard
0017A0  50CF8B     SUB.B W1, W11, [W15]
0017A2  3A0002     BRA NZ, .L65
0017A4  78008C     MOV W12, W1
0017A6  370006     BRA .L66
261:               		{
262:               			data++; //Increment past wildcard byte
263:               			BufPtr++; //Increment to ignore byte corresponding to wildcard
264:               		} else if (*data++ != *BufPtr++) //else see if the bytes are different
0017A8  2FFC23     MOV #0xFFC2, W3
0017AA  41818F     ADD W3, W15, W3
0017AC  784163     MOV.B [W3+W0], W2
0017AE  50CF82     SUB.B W1, W2, [W15]
0017B0  3A000A     BRA NZ, .L72
0017B2  78008C     MOV W12, W1
265:               			return false; //Bytes differ so return failure
0017C6  EB4000     CLR.B W0
266:               	}
267:               	return true; //All bytes matched or were ignored so return success
001786  B3C010     MOV.B #0x1, W0
0017BA  B3C010     MOV.B #0x1, W0
0017BC  370005     BRA .L62
268:               }
0017C8  78074F     MOV [--W15], W14
0017CA  78064F     MOV [--W15], W12
0017CC  BE054F     MOV.D [--W15], W10
0017CE  BE044F     MOV.D [--W15], W8
0017D0  B1034F     SUB #0x34, W15
0017D2  060000     RETURN
269:               
270:               uint16_t BT_CheckResponse_AOK(uint16_t * tally)
271:               {
0017D4  781F88     MOV W8, [W15++]
0017D6  780400     MOV W0, W8
272:               	if (!BT_CheckResponse(AOK))
0017D8  291B40     MOV #0x91B4, W0
0017DA  07FF79     RCALL BT_CheckResponse
0017DC  E00400     CP0.B W0
0017DE  3A0001     BRA NZ, .L75
273:               		*tally += 1;
0017E0  E80C18     INC [W8], [W8]
0017E2  780018     MOV [W8], W0
274:               
275:               	return *tally;
276:               }
0017E4  78044F     MOV [--W15], W8
0017E6  060000     RETURN
277:               
278:               /* update firmware via wireless app */
279:               bool BT_check_upd(void)
280:               {
0017E8  BE9F88     MOV.D W8, [W15++]
281:               	/* Jumper on DFU OTA UPDATE */
282:               	BT_OTA_UPD_TRIS = 1; // set for jumper input
0017EA  A862C8     BSET TRISB, #3
283:               	CNPU1bits.CN7PUE = 1; // pullup for RB3
0017EC  A8E06E     BSET CNPU1, #7
284:               	WaitMs(2); // jumper pullup read delay, rise time is slow
0017EE  200020     MOV #0x2, W0
0017F0  07065B     RCALL WaitMs
285:               	if (BT_OTA_UPD == 0) {
0017F2  AB62CA     BTST PORTB, #3
0017F4  3A0093     BRA NZ, .L77
286:               		BT_OTA_UPD_TRIS = 0; // set back to output
0017F6  A962C8     BCLR TRISB, #3
287:               		BT_WAKE_SW = 1;
0017F8  A862CD     BSET 0x2CD, #3
288:               		BT_WAKE_HW = 1;
0017FA  A842CD     BSET 0x2CD, #2
289:               		BT_CMD = 0;
0017FC  A902C4     BCLR LATA, #0
290:               
291:               		WaitMs(100);
0017FE  200640     MOV #0x64, W0
001800  070653     RCALL WaitMs
292:               		BT_SendCommand("SF,2\r", false); // perform complete factory reset
001802  EB4080     CLR.B W1
001804  291BA0     MOV #0x91BA, W0
001806  07FF08     RCALL BT_SendCommand
293:               		WaitMs(100);
001808  200640     MOV #0x64, W0
00180A  07064E     RCALL WaitMs
294:               		BT_CheckResponse(AOK);
00180C  291B40     MOV #0x91B4, W0
00180E  07FF5F     RCALL BT_CheckResponse
295:               
296:               		BT_SendCommand("SF,2\r", false); // perform complete factory reset again
001810  EB4080     CLR.B W1
001812  291BA0     MOV #0x91BA, W0
001814  07FF01     RCALL BT_SendCommand
297:               		WaitMs(100);
001816  200640     MOV #0x64, W0
001818  070647     RCALL WaitMs
298:               		if (!BT_CheckResponse(AOK)) {
00181A  291B40     MOV #0x91B4, W0
00181C  07FF58     RCALL BT_CheckResponse
00181E  784080     MOV.B W0, W1
001822  E00401     CP0.B W1
001824  320081     BRA Z, .L78
299:               			return false;
001820  EB4000     CLR.B W0
300:               		}
301:               
302:               		BT_SendCommand("SDH,4.1\r", false); // defaults
001826  784080     MOV.B W0, W1
001828  291C00     MOV #0x91C0, W0
00182A  07FEF6     RCALL BT_SendCommand
303:               		WaitMs(100);
00182C  200640     MOV #0x64, W0
00182E  07063C     RCALL WaitMs
304:               		if (!BT_CheckResponse(AOK)) {
001830  291B40     MOV #0x91B4, W0
001832  07FF4D     RCALL BT_CheckResponse
001834  784080     MOV.B W0, W1
001838  E00401     CP0.B W1
00183A  320076     BRA Z, .L78
305:               			return false;
001836  EB4000     CLR.B W0
306:               		}
307:               		BT_SendCommand("SDM,RN4020\r", false); // defaults
00183C  784080     MOV.B W0, W1
00183E  291C90     MOV #0x91C9, W0
001840  07FEEB     RCALL BT_SendCommand
308:               		WaitMs(100);
001842  200640     MOV #0x64, W0
001844  070631     RCALL WaitMs
309:               		if (!BT_CheckResponse(AOK)) {
001846  291B40     MOV #0x91B4, W0
001848  07FF42     RCALL BT_CheckResponse
00184A  784080     MOV.B W0, W1
00184E  E00401     CP0.B W1
001850  32006B     BRA Z, .L78
310:               			return false;
00184C  EB4000     CLR.B W0
311:               		}
312:               
313:               		BT_SendCommand("SDN,Microchip\r", false); // defaults
001852  784080     MOV.B W0, W1
001854  291D50     MOV #0x91D5, W0
001856  07FEE0     RCALL BT_SendCommand
314:               		WaitMs(100);
001858  200640     MOV #0x64, W0
00185A  070626     RCALL WaitMs
315:               		if (!BT_CheckResponse(AOK)) {
00185C  291B40     MOV #0x91B4, W0
00185E  07FF37     RCALL BT_CheckResponse
001860  784080     MOV.B W0, W1
001864  E00401     CP0.B W1
001866  320060     BRA Z, .L78
316:               			return false;
001862  EB4000     CLR.B W0
317:               		}
318:               
319:               		BT_SendCommand("SP,7\r", false); // defaults
001868  784080     MOV.B W0, W1
00186A  291E40     MOV #0x91E4, W0
00186C  07FED5     RCALL BT_SendCommand
320:               		WaitMs(100);
00186E  200640     MOV #0x64, W0
001870  07061B     RCALL WaitMs
321:               		if (!BT_CheckResponse(AOK)) {
001872  291B40     MOV #0x91B4, W0
001874  07FF2C     RCALL BT_CheckResponse
001876  784080     MOV.B W0, W1
00187A  E00401     CP0.B W1
00187C  320055     BRA Z, .L78
322:               			return false;
001878  EB4000     CLR.B W0
323:               		}
324:               
325:               		BT_SendCommand("SS,C0000000\r", false); // add service
00187E  784080     MOV.B W0, W1
001880  291EA0     MOV #0x91EA, W0
001882  07FECA     RCALL BT_SendCommand
326:               		WaitMs(100);
001884  200640     MOV #0x64, W0
001886  070610     RCALL WaitMs
327:               		if (!BT_CheckResponse(AOK)) {
001888  291B40     MOV #0x91B4, W0
00188A  07FF21     RCALL BT_CheckResponse
00188C  784080     MOV.B W0, W1
001890  E00401     CP0.B W1
001892  32004A     BRA Z, .L78
328:               			return false;
00188E  EB4000     CLR.B W0
329:               		}
330:               
331:               		BT_SendCommand("SR,32008000\r", false); // support MLDP, enable OTA (peripheral mode is enabled by default)
001894  784080     MOV.B W0, W1
001896  291F70     MOV #0x91F7, W0
001898  07FEBF     RCALL BT_SendCommand
332:               		WaitMs(100);
00189A  200640     MOV #0x64, W0
00189C  070605     RCALL WaitMs
333:               		if (!BT_CheckResponse(AOK)) {
00189E  291B40     MOV #0x91B4, W0
0018A0  07FF16     RCALL BT_CheckResponse
0018A2  784080     MOV.B W0, W1
0018A6  E00401     CP0.B W1
0018A8  32003F     BRA Z, .L78
334:               			return false;
0018A4  EB4000     CLR.B W0
335:               		}
336:               		BT_SendCommand("R,1\r", false); //Force reboot
0018AA  784080     MOV.B W0, W1
0018AC  292040     MOV #0x9204, W0
0018AE  07FEB4     RCALL BT_SendCommand
337:               
338:               		//Wait for WS status high
339:               		StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
0018B0  20FA01     MOV #0xFA0, W1
0018B2  B3C020     MOV.B #0x2, W0
0018B4  0705EA     RCALL .LFE0, .LFB1, _StartTimer
340:               		while (BT_WS == 0) {
0018B8  370004     BRA .L79
0018C2  AB42C2     BTST PORTA, #2
0018C4  32FFFA     BRA Z, .L80
341:               			if (TimerDone(TMR_RN_COMMS)) //Check if timed out
0018B6  B3C028     MOV.B #0x2, W8
0018BA  784008     MOV.B W8, W0
0018BC  0705EC     RCALL .LFE1, .LFB2, _TimerDone
0018BE  E00400     CP0.B W0
0018C0  3A0030     BRA NZ, .L94
342:               			{
343:               				return false;
001922  EB4000     CLR.B W0
001924  370001     BRA .L78
344:               			}
345:               		}
346:               
347:               		//Wait for end of "CMD\r\n" - we don't check for full "CMD\r\n" string because we may 
348:               		//miss some bits or bytes at the beginning while the UART starts up
349:               		StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
0018C6  20FA01     MOV #0xFA0, W1
0018C8  B3C020     MOV.B #0x2, W0
0018CA  0705DF     RCALL .LFE0, .LFB1, _StartTimer
350:               		while (UART_ReadRxBuffer() != '\n') {
0018CE  370004     BRA .L81
0018D8  070554     RCALL UART_ReadRxBuffer
0018DA  504FEA     SUB.B W0, #0xA, [W15]
0018DC  3AFFF9     BRA NZ, .L82
351:               			if (TimerDone(TMR_RN_COMMS)) //Check if timed out
0018CC  B3C028     MOV.B #0x2, W8
0018D0  784008     MOV.B W8, W0
0018D2  0705E1     RCALL .LFE1, .LFB2, _TimerDone
0018D4  E00400     CP0.B W0
0018D6  3A0027     BRA NZ, .L95
352:               			{
353:               				return false;
001926  EB4000     CLR.B W0
354:               			}
355:               		}
356:               
357:               		BT_SendCommand("I\r", false); // MLDP mode
0018DE  EB4080     CLR.B W1
0018E0  292090     MOV #0x9209, W0
0018E2  07FE9A     RCALL BT_SendCommand
358:               		BT_SendCommand("A\r", false); // start advertising
0018E4  EB4080     CLR.B W1
0018E6  2920C0     MOV #0x920C, W0
0018E8  07FE97     RCALL BT_SendCommand
359:               
360:               		/* wait loop controller for power cycle/reset after firmware update */
361:               		while (true) {
362:               			while (true) { // fast flash waiting for OTA
363:               				ClrWdt();
0018EE  FE6000     CLRWDT
364:               				while (UART_IsNewRxData()) { //While buffer contains old data
0018F0  370006     BRA .L98
0018FE  070538     RCALL UART_IsNewRxData
001900  E00400     CP0.B W0
001902  3AFFF7     BRA NZ, .L85
365:               					UART_ReadRxBuffer(); //Keep reading until empty
0018F2  070547     RCALL UART_ReadRxBuffer
366:               					if (!UART_IsNewRxData()) {
0018F4  07053D     RCALL UART_IsNewRxData
0018F6  E00400     CP0.B W0
0018F8  3A0002     BRA NZ, .L98
367:               						WaitMs(200);
0018EA  200C88     MOV #0xC8, W8
0018FA  780008     MOV W8, W0
0018FC  0705D5     RCALL WaitMs
368:               					}
369:               				}
370:               				WaitMs(110);
001904  2006E0     MOV #0x6E, W0
001906  0705D0     RCALL WaitMs
371:               				SLED = !SLED;
0018EC  240009     MOV #0x4000, W9
001908  801661     MOV LATB, W1
00190A  648001     AND W9, W1, W0
00190C  E90000     DEC W0, W0
00190E  DE004F     LSR W0, #15, W0
001910  DD004E     SL W0, #14, W0
001912  801661     MOV LATB, W1
001914  A1E001     BCLR W1, #14
001916  700081     IOR W0, W1, W1
001918  881661     MOV W1, LATB
372:               			}
00191A  37FFE9     BRA .L86
373:               
374:               		}
375:               
376:               	}
377:               	BT_OTA_UPD_TRIS = 0;
00191C  A962C8     BCLR TRISB, #3
378:               	return true;
00191E  B3C010     MOV.B #0x1, W0
001920  370003     BRA .L78
379:               }
001928  BE044F     MOV.D [--W15], W8
00192A  060000     RETURN
380:               
381:               #ifdef	BT_RN4020
382:               //**********************************************************************************************************************
383:               // Set up the RN4020 module
384:               
385:               bool BT_SetupModule_4020(void)
386:               {
387:               	uint16_t version_code;
388:               
389:               	/* check for over the air firmware updates */
390:               	BT_check_upd();
391:               
392:               	//Check RN4020 module's firmware version for version specific setups
393:               	version_code = BT_CheckFwVer();
394:               
395:               	BT_SendCommand("sf,2\r", false); // Factory reset
396:               	if (!BT_CheckResponse(AOK)) {
397:               		return false;
398:               	}
399:               
400:               	//Send "GR" to get feature settings
401:               	BT_SendCommand("gr\r", false); //Get RN4020 module feature settings
402:               	if (!BT_CheckResponse("26060000\r\n")) //Check if features are set for auto advertise and flow control, No Input, no output, no direct advertisement
403:               	{ //auto enable MLDP, suppress messages during MLDP
404:               		BT_SendCommand("sr,26060000\r", false); //Features not correct so set features
405:               		if (!BT_CheckResponse(AOK)) {
406:               			return false;
407:               		}
408:               	}
409:               
410:               	char macAddr[16];
411:               	BT_SendCommand("gds\r", false); // Get mac address
412:               	while (!BT_ReceivePacket(macAddr));
413:               
414:               	char message[12];
415:               	macAddr[12] = '\0';
416:               	sprintf(message, "sn,%s_BT\r", &macAddr[8]);
417:               
418:               	BT_SendCommand(message, false); //Set advertise name
419:               	if (!BT_CheckResponse(AOK)) {
420:               		return false;
421:               	}
422:               
423:               	BT_SendCommand("gs\r", false);
424:               	if (!BT_CheckResponse("F0000001\r\n")) {
425:               		//Send "SS" to set user defined private profiles and ID/Battery in 1.33 firmware
426:               		BT_SendCommand("ss,F0000001\r", false);
427:               		if (!BT_CheckResponse(AOK)) {
428:               			return false;
429:               		}
430:               	}
431:               
432:               	BT_SendCommand("s-,FRC-\r", false); // set serialized name  Bluetooth-friendly name
433:               	if (!BT_CheckResponse(AOK)) {
434:               		return false;
435:               	}
436:               
437:               	//  initial connection parameters 
438:               	BT_SendCommand("st,003c,0000,0064\r", false);
439:               	if (!BT_CheckResponse(AOK)) {
440:               		return false;
441:               	}
442:               
443:               	// Clear all settings of defined services and characteristics
444:               	BT_SendCommand("pz\r", false);
445:               	if (!BT_CheckResponse(AOK)) {
446:               		return false;
447:               	}
448:               
449:               	if (version_code >= 33) { // V1.33.4 public services
450:               		// Public BTLE services and characteristics
451:               
452:               		// heart rate service with standard 16-bit UUID
453:               		BT_SendCommand("ps,"PUBLIC_HR_UUID"\r", false);
454:               		if (!BT_CheckResponse(AOK)) {
455:               			return false;
456:               		}
457:               
458:               		// heart rate measurement characteristic
459:               		BT_SendCommand("pc,"PUBLIC_HR_CHAR_HRM",12,04\r", false); //Notify, Read
460:               		if (!BT_CheckResponse(AOK)) {
461:               			return false;
462:               		}
463:               
464:               		// heart body sensor location characteristic
465:               		BT_SendCommand("pc,"PUBLIC_HR_CHAR_BSL",06,01\r", false); //Write , Read
466:               		if (!BT_CheckResponse(AOK)) {
467:               			return false;
468:               		}
469:               
470:               		// heart rate control point characteristic
471:               		BT_SendCommand("pc,"PUBLIC_HR_CHAR_RCP",06,01\r", false); //Write , Read
472:               		if (!BT_CheckResponse(AOK)) {
473:               			return false;
474:               		}
475:               
476:               		//  Automation IO service with standard 16-bit UUID
477:               		BT_SendCommand("ps,"PUBLIC_AIO_UUID"\r", false);
478:               		if (!BT_CheckResponse(AOK)) {
479:               			return false;
480:               		}
481:               
482:               		// Automation IO digital characteristic
483:               		BT_SendCommand("pc,"PUBLIC_AIO_CHAR_DIG",16,08,33\r", false); //Notify, Write , Read
484:               		if (!BT_CheckResponse(AOK)) {
485:               			return false;
486:               		}
487:               
488:               		// Automation IO analog characteristic
489:               		BT_SendCommand("pc,"PUBLIC_AIO_CHAR_ANA",16,02,33\r", false); //Notify, Write , Read
490:               		if (!BT_CheckResponse(AOK)) {
491:               			return false;
492:               		}
493:               
494:               		// Automation IO agg characteristic
495:               		BT_SendCommand("pc,"PUBLIC_AIO_CHAR_AGG",12,0F,33\r", false); //Notify, Read
496:               		if (!BT_CheckResponse(AOK)) {
497:               			return false;
498:               		}
499:               	}
500:               
501:               	// set power to max
502:               	BT_SendCommand("sp,7\r", false);
503:               	if (!BT_CheckResponse(AOK)) {
504:               		return false;
505:               	}
506:               
507:               	// set software version
508:               	BT_SendCommand("sdr,"APP_VERSION_STR"\r", false);
509:               	if (!BT_CheckResponse(AOK)) {
510:               		return false;
511:               	}
512:               
513:               	// Private BTLE services and characteristics
514:               
515:               	//Send "ps" to set user defined service UUID
516:               	BT_SendCommand("ps,"PRIVATE_SERVICE",\r", false);
517:               	if (!BT_CheckResponse(AOK)) {
518:               		return false;
519:               	}
520:               
521:               	// Custom button characteristic with generated UUID
522:               	BT_SendCommand("pc,"PRIVATE_CHAR_SWITCHES",22,02\r", false); //Notify, Read
523:               	if (!BT_CheckResponse(AOK)) {
524:               		return false;
525:               	}
526:               
527:               	// Custom potentiometer characteristic with generated UUID
528:               	BT_SendCommand("pc,"PRIVATE_CHAR_POTENTIOMETER",22,02\r", false); //Notify, Read
529:               	if (!BT_CheckResponse(AOK)) {
530:               		return false;
531:               	}
532:               
533:               	// Custom LED characteristic with generated UUID
534:               	BT_SendCommand("pc,"PRIVATE_CHAR_LEDS",0A,04\r", false); //Write , Read
535:               	if (!BT_CheckResponse(AOK)) {
536:               		return false;
537:               	}
538:               
539:               	// Custom RELAY characteristic with generated UUID
540:               	BT_SendCommand("pc,"PRIVATE_CHAR_RELAYS",0A,04\r", false); //Write , Read
541:               	if (!BT_CheckResponse(AOK)) {
542:               		return false;
543:               	}
544:               
545:               	// Custom analog input characteristic with generated UUID //Write , Read
546:               	BT_SendCommand("pc,"PRIVATE_CHAR_ADC_CHAN",0A,04\r", false);
547:               	if (!BT_CheckResponse(AOK)) {
548:               		return false;
549:               	}
550:               
551:               	// Custom digital device characteristic with generated UUID //Write , Read
552:               	BT_SendCommand("pc,"PRIVATE_CHAR_PIC_SLAVE",0A,0F\r", false);
553:               	if (!BT_CheckResponse(AOK)) {
554:               		return false;
555:               	}
556:               
557:               	BT_SendCommand("wc\r", false); //Command to clear script, just in case there is a script
558:               	if (!BT_CheckResponse(AOK)) {
559:               		return false;
560:               	}
561:               
562:               	//Send "R,1" to save changes and reboot
563:               	return BT_RebootEnFlow(true);
564:               }
565:               #endif
566:               
567:               #ifdef	BT_RN4871
568:               //**********************************************************************************************************************
569:               // Set up the RN4871 module
570:               
571:               bool BT_SetupModule_4871(void)
572:               {
00193C  FA001E     LNK #0x1E
00193E  781F88     MOV W8, [W15++]
573:               	uint16_t version_code, failure = 0;
001940  78040E     MOV W14, W8
001942  EB1C00     CLR [W8++]
574:               
575:               	//Check RN4871 module's firmware version for version specific setups
576:               	//	version_code = BT_CheckFwVer();
577:               	version_code = 118; // hard-code for now
578:               
579:               	// Clear all settings of defined services and characteristics
580:               	BT_SendCommand("pz\r", false); // must reboot next to clear handles
001944  EB4080     CLR.B W1
001946  292130     MOV #0x9213, W0
001948  07FE67     RCALL BT_SendCommand
581:               	BT_SendCommand("SF,1\r", false); // Factory reset
00194A  EB4080     CLR.B W1
00194C  292170     MOV #0x9217, W0
00194E  07FE64     RCALL BT_SendCommand
582:               	WaitMs(500);
001950  201F40     MOV #0x1F4, W0
001952  0705AA     RCALL WaitMs
583:               
584:               	//Clear any UART error bits
585:               	U1STAbits.FERR = 0;
001954  A94222     BCLR U1STA, #2
586:               	U1STAbits.PERR = 0;
001956  A96222     BCLR U1STA, #3
587:               
588:               	// BTCMD("$");
589:               	BT_SendCommand("$", false);
001958  EB4080     CLR.B W1
00195A  2921D0     MOV #0x921D, W0
00195C  07FE5D     RCALL BT_SendCommand
590:               	WaitMs(100);
00195E  200640     MOV #0x64, W0
001960  0705A3     RCALL WaitMs
591:               	// BTCMD("$$$");
592:               	BT_SendCommand("$$$", false);
001962  EB4080     CLR.B W1
001964  2921F0     MOV #0x921F, W0
001966  07FE58     RCALL BT_SendCommand
593:               	WaitMs(100);
001968  200640     MOV #0x64, W0
00196A  07059E     RCALL WaitMs
594:               
595:               	// assign delimiters
596:               	BT_SendCommand("S%,%,#\r", false);
00196C  EB4080     CLR.B W1
00196E  292230     MOV #0x9223, W0
001970  07FE53     RCALL BT_SendCommand
597:               	WaitMs(100);
001972  200640     MOV #0x64, W0
001974  070599     RCALL WaitMs
598:               
599:               	BT_SendCommand("SR,4000\r", false); //Features not correct so set features
001976  EB4080     CLR.B W1
001978  2922B0     MOV #0x922B, W0
00197A  07FE4E     RCALL BT_SendCommand
600:               
601:               	// assign random mac address
602:               	BT_SendCommand("&R", false);
00197C  EB4080     CLR.B W1
00197E  292340     MOV #0x9234, W0
001980  07FE4B     RCALL BT_SendCommand
603:               	WaitMs(100);
001982  200640     MOV #0x64, W0
001984  070591     RCALL WaitMs
604:               
605:               	char macAddr[16];
606:               	BT_SendCommand("gds\r", false); // Get mac address
001986  EB4080     CLR.B W1
001988  292370     MOV #0x9237, W0
00198A  07FE46     RCALL BT_SendCommand
607:               	while (!BT_ReceivePacket(macAddr));
00198C  780008     MOV W8, W0
00198E  07FE06     RCALL BT_ReceivePacket
001990  E00400     CP0.B W0
001992  32FFFC     BRA Z, .L101
608:               
609:               	char message[12];
610:               	macAddr[12] = '\0';
001994  EB4000     CLR.B W0
001996  984F60     MOV.B W0, [W14+14]
611:               	sprintf(message, "sn,%s_BT\r", &macAddr[8]);
001998  471FEA     ADD W14, #0xA, [W15++]
00199A  2923C0     MOV #0x923C, W0
00199C  781F80     MOV W0, [W15++]
00199E  470072     ADD W14, #0x12, W0
0019A0  07F5D7     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
612:               	// cleanup serial message buffer
613:               	clear_bt_port();
0019A2  07FDEC     RCALL clear_bt_port
614:               
615:               	BT_SendCommand(message, false); //Set advertise name
0019A4  EB4080     CLR.B W1
0019A6  470072     ADD W14, #0x12, W0
0019A8  07FE37     RCALL BT_SendCommand
616:               	BT_CheckResponse_AOK(&failure);
0019AA  78000E     MOV W14, W0
0019AC  07FF13     RCALL BT_CheckResponse_AOK
617:               
618:               	//Send "SS" to set default services
619:               	BT_SendCommand("ss,80\r", false);
0019AE  EB4080     CLR.B W1
0019B0  292460     MOV #0x9246, W0
0019B2  07FE32     RCALL BT_SendCommand
620:               	BT_CheckResponse_AOK(&failure);
0019B4  78000E     MOV W14, W0
0019B6  07FF0E     RCALL BT_CheckResponse_AOK
621:               
622:               	//Send "SC" for advertisement settings
623:               	BT_SendCommand("sc,2\r", false);
0019B8  EB4080     CLR.B W1
0019BA  2924D0     MOV #0x924D, W0
0019BC  07FE2D     RCALL BT_SendCommand
624:               	BT_CheckResponse_AOK(&failure);
0019BE  78000E     MOV W14, W0
0019C0  07FF09     RCALL BT_CheckResponse_AOK
625:               
626:               	BT_SendCommand("s-,FRC-\r", false); // set serialized name  Bluetooth-friendly name
0019C2  EB4080     CLR.B W1
0019C4  292530     MOV #0x9253, W0
0019C6  07FE28     RCALL BT_SendCommand
627:               	BT_CheckResponse_AOK(&failure);
0019C8  78000E     MOV W14, W0
0019CA  07FF04     RCALL BT_CheckResponse_AOK
628:               
629:               	// set software version
630:               	BT_SendCommand("sdr,"APP_VERSION_STR"\r", false);
0019CC  EB4080     CLR.B W1
0019CE  2925C0     MOV #0x925C, W0
0019D0  07FE23     RCALL BT_SendCommand
631:               	BT_CheckResponse_AOK(&failure);
0019D2  78000E     MOV W14, W0
0019D4  07FEFF     RCALL BT_CheckResponse_AOK
632:               
633:               	// set firmware version
634:               	BT_SendCommand("sdf,"APP_VERSION_STR"\r", false);
0019D6  EB4080     CLR.B W1
0019D8  292650     MOV #0x9265, W0
0019DA  07FE1E     RCALL BT_SendCommand
635:               	BT_CheckResponse_AOK(&failure);
0019DC  78000E     MOV W14, W0
0019DE  07FEFA     RCALL BT_CheckResponse_AOK
636:               
637:               
638:               	// set appearance
639:               	BT_SendCommand("sda,0002\r", false);
0019E0  EB4080     CLR.B W1
0019E2  2926E0     MOV #0x926E, W0
0019E4  07FE19     RCALL BT_SendCommand
640:               	BT_CheckResponse_AOK(&failure);
0019E6  78000E     MOV W14, W0
0019E8  07FEF5     RCALL BT_CheckResponse_AOK
641:               
642:               	// set serial
643:               	BT_SendCommand("sds,1957\r", false);
0019EA  EB4080     CLR.B W1
0019EC  292780     MOV #0x9278, W0
0019EE  07FE14     RCALL BT_SendCommand
644:               	BT_CheckResponse_AOK(&failure);
0019F0  78000E     MOV W14, W0
0019F2  07FEF0     RCALL BT_CheckResponse_AOK
645:               
646:               	//  initial connection parameters 
647:               	BT_SendCommand("st,000C,0032,0000,0064\r", false);
0019F4  EB4080     CLR.B W1
0019F6  292820     MOV #0x9282, W0
0019F8  07FE0F     RCALL BT_SendCommand
648:               	BT_CheckResponse_AOK(&failure);
0019FA  78000E     MOV W14, W0
0019FC  07FEEB     RCALL BT_CheckResponse_AOK
649:               
650:               	// Public BTLE services and characteristics
651:               	// battery level service with standard 16-bit UUID
652:               	BT_SendCommand("ps,"PUBLIC_BATT_UUID"\r", false);
0019FE  EB4080     CLR.B W1
001A00  2929A0     MOV #0x929A, W0
001A02  07FE0A     RCALL BT_SendCommand
653:               	BT_CheckResponse_AOK(&failure);
001A04  78000E     MOV W14, W0
001A06  07FEE6     RCALL BT_CheckResponse_AOK
654:               
655:               	// battery level measurement characteristic
656:               	BT_SendCommand("pc,"PUBLIC_BATT_CHAR_BL",12,04\r", false); //Notify, Read
001A08  EB4080     CLR.B W1
001A0A  292A30     MOV #0x92A3, W0
001A0C  07FE05     RCALL BT_SendCommand
657:               	BT_CheckResponse_AOK(&failure);
001A0E  78000E     MOV W14, W0
001A10  07FEE1     RCALL BT_CheckResponse_AOK
658:               
659:               	// heart rate service with standard 16-bit UUID
660:               	BT_SendCommand("ps,"PUBLIC_HR_UUID"\r", false);
001A12  EB4080     CLR.B W1
001A14  292B20     MOV #0x92B2, W0
001A16  07FE00     RCALL BT_SendCommand
661:               	BT_CheckResponse_AOK(&failure);
001A18  78000E     MOV W14, W0
001A1A  07FEDC     RCALL BT_CheckResponse_AOK
662:               
663:               	// heart rate measurement characteristic
664:               	BT_SendCommand("pc,"PUBLIC_HR_CHAR_HRM",12,04\r", false); //Notify, Read
001A1C  EB4080     CLR.B W1
001A1E  292BB0     MOV #0x92BB, W0
001A20  07FDFB     RCALL BT_SendCommand
665:               	BT_CheckResponse_AOK(&failure);
001A22  78000E     MOV W14, W0
001A24  07FED7     RCALL BT_CheckResponse_AOK
666:               
667:               	// heart body sensor location characteristic
668:               	BT_SendCommand("pc,"PUBLIC_HR_CHAR_BSL",06,01\r", false); //Write , Read
001A26  EB4080     CLR.B W1
001A28  292CA0     MOV #0x92CA, W0
001A2A  07FDF6     RCALL BT_SendCommand
669:               	BT_CheckResponse_AOK(&failure);
001A2C  78000E     MOV W14, W0
001A2E  07FED2     RCALL BT_CheckResponse_AOK
670:               
671:               	// heart rate control point characteristic
672:               	BT_SendCommand("pc,"PUBLIC_HR_CHAR_RCP",06,01\r", false); //Write , Read
001A30  EB4080     CLR.B W1
001A32  292D90     MOV #0x92D9, W0
001A34  07FDF1     RCALL BT_SendCommand
673:               	BT_CheckResponse_AOK(&failure);
001A36  78000E     MOV W14, W0
001A38  07FECD     RCALL BT_CheckResponse_AOK
674:               
675:               	//  Automation IO service with standard 16-bit UUID
676:               	BT_SendCommand("ps,"PUBLIC_AIO_UUID"\r", false);
001A3A  EB4080     CLR.B W1
001A3C  292E80     MOV #0x92E8, W0
001A3E  07FDEC     RCALL BT_SendCommand
677:               	BT_CheckResponse_AOK(&failure);
001A40  78000E     MOV W14, W0
001A42  07FEC8     RCALL BT_CheckResponse_AOK
678:               
679:               	// Automation IO digital characteristic
680:               	BT_SendCommand("pc,"PUBLIC_AIO_CHAR_DIG",16,08,33\r", false); //Notify, Write , Read
001A44  EB4080     CLR.B W1
001A46  292F10     MOV #0x92F1, W0
001A48  07FDE7     RCALL BT_SendCommand
681:               	BT_CheckResponse_AOK(&failure);
001A4A  78000E     MOV W14, W0
001A4C  07FEC3     RCALL BT_CheckResponse_AOK
682:               
683:               	// Automation IO analog characteristic
684:               	BT_SendCommand("pc,"PUBLIC_AIO_CHAR_ANA",16,02,33\r", false); //Notify, Write , Read
001A4E  EB4080     CLR.B W1
001A50  293030     MOV #0x9303, W0
001A52  07FDE2     RCALL BT_SendCommand
685:               	BT_CheckResponse_AOK(&failure);
001A54  78000E     MOV W14, W0
001A56  07FEBE     RCALL BT_CheckResponse_AOK
686:               
687:               	// Automation IO agg characteristic
688:               	BT_SendCommand("pc,"PUBLIC_AIO_CHAR_AGG",12,0F,33\r", false); //Notify, Read
001A58  EB4080     CLR.B W1
001A5A  293150     MOV #0x9315, W0
001A5C  07FDDD     RCALL BT_SendCommand
689:               	BT_CheckResponse_AOK(&failure);
001A5E  78000E     MOV W14, W0
001A60  07FEB9     RCALL BT_CheckResponse_AOK
690:               
691:               	// Private BTLE services and characteristics
692:               	//Send "ps" to set user defined service UUID
693:               	BT_SendCommand("ps,"PRIVATE_SERVICE",\r", false);
001A62  EB4080     CLR.B W1
001A64  293270     MOV #0x9327, W0
001A66  07FDD8     RCALL BT_SendCommand
694:               	BT_CheckResponse_AOK(&failure);
001A68  78000E     MOV W14, W0
001A6A  07FEB4     RCALL BT_CheckResponse_AOK
695:               
696:               	// Custom button characteristic with generated UUID
697:               	BT_SendCommand("pc,"PRIVATE_CHAR_SWITCHES",22,02\r", false); //Notify, Read
001A6C  EB4080     CLR.B W1
001A6E  2934D0     MOV #0x934D, W0
001A70  07FDD3     RCALL BT_SendCommand
698:               	BT_CheckResponse_AOK(&failure);
001A72  78000E     MOV W14, W0
001A74  07FEAF     RCALL BT_CheckResponse_AOK
699:               
700:               	// Custom potentiometer characteristic with generated UUID
701:               	BT_SendCommand("pc,"PRIVATE_CHAR_POTENTIOMETER",22,02\r", false); //Notify, Read
001A76  EB4080     CLR.B W1
001A78  293780     MOV #0x9378, W0
001A7A  07FDCE     RCALL BT_SendCommand
702:               	BT_CheckResponse_AOK(&failure);
001A7C  78000E     MOV W14, W0
001A7E  07FEAA     RCALL BT_CheckResponse_AOK
703:               
704:               	// Custom LED characteristic with generated UUID
705:               	BT_SendCommand("pc,"PRIVATE_CHAR_LEDS",0A,04\r", false); //Write , Read
001A80  EB4080     CLR.B W1
001A82  293A30     MOV #0x93A3, W0
001A84  07FDC9     RCALL BT_SendCommand
706:               	BT_CheckResponse_AOK(&failure);
001A86  78000E     MOV W14, W0
001A88  07FEA5     RCALL BT_CheckResponse_AOK
707:               
708:               	// Custom RELAY characteristic with generated UUID
709:               	BT_SendCommand("pc,"PRIVATE_CHAR_RELAYS",0A,04\r", false); //Write , Read
001A8A  EB4080     CLR.B W1
001A8C  293CE0     MOV #0x93CE, W0
001A8E  07FDC4     RCALL BT_SendCommand
710:               	BT_CheckResponse_AOK(&failure);
001A90  78000E     MOV W14, W0
001A92  07FEA0     RCALL BT_CheckResponse_AOK
711:               
712:               	// Custom analog input characteristic with generated UUID //Write , Read
713:               	BT_SendCommand("pc,"PRIVATE_CHAR_ADC_CHAN",0A,04\r", false);
001A94  EB4080     CLR.B W1
001A96  293F90     MOV #0x93F9, W0
001A98  07FDBF     RCALL BT_SendCommand
714:               	BT_CheckResponse_AOK(&failure);
001A9A  78000E     MOV W14, W0
001A9C  07FE9B     RCALL BT_CheckResponse_AOK
715:               
716:               	// Custom digital device characteristic with generated UUID //Write , Read
717:               	BT_SendCommand("pc,"PRIVATE_CHAR_PIC_SLAVE",0A,0F\r", false);
001A9E  EB4080     CLR.B W1
001AA0  294240     MOV #0x9424, W0
001AA2  07FDBA     RCALL BT_SendCommand
718:               	BT_CheckResponse_AOK(&failure);
001AA4  78000E     MOV W14, W0
001AA6  07FE96     RCALL BT_CheckResponse_AOK
719:               
720:               	BT_SendCommand("wc\r", false); //Command to clear script, just in case there is a script
001AA8  EB4080     CLR.B W1
001AAA  2944F0     MOV #0x944F, W0
001AAC  07FDB5     RCALL BT_SendCommand
721:               	BT_CheckResponse_AOK(&failure);
001AAE  78000E     MOV W14, W0
001AB0  07FE91     RCALL BT_CheckResponse_AOK
722:               
723:               	// setup advertisement data packet
724:               	BT_SendCommand("IA,Z\r", false); // clear AD data
001AB2  EB4080     CLR.B W1
001AB4  294530     MOV #0x9453, W0
001AB6  07FDB0     RCALL BT_SendCommand
725:               	BT_CheckResponse_AOK(&failure);
001AB8  78000E     MOV W14, W0
001ABA  07FE8C     RCALL BT_CheckResponse_AOK
726:               	BT_SendCommand("IA,01,06\r", false); // set connection flags
001ABC  EB4080     CLR.B W1
001ABE  294590     MOV #0x9459, W0
001AC0  07FDAB     RCALL BT_SendCommand
727:               	BT_CheckResponse_AOK(&failure);
001AC2  78000E     MOV W14, W0
001AC4  07FE87     RCALL BT_CheckResponse_AOK
728:               	BT_SendCommand("IA,09,424C45434D32\r", false); // AD name
001AC6  EB4080     CLR.B W1
001AC8  294630     MOV #0x9463, W0
001ACA  07FDA6     RCALL BT_SendCommand
729:               	BT_CheckResponse_AOK(&failure);
001ACC  78000E     MOV W14, W0
001ACE  07FE82     RCALL BT_CheckResponse_AOK
730:               	// set 128-bit UUID in swapped format for client BLECM2 filter
731:               	BT_SendCommand("IA,07,9DEC6AD92C00E086304155EC91872328\r", false);
001AD0  EB4080     CLR.B W1
001AD2  294770     MOV #0x9477, W0
001AD4  07FDA1     RCALL BT_SendCommand
732:               	BT_CheckResponse_AOK(&failure);
001AD6  78000E     MOV W14, W0
001AD8  07FE7D     RCALL BT_CheckResponse_AOK
733:               	BT_SendCommand("A\r", false); // start advertisement
001ADA  EB4080     CLR.B W1
001ADC  2920C0     MOV #0x920C, W0
001ADE  07FD9C     RCALL BT_SendCommand
734:               	BT_CheckResponse_AOK(&failure);
001AE0  78000E     MOV W14, W0
001AE2  07FE78     RCALL BT_CheckResponse_AOK
735:               
736:               	if (failure)
001AE4  5787E4     SUB W15, #0x4, W15
001AE8  E0001E     CP0 [W14]
001AEA  3A0001     BRA NZ, .L102
737:               		return false;
001AE6  EB4000     CLR.B W0
738:               
739:               	//Send "R,1" to save changes and reboot (if needed))
740:               	return BT_RebootEnFlow(false);
001AEC  07FF1F     RCALL BT_RebootEnFlow
741:               }
001AEE  78044F     MOV [--W15], W8
001AF0  FA8000     ULNK
001AF2  060000     RETURN
742:               #endif
743:               
744:               //**********************************************************************************************************************
745:               // Reboot the module and enable flow control on PIC UART
746:               
747:               bool BT_RebootEnFlow(bool do_flow)
748:               {
749:               	bool do_ls = false, good_boot; // causes a mpu serial control lockup if enabled
750:               
751:               #ifdef BT_RN4871
752:               	BT_SendCommand("GN\r", false);
00192C  EB4080     CLR.B W1
00192E  2920F0     MOV #0x920F, W0
001930  07FE73     RCALL BT_SendCommand
753:               	clear_bt_port();
001932  07FE24     RCALL clear_bt_port
754:               	if (do_ls) {
755:               		BT_SendCommand("LS\r", false); // list services
756:               		WaitMs(4000);
757:               	}
758:               	good_boot = true;
759:               #endif
760:               
761:               #ifdef BT_RN4020
762:               	if (do_ls)
763:               		BT_SendCommand("LS\r", false); // list services
764:               
765:               	//Send "R,1" to save changes and reboot
766:               	BT_SendCommand("r,1\r", false); //Force reboot
767:               	if (!BT_CheckResponse("Reboot\r\n")) {
768:               		return false;
769:               	}
770:               	//Disable UART while TX line from RN is low during reset and bootup
771:               	StartTimer(TMR_RN_COMMS, 1000);
772:               	U1MODE &= 0x7FFF;
773:               	while (U1RX_PORT) {
774:               		if (TimerDone(TMR_RN_COMMS)) {
775:               			break;
776:               		}
777:               	}
778:               	StartTimer(TMR_RN_COMMS, 4000);
779:               	while (!U1RX_PORT) {
780:               		if (TimerDone(TMR_RN_COMMS)) {
781:               			break;
782:               		}
783:               	}
784:               
785:               	UART_RX_IF = 0; //Clear UART Receive interrupt flag
786:               	U1MODE |= 0x8200; //Enable UART, use RTC/CTS flow control
787:               	U1STA |= 0x0400; //Enable transmit
788:               
789:               	//Clear out NULL char(s) and other garbage if present after reboot, wait for first char of CMD\r\n response
790:               	StartTimer(TMR_RN_COMMS, 4000);
791:               	while (UART_ReadRxBuffer() != 'C') {
792:               		while (!UART_IsNewRxData()) {
793:               			if (TimerDone(TMR_RN_COMMS)) { //Check if timed out
794:               				return false; //If timed out then return failure
795:               			}
796:               		}
797:               	}
798:               
799:               	good_boot = BT_CheckResponse("MD\r\n"); //Check that we received CMD indicating reboot is done
800:               
801:               
802:               #endif
803:               	//Clear any UART error bits
804:               	U1STAbits.FERR = 0;
001934  A94222     BCLR U1STA, #2
805:               	U1STAbits.PERR = 0;
001936  A96222     BCLR U1STA, #3
806:               	return good_boot; //Check that we received CMD indicating reboot is done	
807:               }
001938  B3C010     MOV.B #0x1, W0
00193A  060000     RETURN
808:               
809:               #ifdef VERIFY_RN_FW_VER
810:               //Retrieve firmware version on module and check against the required version
811:               //Returns true if version is correct; false if not or communication failure
812:               
813:               uint16_t BT_CheckFwVer(void)
814:               {
001AF4  FA007E     LNK #0x7E
001AF6  781F88     MOV W8, [W15++]
815:               	char fpVer[20];
816:               	char *pfpVer = fpVer;
817:               	char strVer[100];
818:               	char *pstrVer = strVer;
001B46  4700F4     ADD W14, #0x14, W1
001B48  370001     BRA .L111
001B4A  4700F4     ADD W14, #0x14, W1
819:               	uint16_t verMajor,
820:               		verMinor,
821:               		verPatch;
822:               
823:               	//flush UART RX buffer just in case there's old data
824:               	while (UART_IsNewRxData()) { //While buffer contains old data
001AFA  370003     BRA .L106
001B02  070436     RCALL UART_IsNewRxData
001B04  E00400     CP0.B W0
001B06  3AFFFA     BRA NZ, .L107
825:               		UART_ReadRxBuffer(); //Keep reading until empty
001AFC  070442     RCALL UART_ReadRxBuffer
826:               		WaitMs(100);
001AF8  200648     MOV #0x64, W8
001AFE  780008     MOV W8, W0
001B00  0704D3     RCALL WaitMs
827:               	}
828:               
829:               	StartTimer(TMR_RN_COMMS, 2000);
001B08  207D01     MOV #0x7D0, W1
001B0A  B3C020     MOV.B #0x2, W0
001B0C  0704BE     RCALL .LFE0, .LFB1, _StartTimer
830:               	BT_SendCommand("v\r", false); // Get firmware version
001B0E  EB4080     CLR.B W1
001B10  2949F0     MOV #0x949F, W0
001B12  07FD82     RCALL BT_SendCommand
831:               	while (!BT_ReceivePacket(strVer)) {
001B16  370004     BRA .L108
001B20  470074     ADD W14, #0x14, W0
001B22  07FD3C     RCALL BT_ReceivePacket
001B24  E00400     CP0.B W0
001B26  32FFF8     BRA Z, .L110
832:               		if (TimerDone(TMR_RN_COMMS)) {
001B14  B3C028     MOV.B #0x2, W8
001B18  784008     MOV.B W8, W0
001B1A  0704BD     RCALL .LFE1, .LFB2, _TimerDone
001B1C  E00400     CP0.B W0
001B1E  3A0040     BRA NZ, .L117
833:               			return false;
001BA0  EB0000     CLR W0
001BA2  370001     BRA .L109
834:               		}
835:               	}
836:               
837:               	//Skip to first digit
838:               	while ((*pstrVer < '0' || *pstrVer > '9') && *pstrVer != NULL) {
001B28  90504E     MOV.B [W14+20], W0
001B2A  B3CD01     MOV.B #0xD0, W1
001B2C  404081     ADD.B W0, W1, W1
001B2E  50CFE9     SUB.B W1, #0x9, [W15]
001B30  36000A     BRA LEU, .L118
001B32  E00400     CP0.B W0
001B34  32000A     BRA Z, .L119
001B36  470075     ADD W14, #0x15, W0
001B38  B3CD04     MOV.B #0xD0, W4
001B3A  780080     MOV W0, W1
001B3C  784130     MOV.B [W0++], W2
001B3E  414184     ADD.B W2, W4, W3
001B40  51CFE9     SUB.B W3, #0x9, [W15]
001B42  3E0008     BRA GTU, .L112
001B44  370003     BRA .L111
001B4C  78028E     MOV W14, W5
001B54  E00402     CP0.B W2
001B56  3AFFF1     BRA NZ, .L114
001B58  37FFF9     BRA .L111
839:               		pstrVer++;
840:               	}
841:               	//Extract version number
842:               	while ((*pstrVer >= '0' && *pstrVer <= '9') || *pstrVer == '.') {
001B4E  B3CD03     MOV.B #0xD0, W3
001B50  B3C2E4     MOV.B #0x2E, W4
001B52  370004     BRA .L113
001B5C  784031     MOV.B [W1++], W0
001B5E  404103     ADD.B W0, W3, W2
001B60  514FE9     SUB.B W2, #0x9, [W15]
001B62  36FFFB     BRA LEU, .L115
001B64  504F84     SUB.B W0, W4, [W15]
001B66  32FFF9     BRA Z, .L115
843:               		*pfpVer = *pstrVer;
001B5A  785A80     MOV.B W0, [W5++]
844:               		pfpVer++;
845:               		pstrVer++;
846:               	}
847:               	*pfpVer = '\0';
001B68  EB4A80     CLR.B [W5]
848:               
849:               	//Tokenize and convert to unsigned
850:               	sscanf(fpVer, "%u.%u.%u", &verMajor, &verMinor, &verPatch);
001B6A  2007C0     MOV #0x7C, W0
001B6C  471F80     ADD W14, W0, [W15++]
001B6E  2007A1     MOV #0x7A, W1
001B70  471F81     ADD W14, W1, [W15++]
001B72  500064     SUB W0, #0x4, W0
001B74  471F80     ADD W14, W0, [W15++]
001B76  294A20     MOV #0x94A2, W0
001B78  781F80     MOV W0, [W15++]
001B7A  78000E     MOV W14, W0
001B7C  07F534     RCALL __sscanf_cdnopuxX
851:               
852:               	//Verify version number
853:               	if ((verMajor != RN_FW_VER_MAJOR133) && (verMajor != RN_FW_VER_MAJOR)) {
001B7E  5787E8     SUB W15, #0x8, W15
001B82  9038CE     MOV [W14+120], W1
001B84  508FE1     SUB W1, #0x1, [W15]
001B86  3A000F     BRA NZ, .L109
854:               		return false;
001B80  EB0000     CLR W0
855:               	}
856:               	if ((verMinor != RN_FW_VER_MINOR133) && (verMinor != RN_FW_VER_MINOR)) {
001B88  90385E     MOV [W14+122], W0
001B8A  200211     MOV #0x21, W1
001B8C  500F81     SUB W0, W1, [W15]
001B8E  320002     BRA Z, .L116
001B90  500FF7     SUB W0, #0x17, [W15]
001B92  3A0008     BRA NZ, .L121
857:               		return false;
001BA4  EB0000     CLR W0
858:               	}
859:               	if ((verPatch != RN_FW_VER_PATCH133) && (verPatch != RN_FW_VER_PATCH)) {
001B94  9038EE     MOV [W14+124], W1
001B96  5080E4     SUB W1, #0x4, W1
001B98  508FE1     SUB W1, #0x1, [W15]
001B9A  360005     BRA LEU, .L109
860:               		return false;
001B9C  EB0000     CLR W0
001B9E  370003     BRA .L109
861:               	}
862:               
863:               	return verMinor;
864:               }
001BA6  78044F     MOV [--W15], W8
001BA8  FA8000     ULNK
001BAA  060000     RETURN
865:               #endif //VERIFY_RN_FW_VER
---  /root/MPLABXProjects/fac_relay_clone/automio.c  ----------------------------------------------------
1:                 #include "automio.h"
2:                 
3:                 static void gpio_set(struct ble_automation_io *aio, uint8_t value)
4:                 {
5:                 	uint32_t pin = aio->gpio.pin_number;
6:                 
7:                 	if (value) {
8:                 		//		nrf_gpio_pin_set(pin);
9:                 	} else {
10:                		//		nrf_gpio_pin_clear(pin);
11:                	}
12:                }
13:                
14:                static uint8_t gpio_get(struct ble_automation_io *aio)
15:                {
16:                	uint8_t val;
17:                	if (aio->gpio.output) {
18:                		val = BLE_DIGITAL_OUTPUT_STATE;
19:                	} else {
20:                		//		val = nrf_gpio_pin_read(aio->gpio.pin_number);
21:                	}
22:                
23:                	return val;
24:                }
0024B8  B3C030     MOV.B #0x3, W0
0024BA  060000     RETURN
25:                
26:                void ble_automation_io_refresh(struct ble_automation_io *aio)
27:                {
0024BC  781F88     MOV W8, [W15++]
0024BE  780400     MOV W0, W8
28:                	uint8_t value = gpio_get(aio);
0024C0  780008     MOV W8, W0
0024C2  07FFFA     RCALL .Letext0, .LFE3, _gpio_get, .Ltext0, .LFB1
29:                	if (value != aio->value_digital) {
30:                		// TODO: notify clients
31:                	}
32:                	aio->value_digital = value;
0024C4  784C00     MOV.B W0, [W8]
33:                }
0024C6  78044F     MOV [--W15], W8
0024C8  060000     RETURN
34:                
35:                static void init_gpio(struct ble_automation_io *aio)
36:                {
37:                	uint32_t pin = aio->gpio.pin_number;
38:                	bool output = aio->gpio.output;
39:                
40:                	if (output) {
41:                		//		nrf_gpio_cfg_output(pin);
42:                		gpio_set(aio, (int) aio->gpio.default_value);
43:                		ble_automation_io_refresh(aio);
44:                	} else {
45:                		//		nrf_gpio_cfg_input(pin, NRF_GPIO_PIN_NOPULL);
46:                	}
47:                }
---  /root/MPLABXProjects/fac_relay_clone/app.c  --------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        app.c
29:                 * Date:        July 24, 2014
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 */
33:                
34:                // *****************************************************************************
35:                // *****************************************************************************
36:                // Section: Included Files
37:                // *****************************************************************************
38:                // *****************************************************************************
39:                
40:                #include <xc.h>
41:                #include <stdint.h>
42:                #include <stdbool.h>
43:                #include <stdio.h>
44:                #include <string.h>
45:                #include "app.h"
46:                #include "config.h"
47:                #include "timers.h"
48:                #include "uart.h"
49:                #include "bluetooth.h"
50:                #include "adc.h"
51:                #include "leds.h"
52:                #include "switches.h"
53:                #include "rtcc.h"
54:                #include "sleep.h"
55:                #include "spi.h"
56:                #include "link.h"
57:                #include "automio.h"
58:                
59:                APP_DATA appData;
60:                ADC_DATA adcData;
61:                AIO_DATA aioData;
62:                
63:                //Primary application state machine
64:                
65:                void APP_Tasks(void)
66:                {
67:                	static uint16_t failure = 0;
68:                #ifdef USE_SLEEP                //see config.h, Application setting section
69:                	APP_STATE_T savedState;
70:                	int16_t potDiff;
71:                
72:                	//Has inactivity timer expired?
73:                	if (appData.sleepFlag) {
74:                		savedState = appData.state; //Save context
75:                		appData.state = APP_SLEEP; //Enter sleep state
76:                	}
77:                #endif
78:                
79:                	//Update LED outputs
80:                	LED_Tasks();
001C2E  070121     RCALL LED_Tasks
81:                
82:                	switch (appData.state) {
001C30  805060     MOV appData, W0
001C32  500FE1     SUB W0, #0x1, [W15]
001C34  32000F     BRA Z, .L7
001C36  390005     BRA NC, .L6
001C38  500FE2     SUB W0, #0x2, [W15]
001C3A  32000F     BRA Z, .L8
001C3C  500FE3     SUB W0, #0x3, [W15]
001C3E  3A0118     BRA NZ, .L4
001C40  370024     BRA .L29
83:                		//Initial state
84:                	case APP_INITIALIZE:
85:                		if (APP_Initialize()) {
001C42  07FFB4     RCALL APP_Initialize
001C44  E00400     CP0.B W0
001C46  320003     BRA Z, .L10
86:                			appData.state = APP_BLUETOOTH_ADVERTISE;
001C48  200020     MOV #0x2, W0
001C4A  885060     MOV W0, appData
001C4C  370111     BRA .L4
87:                		} else {
88:                			appData.state = APP_INITIALIZATION_ERROR;
001C4E  200010     MOV #0x1, W0
001C50  885060     MOV W0, appData
001C52  37010E     BRA .L4
89:                		}
90:                		break;
91:                
92:                		//Initialization failed
93:                	case APP_INITIALIZATION_ERROR:
94:                		LED_SET_LightShow(LED_ERROR);
001C54  200030     MOV #0x3, W0
001C56  070163     RCALL LED_SET_LightShow
95:                		break;
001C58  37010B     BRA .L4
96:                
97:                		//We're not connected to a device - advertise mode
98:                	case APP_BLUETOOTH_ADVERTISE:
99:                		LED_SET_LightShow(LED_BTLE_ADVERTISING);
001C5A  200010     MOV #0x1, W0
001C5C  070160     RCALL LED_SET_LightShow
100:               
101:               #ifdef	BT_RN4871
102:               		appData.rn_4871_packets = true;
001C5E  B3C010     MOV.B #0x1, W0
001C60  B7EB9D     MOV.B WREG, 0xB9D
103:               		appData.got_packet = BT_ReceivePacket(appData.receive_packet); // check for RN4871 connect packet
001C62  20A0E0     MOV #0xA0E, W0
001C64  07FC9B     RCALL BT_ReceivePacket
001C66  B7EB8E     MOV.B WREG, 0xB8E
104:               		if (appData.got_packet == true) { //true if new packet received
001C68  E00400     CP0.B W0
001C6A  320008     BRA Z, .L11
105:               			// rn4871 connection status packets
106:               			if (strstr(appData.receive_packet, "CONNECT,")) {
001C6C  294B21     MOV #0x94B2, W1
001C6E  20A0E0     MOV #0xA0E, W0
001C70  07F485     RCALL _strstr
001C72  E00000     CP0 W0
001C74  320002     BRA Z, .L12
107:               				appData.rn4871_connected = true;
001C76  B3C010     MOV.B #0x1, W0
001C78  B7EB9C     MOV.B WREG, 0xB9C
108:               			}
109:               			appData.got_packet = false;
001C7A  EF6B8E     CLR.B 0xB8E
110:               		}
111:               #endif
112:               
113:               		if (BT_CONNECTED || appData.rn4871_connected) {
001C7C  AB22C2     BTST PORTA, #1
001C7E  3A0002     BRA NZ, .L13
001C80  E24B9C     CP0.B 0xB9C
001C82  3200F6     BRA Z, .L4
114:               			appData.state = APP_BLUETOOTH_PAIRED;
001C84  200030     MOV #0x3, W0
001C86  885060     MOV W0, appData
001C88  3700F3     BRA .L4
115:               		}
116:               		break;
117:               
118:               		//We are connected to a BTLE device
119:               	case APP_BLUETOOTH_PAIRED:
120:               		//Update LEDs
121:               		LED_SET_LightShow(LED_BTLE_PAIRED);
001C8A  200020     MOV #0x2, W0
001C8C  070148     RCALL LED_SET_LightShow
122:               		//Check to see if we are still connected; return to advertise state if not
123:               		if (!BT_CONNECTED && !appData.rn4871_connected) {
001C8E  AB22C2     BTST PORTA, #1
001C90  3A0008     BRA NZ, .L14
001C92  E24B9C     CP0.B 0xB9C
001C94  3A0006     BRA NZ, .L14
124:               			appData.update_packet = false;
001C96  EF6B8F     CLR.B 0xB8F
125:               			LED_SET_LightShow(LED_BTLE_ADVERTISING);
001C98  200010     MOV #0x1, W0
001C9A  070141     RCALL LED_SET_LightShow
126:               			appData.state = APP_BLUETOOTH_ADVERTISE;
001C9C  200020     MOV #0x2, W0
001C9E  885060     MOV W0, appData
127:               			break;
001CA0  3700E7     BRA .L4
128:               		}
129:               
130:               		//Check if switches have changed and debounce timers are expired
131:               		Switch_Tasks();
001CA2  0703C6     RCALL Switch_Tasks
132:               		if (appData.sendSwitches) { //New switch status to send?
001CA4  E24B90     CP0.B .L65
001CA6  32001C     BRA Z, .L15
133:               			//Form message
134:               			sprintf(appData.transmit_packet, "shw,"PRIVATE_CHAR_SWITCHES_H",%d%d%d%d\r", appData.sw1, appData.sw2, appData.sw3, appData.sw4);
001CA8  20BA23     MOV #0xBA2, W3
001CAA  784193     MOV.B [W3], W3
001CAC  20BA12     MOV #0xBA1, W2
001CAE  784112     MOV.B [W2], W2
001CB0  20BA01     MOV #0xBA0, W1
001CB2  784091     MOV.B [W1], W1
001CB4  BFCB9F     MOV.B 0xB9F, WREG
001CB6  FB8183     ZE W3, W3
001CB8  781F83     MOV W3, [W15++]
001CBA  FB8102     ZE W2, W2
001CBC  781F82     MOV W2, [W15++]
001CBE  FB8081     ZE W1, W1
001CC0  781F81     MOV W1, [W15++]
001CC2  FB8000     ZE W0, W0
001CC4  781F80     MOV W0, [W15++]
001CC6  294BB0     MOV #0x94BB, W0
001CC8  781F80     MOV W0, [W15++]
001CCA  20B0E0     MOV #0xB0E, W0
001CCC  07F441     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
135:               			//Try to transmit the message; reset flag if successful
136:               			if (BT_SendCommand(appData.transmit_packet, true)) {
001CCE  B3C011     MOV.B #0x1, W1
001CD0  20B0E0     MOV #0xB0E, W0
001CD2  07FCA2     RCALL BT_SendCommand
001CD4  5787EA     SUB W15, #0xA, W15
001CD6  E00400     CP0.B W0
001CD8  320003     BRA Z, .L15
137:               				BT_CheckResponse_AOK(&failure);
001CDA  20BDC0     MOV #0xBDC, W0
001CDC  07FD7B     RCALL BT_CheckResponse_AOK
138:               				appData.sendSwitches = false;
001CDE  EF6B90     CLR.B .L65
139:               			}
140:               		}
141:               
142:               		//Process ADC accumulator value if oversampling is complete
143:               		if (appData.accumReady) {
001CE0  E24BA8     CP0.B 0xBA8
001CE2  320003     BRA Z, .L16
144:               			ADC_ProcAccum();
001CE4  0702B6     RCALL ADC_ProcAccum
145:               #ifdef USE_SLEEP                //see config.h, Application setting section
146:               			potDiff = appData.potValue - appData.potValueOld; //Reset the inactivity sleep timer if pot has changed
147:               			if (potDiff > POT_KEEP_AWAKE_DELTA || potDiff < -POT_KEEP_AWAKE_DELTA) {
148:               				SleepTimerReset();
149:               			}
150:               #endif
151:               			appData.accumReady = false; //Clear app flags
001CE6  EF6BA8     CLR.B 0xBA8
152:               			appData.ADCinUse = false;
001CE8  EF6BA9     CLR.B 0xBA9
153:               		}
154:               
155:               		// packet transmission queue, TimerDone puts packet in the transmission stream
156:               
157:               		//Start new ADC read if timer expired, not currently sampling, and not waiting to process accumulator
158:               		if (TimerDone(TMR_ADC) && appData.ADCinUse == false) {
001CEA  B3C030     MOV.B #0x3, W0
001CEC  0703D4     RCALL .LFE1, .LFB2, _TimerDone
001CEE  E00400     CP0.B W0
001CF0  320008     BRA Z, .L17
001CF2  E24BA9     CP0.B 0xBA9
001CF4  3A0006     BRA NZ, .L17
159:               			if (ADC_Tasks()) {
001CF6  070260     RCALL ADC_Tasks
001CF8  E00400     CP0.B W0
001CFA  320003     BRA Z, .L17
160:               				StartTimer(TMR_ADC, ADC_REFRESH_MS);
001CFC  2000A1     MOV #0xA, W1
001CFE  B3C030     MOV.B #0x3, W0
001D00  0703C4     RCALL .LFE0, .LFB1, _StartTimer
161:               			} //Restart timer once module is up and running
162:               		}
163:               
164:               		//Transmit new potentiometer reading?
165:               		if (TimerDone(TMR_POT)) {
001D02  B3C040     MOV.B #0x4, W0
001D04  0703C8     RCALL .LFE1, .LFB2, _TimerDone
001D06  E00400     CP0.B W0
001D08  320017     BRA Z, .L18
166:               			//Send message only if pot value has changed
167:               			if (appData.potValue != appData.potValueLastTX) {
001D0A  805D70     MOV 0xBAE, W0
001D0C  E30BB2     CP 0xBB2
001D0E  320011     BRA Z, .L19
168:               				//Form message
169:               				sprintf(appData.transmit_packet, "shw,"PRIVATE_CHAR_POTENTIOMETER_H",%04d\r", appData.potValue);
001D10  781F80     MOV W0, [W15++]
001D12  294CE0     MOV #0x94CE, W0
001D14  781F80     MOV W0, [W15++]
001D16  20B0E0     MOV #0xB0E, W0
001D18  07F41B     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
170:               				//Try to transmit the message; reset timer if successful
171:               				if (BT_SendCommand(appData.transmit_packet, true)) {
001D1A  B3C011     MOV.B #0x1, W1
001D1C  20B0E0     MOV #0xB0E, W0
001D1E  07FC7C     RCALL BT_SendCommand
001D20  5787E4     SUB W15, #0x4, W15
001D22  E00400     CP0.B W0
001D24  320009     BRA Z, .L18
172:               					appData.potValueLastTX = appData.potValue;
001D26  F80BAE     PUSH 0xBAE
001D28  F90BB2     POP 0xBB2
173:               					StartTimer(TMR_POT, POT_TX_MS);
001D2A  200141     MOV #0x14, W1
001D2C  B3C040     MOV.B #0x4, W0
001D2E  0703AD     RCALL .LFE0, .LFB1, _StartTimer
001D30  370003     BRA .L18
174:               				}
175:               			} else {
176:               				StartTimer(TMR_POT, POT_TX_MS);
001D32  200141     MOV #0x14, W1
001D34  B3C040     MOV.B #0x4, W0
001D36  0703A9     RCALL .LFE0, .LFB1, _StartTimer
177:               			} //value not changed - skip this transmission
178:               		}
179:               
180:               		if (TimerDone(TMR_BATT)) {
001D38  B3C0D0     MOV.B #0xD, W0
001D3A  0703AD     RCALL .LFE1, .LFB2, _TimerDone
001D3C  E00400     CP0.B W0
001D3E  320013     BRA Z, .L20
181:               			//Form message
182:               			sprintf(appData.transmit_packet, "shw,"PUBLIC_BATT_CHAR_H",%02d\r\n", (appData.potValue >> 6)&0b00111111);
001D40  805D70     MOV 0xBAE, W0
001D42  DE0046     LSR W0, #6, W0
001D44  B203F0     AND #0x3F, W0
001D46  781F80     MOV W0, [W15++]
001D48  294DD0     MOV #0x94DD, W0
001D4A  781F80     MOV W0, [W15++]
001D4C  20B0E0     MOV #0xB0E, W0
001D4E  07F400     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
183:               			//Try to transmit the message; reset timer if successful
184:               			if (BT_SendCommand(appData.transmit_packet, true)) {
001D50  B3C011     MOV.B #0x1, W1
001D52  20B0E0     MOV #0xB0E, W0
001D54  07FC61     RCALL BT_SendCommand
001D56  5787E4     SUB W15, #0x4, W15
001D58  E00400     CP0.B W0
001D5A  320005     BRA Z, .L20
185:               				BT_CheckResponse_AOK(&failure);
001D5C  20BDC0     MOV #0xBDC, W0
001D5E  07FD3A     RCALL BT_CheckResponse_AOK
186:               				StartTimer(TMR_BATT, BATT_TX_MS);
001D60  201901     MOV #0x190, W1
001D62  B3C0D0     MOV.B #0xD, W0
001D64  070392     RCALL .LFE0, .LFB1, _StartTimer
187:               			}
188:               		}
189:               
190:               		if (TimerDone(TMR_HR)) {
001D66  B3C0C0     MOV.B #0xC, W0
001D68  070396     RCALL .LFE1, .LFB2, _TimerDone
001D6A  E00400     CP0.B W0
001D6C  320024     BRA Z, .L21
191:               			//Form message
192:               			sprintf(appData.transmit_packet, "shw,"PUBLIC_HR_CHAR_HRM_H",%02x%02x%02x%02x\r\n", 0x08, (appData.potValue >> 4)&0xff, appData.hrmEnergy & 0x00ff, appData.hrmEnergy >> 8); // format mask and ADC data
001D6E  805DB1     MOV 0xBB6, W1
001D70  DE0848     LSR W1, #8, W0
001D72  781F80     MOV W0, [W15++]
001D74  200FF0     MOV #0xFF, W0
001D76  609F80     AND W1, W0, [W15++]
001D78  805D71     MOV 0xBAE, W1
001D7A  DE08C4     LSR W1, #4, W1
001D7C  609F80     AND W1, W0, [W15++]
001D7E  200080     MOV #0x8, W0
001D80  781F80     MOV W0, [W15++]
001D82  294ED0     MOV #0x94ED, W0
001D84  781F80     MOV W0, [W15++]
001D86  20B0E0     MOV #0xB0E, W0
001D88  07F3E3     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
193:               			//Try to transmit the message; reset timer if successful
194:               			if (BT_SendCommand(appData.transmit_packet, true)) {
001D8A  B3C011     MOV.B #0x1, W1
001D8C  20B0E0     MOV #0xB0E, W0
001D8E  07FC44     RCALL BT_SendCommand
001D90  5787EA     SUB W15, #0xA, W15
001D92  E00400     CP0.B W0
001D94  320010     BRA Z, .L21
195:               				BT_CheckResponse_AOK(&failure);
001D96  20BDC0     MOV #0xBDC, W0
001D98  07FD1D     RCALL BT_CheckResponse_AOK
196:               				StartTimer(TMR_HR, HR_TX_MS);
001D9A  200C81     MOV #0xC8, W1
001D9C  B3C0C0     MOV.B #0xC, W0
001D9E  070375     RCALL .LFE0, .LFB1, _StartTimer
197:               				sprintf(appData.transmit_packet, "shw,"PUBLIC_HR_CHAR_BSL_H",%02x\r\n", 3);
001DA0  200030     MOV #0x3, W0
001DA2  781F80     MOV W0, [W15++]
001DA4  295090     MOV #0x9509, W0
001DA6  781F80     MOV W0, [W15++]
001DA8  20B0E0     MOV #0xB0E, W0
001DAA  07F3D2     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
198:               				BT_SendCommand(appData.transmit_packet, false);
001DAC  EB4080     CLR.B W1
001DAE  20B0E0     MOV #0xB0E, W0
001DB0  07FC33     RCALL BT_SendCommand
199:               				appData.hrmEnergy++;
001DB2  EC2BB6     INC 0xBB6
001DB4  5787E4     SUB W15, #0x4, W15
200:               			}
201:               		}
202:               
203:               		if (TimerDone(TMR_AIO_DIG)) {
001DB6  B3C0E0     MOV.B #0xE, W0
001DB8  07036E     RCALL .LFE1, .LFB2, _TimerDone
001DBA  E00400     CP0.B W0
001DBC  32000F     BRA Z, .L22
204:               			//Form message
205:               			sprintf(appData.transmit_packet, "shw,"PUBLIC_AIO_CHAR_DIG_H",0101010101010101\r\n"); // digital data
001DBE  295190     MOV #0x9519, W0
001DC0  20B0E1     MOV #0xB0E, W1
001DC2  09001B     REPEAT #0x1B
001DC4  7858B0     MOV.B [W0++], [W1++]
001DC6  B101C0     SUB #0x1C, W0
206:               			//Try to transmit the message; reset timer if successful
207:               			if (BT_SendCommand(appData.transmit_packet, true)) {
001DC8  B3C011     MOV.B #0x1, W1
001DCA  20B0E0     MOV #0xB0E, W0
001DCC  07FC25     RCALL BT_SendCommand
001DCE  E00400     CP0.B W0
001DD0  320005     BRA Z, .L22
208:               				BT_CheckResponse_AOK(&failure);
001DD2  20BDC0     MOV #0xBDC, W0
001DD4  07FCFF     RCALL BT_CheckResponse_AOK
209:               				StartTimer(TMR_AIO_DIG, AIO_TX_MS);
001DD6  200C81     MOV #0xC8, W1
001DD8  B3C0E0     MOV.B #0xE, W0
001DDA  070357     RCALL .LFE0, .LFB1, _StartTimer
210:               			}
211:               		}
212:               
213:               		//Process any new messages received from RN module
214:               #ifdef	BT_RN4871
215:               		appData.rn_4871_packets = true;
001DDC  B3C010     MOV.B #0x1, W0
001DDE  B7EB9D     MOV.B WREG, 0xB9D
216:               #endif
217:               		appData.got_packet = BT_ReceivePacket(appData.receive_packet); //Get new message if one has been received from the RNxxxx
001DE0  20A0E0     MOV #0xA0E, W0
001DE2  07FBDC     RCALL BT_ReceivePacket
001DE4  B7EB8E     MOV.B WREG, 0xB8E
218:               		if (appData.got_packet == true) { //true if new packet received
001DE6  E00400     CP0.B W0
001DE8  320043     BRA Z, .L4
219:               
220:               			appData.packet_data = Get_Link_Packet();
001DEA  070320     RCALL Get_Link_Packet
001DEC  885DC0     MOV W0, .L67
221:               			appData.packet_data->dac1 = appData.potValue & 0xff;
001DEE  20BAE1     MOV #0xBAE, W1
001DF0  784091     MOV.B [W1], W1
001DF2  984011     MOV.B W1, [W0+1]
222:               			appData.packet_data->dac2 = appData.potValue >> 8;
001DF4  805DC0     MOV .L67, W0
001DF6  20BAF1     MOV #0xBAF, W1
001DF8  784091     MOV.B [W1], W1
001DFA  984021     MOV.B W1, [W0+2]
223:               			Write_Link_Packet((uint8_t *) appData.packet_data, true);
001DFC  B3C011     MOV.B #0x1, W1
001DFE  805DC0     MOV .L67, W0
001E00  0702F0     RCALL Write_Link_Packet
224:               
225:               			if (strstr(appData.receive_packet, "WV,001E,")) { //Check for LED update message 1.23
001E02  295351     MOV #0x9535, W1
001E04  20A0E0     MOV #0xA0E, W0
001E06  07F3BA     RCALL _strstr
001E08  E00000     CP0 W0
001E0A  320003     BRA Z, .L23
226:               				GetNewLEDs(strstr(appData.receive_packet, "WV,001E,")); //Latch new LED values
001E0C  07008A     RCALL GetNewLEDs
227:               				appData.update_packet = true;
001E0E  B3C010     MOV.B #0x1, W0
001E10  B7EB8F     MOV.B WREG, 0xB8F
228:               			}
229:               			if (strstr(appData.receive_packet, "WV,"PRIVATE_CHAR_LEDS_H",")) { //Check for LED update message 1.33
001E12  2953E1     MOV #0x953E, W1
001E14  20A0E0     MOV #0xA0E, W0
001E16  07F3B2     RCALL _strstr
001E18  E00000     CP0 W0
001E1A  320003     BRA Z, .L24
230:               				GetNewLEDs(strstr(appData.receive_packet, "WV,"PRIVATE_CHAR_LEDS_H",")); //Latch new LED values
001E1C  070082     RCALL GetNewLEDs
231:               				appData.update_packet = true;
001E1E  B3C010     MOV.B #0x1, W0
001E20  B7EB8F     MOV.B WREG, 0xB8F
232:               			}
233:               			//
234:               			//Other message handling can be added here
235:               			//
236:               			//receive new SPI ADC channel
237:               			if (strstr(appData.receive_packet, "WV,"PRIVATE_CHAR_ADC_CHAN_H",")) {
001E22  295471     MOV #0x9547, W1
001E24  20A0E0     MOV #0xA0E, W0
001E26  07F3AA     RCALL _strstr
001E28  E00000     CP0 W0
001E2A  320001     BRA Z, .L25
238:               				GetNewADC_Chan(strstr(appData.receive_packet, "WV,"PRIVATE_CHAR_ADC_CHAN_H",")); // new ADC config data
001E2C  070217     RCALL GetNewADC_Chan
239:               			}
240:               			//receive new SPI SLAVE request
241:               			if (strstr(appData.receive_packet, "WV,"PRIVATE_CHAR_PIC_SLAVE_H",")) {
242:               
243:               			}
244:               			// HRM energy expended reset
245:               			if (strstr(appData.receive_packet, "WV,"PUBLIC_HR_CHAR_RCP_H",01")) {
001E2E  295501     MOV #0x9550, W1
001E30  20A0E0     MOV #0xA0E, W0
001E32  07F3A4     RCALL _strstr
001E34  E00000     CP0 W0
001E36  320001     BRA Z, .L26
246:               				appData.hrmEnergy = 0;
001E38  EF2BB6     CLR 0xBB6
247:               			}
248:               			//receive new BATTERY request
249:               			if (strstr(appData.receive_packet, "RV,"PUBLIC_BATT_CHAR_H"")) {
001E3A  2955B1     MOV #0x955B, W1
001E3C  20A0E0     MOV #0xA0E, W0
001E3E  07F39E     RCALL _strstr
001E40  E00000     CP0 W0
001E42  32000C     BRA Z, .L27
250:               				//Form message
251:               				sprintf(appData.transmit_packet, "shw,"PUBLIC_BATT_CHAR_H",%d\r", 63);
001E44  2003F0     MOV #0x3F, W0
001E46  781F80     MOV W0, [W15++]
001E48  295630     MOV #0x9563, W0
001E4A  781F80     MOV W0, [W15++]
001E4C  20B0E0     MOV #0xB0E, W0
001E4E  07F380     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
252:               				//Try to transmit the message; reset timer if successful
253:               				BT_SendCommand(appData.transmit_packet, false);
001E50  EB4080     CLR.B W1
001E52  20B0E0     MOV #0xB0E, W0
001E54  07FBE1     RCALL BT_SendCommand
254:               				BT_CheckResponse_AOK(&failure);
001E56  20BDC0     MOV #0xBDC, W0
001E58  07FCBD     RCALL BT_CheckResponse_AOK
001E5A  5787E4     SUB W15, #0x4, W15
255:               			}
256:               
257:               #ifdef	BT_RN4871
258:               
259:               			if (strstr(appData.receive_packet, "DISCONNECT") || (failure > 25)) {
001E5C  295701     MOV #0x9570, W1
001E5E  20A0E0     MOV #0xA0E, W0
001E60  07F38D     RCALL _strstr
001E62  E00000     CP0 W0
001E64  3A0003     BRA NZ, .L28
001E66  805EE0     MOV failure, W0
001E68  500FF9     SUB W0, #0x19, [W15]
001E6A  360002     BRA LEU, .L4
260:               				appData.rn4871_connected = false;
001E6C  EF6B9C     CLR.B 0xB9C
261:               				failure = 0;
001E6E  EF2BDC     CLR failure
262:               			}
263:               #endif
264:               		}
265:               		break;
266:               
267:               #ifdef USE_SLEEP                //see config.h, Application setting section        
268:               		//Put micro and RN module to sleep - any button press will cause wake up
269:               	case APP_SLEEP:
270:               		appData.sleepFlag = 0; //clear flag and call sleep function
271:               		APP_SleepNow();
272:               		appData.state = savedState; //Woken from sleep; restore state
273:               
274:               		break;
275:               #endif //USE_SLEEP
276:               
277:               	default:
278:               		break;
279:               	} //end switch(appData.state)
280:               } //end APP_Tasks()
001E70  060000     RETURN
281:               
282:               //Sets up the RN module
283:               
284:               bool APP_Initialize(void)
285:               {
286:               	/****************************************************************************
287:               	 * Initialize appData structure
288:               	 ***************************************************************************/
289:               	appData.error_code = ERROR_NONE;
001BAC  B3C010     MOV.B #0x1, W0
001BAE  B7EB9E     MOV.B WREG, 0xB9E
290:               	appData.got_packet = false;
001BB0  EF6B8E     CLR.B 0xB8E
291:               	appData.potValue = 0;
001BB2  EF2BAE     CLR 0xBAE
292:               	appData.potValueOld = 0xFFFF;
001BB4  EB8080     SETM W1
001BB6  885D81     MOV W1, 0xBB0
293:               	appData.potValueLastTX = 0xFFFF;
001BB8  885D91     MOV W1, 0xBB2
294:               	appData.state = APP_INITIALIZE;
001BBA  EF2A0C     CLR appData
295:               	appData.sw1 = false;
001BBC  EF6B9F     CLR.B 0xB9F
296:               	appData.sw2 = false;
001BBE  EF6BA0     CLR.B 0xBA0
297:               	appData.sw3 = false;
001BC0  EF6BA1     CLR.B 0xBA1
298:               	appData.sw4 = false;
001BC2  EF6BA2     CLR.B .L35
299:               	appData.led1 = 0;
001BC4  EF6B92     CLR.B 0xB92
300:               	appData.led2 = 0;
001BC6  EF6B93     CLR.B 0xB93
301:               	appData.led3 = 0;
001BC8  EF6B94     CLR.B 0xB94
302:               	appData.led4 = 0;
001BCA  EF6B95     CLR.B 0xB95
303:               	appData.led5 = 0;
001BCC  EF6B96     CLR.B 0xB96
304:               	appData.led6 = 0;
001BCE  EF6B97     CLR.B 0xB97
305:               	appData.update_packet = true;
001BD0  B7EB8F     MOV.B WREG, 0xB8F
306:               	appData.sw1Changed = false;
001BD2  EF6BA3     CLR.B 0xBA3
307:               	appData.sw2Changed = false;
001BD4  EF6BA4     CLR.B 0xBA4
308:               	appData.sw3Changed = false;
001BD6  EF6BA5     CLR.B 0xBA5
309:               	appData.sw4Changed = false;
001BD8  EF6BA6     CLR.B .L41
310:               	appData.sendSwitches = false;
001BDA  EF6B90     CLR.B .L65
311:               	appData.ADCcalFlag = false;
001BDC  EF6B91     CLR.B 0xB91
312:               	appData.sleepFlag = false;
001BDE  EF6BAC     CLR.B 0xBAC
313:               	appData.RTCCalarm = false;
001BE0  EF6BA7     CLR.B 0xBA7
314:               	appData.accumReady = false;
001BE2  EF6BA8     CLR.B 0xBA8
315:               	appData.ADCinUse = false;
001BE4  EF6BA9     CLR.B 0xBA9
316:               	appData.timer1Flag = false;
001BE6  EF6BAA     CLR.B 0xBAA
317:               	appData.rn4871_connected = false;
001BE8  EF6B9C     CLR.B 0xB9C
318:               	appData.rn_4871_packets = false;
001BEA  EF6B9D     CLR.B 0xB9D
319:               
320:               	/****************************************************************************
321:               	 * Peripherals Init
322:               	 ***************************************************************************/
323:               	ADC_Init(); //Initialize the pADC
001BEC  0702D6     RCALL ADC_Init
324:               	UART_Init(); //Initialize the UART
001BEE  0703A7     RCALL UART_Init
325:               	Timers_Init(); //Initialize the timers
001BF0  070444     RCALL Timers_Init
326:               	SPI_Init();
001BF2  070255     RCALL SPI_Init
327:               
328:               #ifdef USE_SLEEP            //see config.h, Application settings section
329:               #ifdef SLEEP_MODE_RTCC
330:               	RTCC_Init();
331:               #endif  //SLEEP_MODE_RTCC
332:               #endif  //USE_SLEEP
333:               
334:               	// set RN4871 to command mode
335:               #ifdef BT_RN4871
336:               	U1MODEbits.UARTEN = 0; // disable UART so we can change flow control to none
001BF4  A9E221     BCLR 0x221, #7
337:               	WaitMs(50);
001BF6  200320     MOV #0x32, W0
001BF8  070457     RCALL WaitMs
338:               	U1MODEbits.UEN0 = 0; // NO RTS/CTS
001BFA  A90221     BCLR 0x221, #0
339:               	U1MODEbits.UEN1 = 0; // NO RTS/CTS
001BFC  A92221     BCLR 0x221, #1
340:               	U1MODEbits.UARTEN = 1; // enable UART
001BFE  A8E221     BSET 0x221, #7
341:               	U1STA = 0x0400; //Enable transmit
001C00  204000     MOV #0x400, W0
001C02  881110     MOV W0, U1STA
342:               
343:               	// BTCMD("$");
344:               	BT_SendCommand("$", false);
001C04  EB4080     CLR.B W1
001C06  294AC0     MOV #0x94AC, W0
001C08  07FD07     RCALL BT_SendCommand
345:               	WaitMs(100);
001C0A  200640     MOV #0x64, W0
001C0C  07044D     RCALL WaitMs
346:               	// BTCMD("$$$");
347:               	BT_SendCommand("$$$", false);
001C0E  EB4080     CLR.B W1
001C10  294AE0     MOV #0x94AE, W0
001C12  07FD02     RCALL BT_SendCommand
348:               	WaitMs(500);
001C14  201F40     MOV #0x1F4, W0
001C16  070448     RCALL WaitMs
349:               
350:               	//Module is now in command mode and ready for input
351:               	if (!BT_SetupModule_4871()) { //Setup RN4871 module
001C18  07FE91     RCALL BT_SetupModule_4871
001C1A  E00400     CP0.B W0
001C1C  3A0004     BRA NZ, .L2
352:               		appData.error_code = ERROR_INITIALIZATION;
001C1E  B3CFE0     MOV.B #0xFE, W0
001C20  B7EB9E     MOV.B WREG, 0xB9E
353:               		return false;
001C22  EB4000     CLR.B W0
001C24  370003     BRA .L3
354:               	}
355:               #endif
356:               
357:               #ifdef	BT_RN4020
358:               	BT_WAKE_SW = 1; //wake module
359:               	//Wait for WS status high
360:               	StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
361:               	while (BT_WS == 0) {
362:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
363:               		{
364:               			appData.error_code = ERROR_INITIALIZATION;
365:               			return false;
366:               		}
367:               	}
368:               
369:               	//Wait for end of "CMD\r\n" - we don't check for full "CMD\r\n" string because we may 
370:               	//miss some bits or bytes at the beginning while the UART starts up
371:               	StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
372:               	while (UART_ReadRxBuffer() != '\n') {
373:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
374:               		{
375:               			appData.error_code = ERROR_INITIALIZATION;
376:               			return false;
377:               		}
378:               	}
379:               
380:               	//Module is now in command mode and ready for input
381:               	if (!BT_SetupModule_4020()) { //Setup RN4020 module
382:               		appData.error_code = ERROR_INITIALIZATION;
383:               		return false;
384:               	}
385:               
386:               #ifdef VERIFY_RN_FW_VER
387:               	//Verify RN4020 module's firmware version
388:               	if (!(appData.version_code = BT_CheckFwVer())) {
389:               		appData.error_code = ERROR_RN_FW;
390:               		return false;
391:               	}
392:               #endif // VERIFY_RN_FW_VER 
393:               #endif
394:               
395:               	//flush UART RX buffer as a precaution before starting app state machine
396:               	clear_bt_port();
001C26  07FCAA     RCALL clear_bt_port
397:               
398:               	SLED = 1; // init completed
001C28  A8C2CD     BSET 0x2CD, #6
399:               	return true;
001C2A  B3C010     MOV.B #0x1, W0
400:               }
001C2C  060000     RETURN
---  /root/MPLABXProjects/fac_relay_clone/adc.c  --------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        adc.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 * modified for MCP3208 device Nov 2016
32:                 *
33:                 *
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdbool.h>
39:                #include "adc.h"
40:                #include "spi.h"
41:                #include "app.h"
42:                #include "config.h"
43:                #include "timers.h"
44:                
45:                extern APP_DATA appData;
46:                extern ADC_DATA adcData;
47:                
48:                /******************************************************************************
49:                 * Function:        void ADC_Init()
50:                 *
51:                 * PreCondition:    None
52:                 *
53:                 * Input:           None
54:                 *
55:                 * Output:          None
56:                 *
57:                 * Side Effects:    None
58:                 *
59:                 * Overview:        This routine initializes the ADC 
60:                 *                 
61:                 * Note:
62:                 *
63:                 *****************************************************************************/
64:                
65:                void ADC_Init()
66:                {
67:                	adcData.mcp3208_cmd.ld = 0; // clear the command word
00219A  20BBA0     MOV #0xBBA, W0
00219C  EB0800     CLR [W0]
00219E  781030     MOV [W0++], [W0--]
68:                	adcData.chan = 0;
0021A0  EB4080     CLR.B W1
0021A2  984061     MOV.B W1, [W0+6]
69:                	adcData.mcp3208_cmd.map.start_bit = 1;
0021A4  900090     MOV [W0+2], W1
70:                	adcData.mcp3208_cmd.map.single_diff = 1;
0021A6  B30061     IOR #0x6, W1
71:                	adcData.mcp3208_cmd.map.index = 0; // channel
0021A8  23FFF2     MOV #0x3FFF, W2
0021AA  610810     AND W2, [W0], [W0]
0021AC  A10001     BCLR W1, #0
0021AE  980011     MOV W1, [W0+2]
72:                	appData.ADCcalFlag = true;
0021B0  B3C010     MOV.B #0x1, W0
0021B2  B7EB91     MOV.B WREG, 0xB91
73:                	SPI_CS0 = 1;
0021B4  A862C4     BSET LATA, #3
74:                }
0021B6  060000     RETURN
75:                
76:                //State machine for restarting ADC and taking new readings from pot
77:                //Returns true when SPI data has been returned from the mpc3208; false otherwise
78:                
79:                bool ADC_Tasks(void)
80:                {
0021B8  BE9F88     MOV.D W8, [W15++]
81:                	static uint8_t count = 0;
82:                
83:                	/* send the command sequence to the adc */
84:                	if (!adcData.mcp3208_cmd.map.in_progress) {
0021BA  AB8BBD     BTST 0xBBD, #4
0021BC  3A003D     BRA NZ, .L12
85:                		adcData.mcp3208_cmd.map.in_progress = true;
0021BE  20BBA0     MOV #0xBBA, W0
0021C0  900090     MOV [W0+2], W1
0021C2  A0C001     BSET W1, #12
86:                		adcData.mcp3208_cmd.map.finish = false;
0021C4  A1B001     BCLR W1, #11
0021C6  980011     MOV W1, [W0+2]
87:                		count = 0;
0021C8  EF6C98     CLR.B count
88:                		if (!SPI_IsTxData()) {
0021CA  07FFBF     RCALL SPI_IsTxData
0021CC  784080     MOV.B W0, W1
0021D0  E00401     CP0.B W1
0021D2  3A003D     BRA NZ, .L4
89:                			adcData.mcp3208_cmd.map.single_diff = 1;
0021D4  20BBA8     MOV #0xBBA, W8
0021D6  900118     MOV [W8+2], W2
0021D8  A01002     BSET W2, #1
90:                			adcData.mcp3208_cmd.map.index = adcData.chan;
0021DA  900038     MOV [W8+6], W0
0021DC  DD00CE     SL W0, #14, W1
0021DE  23FFF3     MOV #0x3FFF, W3
0021E0  618198     AND W3, [W8], W3
0021E2  718C01     IOR W3, W1, [W8]
0021E4  DE0042     LSR W0, #2, W0
0021E6  6000E1     AND W0, #0x1, W1
0021E8  780002     MOV W2, W0
0021EA  A10000     BCLR W0, #0
0021EC  708000     IOR W1, W0, W0
0021EE  980410     MOV W0, [W8+2]
91:                			SPI_ClearBufs(); // dump the spi buffers
0021F0  07FF74     RCALL SPI_ClearBufs
92:                			SPI_WriteTxBuffer(adcData.mcp3208_cmd.bd[2]);
0021F2  904028     MOV.B [W8+2], W0
0021F4  07FFB3     RCALL SPI_WriteTxBuffer
93:                			SPI_WriteTxBuffer(adcData.mcp3208_cmd.bd[1]);
0021F6  904018     MOV.B [W8+1], W0
0021F8  07FFB1     RCALL SPI_WriteTxBuffer
94:                			SPI_WriteTxBuffer(adcData.mcp3208_cmd.bd[0]);
0021FA  784018     MOV.B [W8], W0
0021FC  07FFAF     RCALL SPI_WriteTxBuffer
95:                			SPI_CS0 = 0; // select the ADC
0021FE  A962C4     BCLR LATA, #3
96:                			SPI_Speed(0);
002200  EB4000     CLR.B W0
002202  07FF5F     RCALL SPI_Speed
97:                			SPI_TxStart();
002204  07FF75     RCALL SPI_TxStart
98:                		}
99:                		return false;
0021CE  EB4000     CLR.B W0
002206  EB4000     CLR.B W0
002208  370022     BRA .L4
100:               	}
101:               
102:               	/* read the returned spi data from the buffer and format it */
103:               	if (adcData.mcp3208_cmd.map.in_progress) {
104:               		while (SPI_IsNewRxData()) {
002238  07FF6E     RCALL SPI_IsNewRxData
00223A  E00400     CP0.B W0
00223C  3AFFE6     BRA NZ, .L9
105:               			switch (count) {
00220A  BFCC98     MOV.B count, WREG
00220C  504FE1     SUB.B W0, #0x1, [W15]
00220E  320003     BRA Z, .L6
002210  504FE2     SUB.B W0, #0x2, [W15]
002212  3A0010     BRA NZ, .L13
002214  370005     BRA .L14
106:               			case 1:
107:               				adcData.potValue = (SPI_ReadRxBuffer()&0x0f) << 8;
002216  07FF88     RCALL SPI_ReadRxBuffer
002218  60006F     AND W0, #0xF, W0
00221A  DD0048     SL W0, #8, W0
00221C  885DF0     MOV W0, 0xBBE
108:               				break;
00221E  37000B     BRA .L8
109:               			case 2:
110:               				adcData.potValue += SPI_ReadRxBuffer();
002220  20BBA8     MOV #0xBBA, W8
002222  9004A8     MOV [W8+4], W9
002224  07FF81     RCALL SPI_ReadRxBuffer
002226  FB8000     ZE W0, W0
002228  400489     ADD W0, W9, W9
00222A  980429     MOV W9, [W8+4]
111:               				adcData.mcp3208_cmd.map.finish = true;
00222C  900018     MOV [W8+2], W0
00222E  A0B000     BSET W0, #11
002230  980410     MOV W0, [W8+2]
112:               				break;
002232  370001     BRA .L8
113:               			default:
114:               				SPI_ReadRxBuffer(); // eat extra bytes
002234  07FF79     RCALL SPI_ReadRxBuffer
115:               				break;
116:               			}
117:               			count++;
002236  EC6C98     INC.B count
118:               		}
119:               	}
120:               
121:               	/* cleanup for next time */
122:               	if (adcData.mcp3208_cmd.map.finish) {
00223E  AB6BBD     BTST 0xBBD, #3
002240  320006     BRA Z, .L4
123:               		adcData.mcp3208_cmd.map.in_progress = false;
002242  20BBA0     MOV #0xBBA, W0
002244  900090     MOV [W0+2], W1
002246  A1C001     BCLR W1, #12
002248  980011     MOV W1, [W0+2]
124:               		appData.accumReady = true;
00224A  B3C010     MOV.B #0x1, W0
00224C  B7EBA8     MOV.B WREG, 0xBA8
125:               		return true;
126:               	}
127:               
128:               	return false;
129:               }
00224E  BE044F     MOV.D [--W15], W8
002250  060000     RETURN
130:               
131:               //Process the accumulator value once it is ready
132:               //And update stored potentiometer values
133:               
134:               void ADC_ProcAccum(void)
135:               {
136:               	appData.potValueOld = appData.potValue; //Save previous value
002252  F80BAE     PUSH 0xBAE
002254  F90BB0     POP 0xBB0
137:               	appData.potValue = adcData.potValue;
002256  F80BBE     PUSH 0xBBE
002258  F90BAE     POP 0xBAE
138:               }
00225A  060000     RETURN
139:               
140:               //ADC ISR
141:               
142:               void _ISR_NO_AUTO_PSV _ISR _ADC1Interrupt(void)
143:               {
144:               	IFS0bits.AD1IF = 0;
0002C8  A9A085     BCLR 0x85, #5
145:               	//Accumulation complete
146:               
147:               }
0002CA  064000     RETFIE
148:               
149:               void GetNewADC_Chan(char * receive_packet)
150:               {
151:               	adcData.chan = receive_packet[9] == '1' ? 1 : 0; // update adc channel 
00225C  904990     MOV.B [W0+9], W3
00225E  B3C312     MOV.B #0x31, W2
002260  69C182     XOR.B W3, W2, W3
002262  FB8183     ZE W3, W3
002264  E90183     DEC W3, W3
002266  DE19CF     LSR W3, #15, W3
002268  784203     MOV.B W3, W4
00226A  784283     MOV.B W3, W5
00226C  20BC01     MOV #0xBC0, W1
00226E  784885     MOV.B W5, [W1]
152:               	adcData.chan += receive_packet[11] == '1' ? 2 : 0;
002270  9049B0     MOV.B [W0+11], W3
002272  EB4080     CLR.B W1
002274  51CF82     SUB.B W3, W2, [W15]
002276  3A0001     BRA NZ, .L18
002278  B3C021     MOV.B #0x2, W1
00227A  40C084     ADD.B W1, W4, W1
00227C  20BC02     MOV #0xBC0, W2
00227E  784901     MOV.B W1, [W2]
153:               	adcData.chan += receive_packet[13] == '1' ? 4 : 0;
002280  9049D0     MOV.B [W0+13], W3
002282  EB4000     CLR.B W0
002284  B3C312     MOV.B #0x31, W2
002286  51CF82     SUB.B W3, W2, [W15]
002288  3A0001     BRA NZ, .L19
00228A  B3C040     MOV.B #0x4, W0
00228C  404081     ADD.B W0, W1, W1
00228E  784001     MOV.B W1, W0
002290  B7EBC0     MOV.B WREG, 0xBC0
154:               }
002292  060000     RETURN
