Disassembly Listing for blecm_dk
Generated From:
/root/ble/fac_relay_clone/blecm_dk.X/dist/default/debug/blecm_dk.X.debug.elf
Sep 7, 2018 7:37:04 PM

---  /root/ble/fac_relay_clone/uart.c  ------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        uart.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Uart functions
33:                 * 
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdbool.h>
39:                #include <stddef.h>
40:                #include "uart.h"
41:                #include "config.h"
42:                
43:                //UART receive buffer type
44:                
45:                typedef struct {
46:                	volatile uint8_t buffer[SIZE_RxBuffer];
47:                	volatile uint8_t volatile *head;
48:                	volatile uint8_t *tail;
49:                	volatile uint16_t byteCount;
50:                } UART_RX_BUFFER_T;
51:                
52:                //UART transmit buffer type
53:                
54:                typedef struct {
55:                	volatile uint8_t buffer[SIZE_TxBuffer];
56:                	volatile uint8_t *head;
57:                	volatile uint8_t volatile *tail;
58:                	volatile uint16_t byteCount;
59:                } UART_TX_BUFFER_T;
60:                
61:                //Buffer instances
62:                static UART_RX_BUFFER_T rxBuf;
63:                static UART_TX_BUFFER_T txBuf;
64:                
65:                //**********************************************************************************************************************
66:                // Initialize the UART to communicate with the Bluetooth module
67:                
68:                void UART_Init(void)
69:                {
70:                	rxBuf.tail = &rxBuf.buffer[0]; //Initialize the pointers
0026F4  208500     MOV #0x850, W0
0026F6  884A90     MOV W0, 0x952
71:                	rxBuf.head = &rxBuf.buffer[0];
0026F8  884A80     MOV W0, 0x950
72:                	txBuf.tail = &txBuf.buffer[0];
0026FA  209560     MOV #0x956, W0
0026FC  8852C0     MOV W0, 0xA58
73:                	txBuf.head = &txBuf.buffer[0];
0026FE  8852B0     MOV W0, .L94
74:                	txBuf.byteCount = rxBuf.byteCount = 0;
002700  EF2954     CLR 0x954
002702  F80954     PUSH 0x954
002704  F90A5A     POP 0xA5A
75:                
76:                	U1BRG = 34; //Baud rate 115,200 - actually 115,384 baud 0.16% error
002706  200220     MOV #0x22, W0
002708  881140     MOV W0, U1BRG
77:                	//	U1BRG = 7;
78:                	U1MODE = 0x8008; //Enable UART, no flow control, BRGH = 1 for high speed baud mode
00270A  280080     MOV #0x8008, W0
00270C  881100     MOV W0, U1MODE
79:                	U1MODEbits.UEN0=0; //
00270E  A90221     BCLR 0x221, #0
80:                	U1MODEbits.UEN1=1; // enable RTS/CTS
002710  A82221     BSET 0x221, #1
81:                	U1MODEbits.RTSMD = 0; // pin is in flow control mode
002712  A96221     BCLR 0x221, #3
82:                	U1STA = 0x0400; //Enable transmit
002714  204000     MOV #0x400, W0
002716  881110     MOV W0, U1STA
83:                	UART_RX_IF = 0; //Clear UART interrupt flags
002718  A96085     BCLR 0x85, #3
84:                	UART_ER_IF = 0;
00271A  A9208C     BCLR IFS4, #1
85:                	UART_RX_IE = 1; //Enable UART Receive and Error interrupt
00271C  A86095     BSET 0x95, #3
86:                	UART_ER_IE = 1;
00271E  A8209C     BSET IEC4, #1
87:                }
002720  060000     RETURN
88:                
89:                //**********************************************************************************************************************
90:                // Start transmission by enabling the UART transmit interrupt
91:                
92:                inline void UART_TxStart(void)
93:                {
94:                	UART_TX_IE = 1; //Enable transmit interrupts
002722  A88095     BSET 0x95, #4
95:                }
002724  060000     RETURN
96:                
97:                //**********************************************************************************************************************
98:                // See if there are one or more bytes in the receive buffer
99:                
100:               bool UART_IsNewRxData(void)
101:               {
102:               	__builtin_disi(0x3FFF); //disable interrupts
002726  FC3FFF     DISI #0x3FFF
103:               	if (rxBuf.byteCount == 0) { //Check if data in buffer
002728  E20954     CP0 0x954
00272A  3A0003     BRA NZ, .L4
104:               		__builtin_disi(0); //enable interrupts
00272C  FC0000     DISI #0x0
105:               		return(false); //No bytes in the buffer so return false
00272E  EB4000     CLR.B W0
002730  370002     BRA .L5
106:               	}
107:               	__builtin_disi(0); //enable interrupts
002732  FC0000     DISI #0x0
108:               	return(true); //There are bytes in the buffer
002734  B3C010     MOV.B #0x1, W0
109:               }
002736  060000     RETURN
110:               
111:               //**********************************************************************************************************************
112:               // Read a byte from the receive buffer
113:               
114:               uint8_t UART_ReadRxBuffer(void)
115:               {
116:               	uint8_t Temp;
117:               
118:               	__builtin_disi(0x3FFF); //disable interrupts
002738  FC3FFF     DISI #0x3FFF
119:               	if (rxBuf.byteCount == 0) { //For safety, do not allow read of empty buffer
00273A  E20954     CP0 0x954
00273C  3A0003     BRA NZ, .L7
120:               		__builtin_disi(0); //enable interrupts
00273E  FC0000     DISI #0x0
121:               		return(0); //Return zero if there is nothing in the buffer
002740  EB4000     CLR.B W0
002742  37000A     BRA .L8
122:               	}
123:               
124:               	rxBuf.byteCount--; //Decrement byte count
002744  ED2954     DEC 0x954
125:               	__builtin_disi(0); //enable interrupts
002746  FC0000     DISI #0x0
126:               	Temp = *rxBuf.tail++; //Get the byte and increment the pointer
002748  804A91     MOV 0x952, W1
00274A  784031     MOV.B [W1++], W0
00274C  884A91     MOV W1, 0x952
127:               	if (rxBuf.tail > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if at end of buffer
00274E  2094F2     MOV #0x94F, W2
002750  508F82     SUB W1, W2, [W15]
002752  360002     BRA LEU, .L8
128:               		rxBuf.tail = &rxBuf.buffer[0]; //then wrap the pointer to beginning
002754  208501     MOV #0x850, W1
002756  884A91     MOV W1, 0x952
129:               	}
130:               	return(Temp);
131:               }
002758  060000     RETURN
132:               
133:               //**********************************************************************************************************************
134:               // Write a byte to the transmit buffer
135:               
136:               void UART_WriteTxBuffer(const uint8_t TxByte)
137:               {
138:               	*txBuf.head++ = TxByte; //Put the byte in the transmit buffer and increment the pointer
00275A  8052B1     MOV .L94, W1
00275C  785880     MOV.B W0, [W1++]
00275E  8852B1     MOV W1, .L94
139:               	if (txBuf.head > &txBuf.buffer[SIZE_TxBuffer - 1]) { //Check if at end of buffer
002760  20A550     MOV #0xA55, W0
002762  508F80     SUB W1, W0, [W15]
002764  360002     BRA LEU, .L10
140:               		txBuf.head = &txBuf.buffer[0]; //Wrap pointer to beginning
002766  209560     MOV #0x956, W0
002768  8852B0     MOV W0, .L94
141:               	}
142:               	__builtin_disi(0x3FFF); //disable interrupts
00276A  FC3FFF     DISI #0x3FFF
143:               	if (txBuf.byteCount < SIZE_TxBuffer) { //Increment byte count
00276C  200FF0     MOV #0xFF, W0
00276E  E30A5A     CP 0xA5A
002770  3E0001     BRA GTU, .L11
144:               		txBuf.byteCount++;
002772  EC2A5A     INC 0xA5A
145:               	}
146:               	__builtin_disi(0); //enable interrupts
002774  FC0000     DISI #0x0
147:               }
002776  060000     RETURN
148:               
149:               //**********************************************************************************************************************
150:               // Return the number of bytes free in the TX buffer
151:               
152:               uint16_t UART_GetTXBufferFreeSpace(void)
153:               {
154:               	uint16_t space;
155:               
156:               	__builtin_disi(0x3FFF); //disable interrupts            
002778  FC3FFF     DISI #0x3FFF
157:               	space = SIZE_TxBuffer - txBuf.byteCount;
00277A  8052D0     MOV 0xA5A, W0
00277E  201001     MOV #0x100, W1
002780  508000     SUB W1, W0, W0
158:               	__builtin_disi(0); //enable interrupts
00277C  FC0000     DISI #0x0
159:               	return space;
160:               }
002782  060000     RETURN
161:               
162:               //Peek at buffer tail
163:               
164:               uint8_t UART_PeekRxBuffer(void)
165:               {
166:               	__builtin_disi(0x3FFF); //disable interrupts
002784  FC3FFF     DISI #0x3FFF
167:               	if (rxBuf.byteCount == 0) { //Check if pointers are the same
002786  E20954     CP0 0x954
002788  3A0003     BRA NZ, .L14
168:               		__builtin_disi(0); //enable interrupts
00278A  FC0000     DISI #0x0
169:               		return(NULL); //No bytes in the buffer so return NULL
00278C  EB4000     CLR.B W0
00278E  370003     BRA .L15
170:               	} else {
171:               		__builtin_disi(0); //enable interrupts
002790  FC0000     DISI #0x0
172:               		return *rxBuf.tail;
002792  804A90     MOV 0x952, W0
002794  784010     MOV.B [W0], W0
173:               	}
174:               }
002796  060000     RETURN
175:               
176:               //**********************************************************************************************************************
177:               // Interrupt routine for UART receive interrupts
178:               
179:               void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt(void)
180:               {
0002F8  BE9F80     MOV.D W0, [W15++]
181:               	UART_RX_IF = 0; //Clear UART Receive interrupt flag
0002FA  A96085     BCLR 0x85, #3
182:               	*rxBuf.head++ = UART_RX_BUF; //Put received byte in the buffer
0002FC  801131     MOV U1RXREG, W1
0002FE  804A80     MOV 0x950, W0
000300  785801     MOV.B W1, [W0++]
000302  884A80     MOV W0, 0x950
183:               	if (rxBuf.head > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if end of buffer
000304  2094F1     MOV #0x94F, W1
000306  500F81     SUB W0, W1, [W15]
000308  360002     BRA LEU, .L17
184:               		rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
00030A  208500     MOV #0x850, W0
00030C  884A80     MOV W0, 0x950
185:               	}
186:               	if (rxBuf.byteCount < SIZE_RxBuffer) { //Increment byte count
00030E  200FF0     MOV #0xFF, W0
000310  E30954     CP 0x954
000312  3E0001     BRA GTU, .L16
187:               		rxBuf.byteCount++;
000314  EC2954     INC 0x954
188:               	}
189:               }
000316  BE004F     MOV.D [--W15], W0
000318  064000     RETFIE
190:               
191:               //**********************************************************************************************************************
192:               // Interrupt routine for UART transmit interrupts
193:               
194:               void __attribute__((interrupt, no_auto_psv)) _U1TXInterrupt(void)
195:               {
00031A  BE9F80     MOV.D W0, [W15++]
196:               	if (txBuf.byteCount > 0) //Check if more data is in the buffer
00031C  E20A5A     CP0 0xA5A
00031E  32000E     BRA Z, .L20
197:               	{
198:               		//Only do anything if hardware buffer has space
199:               		if (!UART_FULL) {
000320  AB2223     BTST 0x223, #1
000322  3A000D     BRA NZ, .L19
200:               			UART_TX_IF = 0; //Clear UART 1 TX interrupt flag
000324  A98085     BCLR 0x85, #4
201:               			UART_TX_BUF = *txBuf.tail++; //Load next byte into the TX buffer
000326  8052C0     MOV 0xA58, W0
000328  FB80B0     ZE [W0++], W1
00032A  881121     MOV W1, U1TXREG
00032C  8852C0     MOV W0, 0xA58
202:               			if (txBuf.tail > &txBuf.buffer[SIZE_TxBuffer - 1]) { //Check if end of buffer
00032E  20A551     MOV #0xA55, W1
000330  500F81     SUB W0, W1, [W15]
000332  360002     BRA LEU, .L22
203:               				txBuf.tail = &txBuf.buffer[0]; //Wrap pointer to beginning
000334  209560     MOV #0x956, W0
000336  8852C0     MOV W0, 0xA58
204:               			}
205:               			txBuf.byteCount--; //Decrement byte count
000338  ED2A5A     DEC 0xA5A
00033A  370001     BRA .L19
206:               		}
207:               	} else {
208:               		UART_TX_IE = 0; //No more data to transmit, so stop interrupts
00033C  A98095     BCLR 0x95, #4
209:               	}
210:               }
00033E  BE004F     MOV.D [--W15], W0
000340  064000     RETFIE
211:               
212:               //**********************************************************************************************************************
213:               // Interrupt routine for UART error interrupts
214:               
215:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void)
216:               {
000342  BE9F80     MOV.D W0, [W15++]
217:               	IFS4bits.U1ERIF = 0; //Clear interrupt flag
000344  A9208C     BCLR IFS4, #1
218:               
219:               	//Handle an overflow error by reading next byte and clearing flag
220:               	if (U1STAbits.OERR == 1) {
000346  AB2222     BTST U1STA, #1
000348  32000E     BRA Z, .L24
221:               		*rxBuf.head++ = UART_RX_BUF; //Put received byte in the buffer
00034A  801131     MOV U1RXREG, W1
00034C  804A80     MOV 0x950, W0
00034E  785801     MOV.B W1, [W0++]
000350  884A80     MOV W0, 0x950
222:               		if (rxBuf.head > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if end of buffer
000352  2094F1     MOV #0x94F, W1
000354  500F81     SUB W0, W1, [W15]
000356  360002     BRA LEU, .L25
223:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
000358  208500     MOV #0x850, W0
00035A  884A80     MOV W0, 0x950
224:               		}
225:               		if (rxBuf.byteCount < SIZE_RxBuffer) { //Increment byte count
00035C  200FF0     MOV #0xFF, W0
00035E  E30954     CP 0x954
000360  3E0001     BRA GTU, .L26
226:               			rxBuf.byteCount++;
000362  EC2954     INC 0x954
227:               		}
228:               		U1STAbits.OERR = 0;
000364  A92222     BCLR U1STA, #1
229:               	}
230:               
231:               	//Clear any other error bits
232:               	U1STAbits.FERR = 0;
000366  A94222     BCLR U1STA, #2
233:               	U1STAbits.PERR = 0;
000368  A96222     BCLR U1STA, #3
234:               }
00036A  BE004F     MOV.D [--W15], W0
00036C  064000     RETFIE
---  /root/ble/fac_relay_clone/timers.c  ----------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        timers.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Timer functions
33:                 *
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdbool.h>
39:                #include "config.h"
40:                #include "timers.h"
41:                #include "app.h"
42:                
43:                extern APP_DATA appData;
44:                
45:                static volatile uint16_t tickCount[TMR_COUNT] = {0};
46:                
47:                //**********************************************************************************************************************
48:                // Initialize the timers
49:                
50:                void Timers_Init(void)
51:                {
52:                	//Timer 1 is used for interrupt based software timers counting 1ms intervals to a resolution of 500us
53:                	T1CON = TIMER_OFF; //Timer 1 off
002830  EF2104     CLR T1CON
54:                	TMR1 = 0; //Clear timer 1
002832  EF2100     CLR TMR1
55:                	PR1 = TIMER_500US_PERIOD; //Set the period value for 500us
002834  21F3F0     MOV #0x1F3F, W0
002836  880810     MOV W0, PR1
56:                	T1CON |= TIMER_ON_PRESCALE1; //using 1:1 prescaler and turn on timer 1
002838  A8E105     BSET 0x105, #7
57:                	IFS0bits.T1IF = 0; //Clear the interrupt flag
00283A  A96084     BCLR IFS0, #3
58:                	IEC0bits.T1IE = 1; //Enable the timer 1 interrupt
00283C  A86094     BSET IEC0, #3
59:                
60:                #ifdef USE_SLEEP                //see config.h, Application setting section
61:                	//Timer 2/3 is used in 32-bit mode as inactivity timer to trigger sleep mode
62:                	T2CON = TIMER_OFF; //Timer 3 off
63:                	TMR3 = 0; //Clear timer 3
64:                	TMR2 = 0; //Clear timer 2
65:                	T2CONbits.T32 = 1; //Enable 32-bit mode
66:                	PR3 = (uint16_t) (SLEEP_TIME >> 16); //Set the period value - msw
67:                	PR2 = (uint16_t) (SLEEP_TIME | 0x0000FFFF); //lsw
68:                	T2CON |= TIMER_ON_PRESCALE256; //using 1:256 prescaler and turn on timer 3
69:                	IFS0bits.T3IF = 0; //Clear the interrupt flag
70:                	IEC0bits.T3IE = 1; //Enable the timer 3 interrupt
71:                
72:                #ifndef SLEEP_MODE_RTCC         //we'll be using Timer 1 for periodic wakeup
73:                	T1CON = 0x0000; //Timer 1 off
74:                	T1CONbits.T1ECS = 0b10; //Clock source LPRC
75:                	T1CONbits.TCS = 1;
76:                	T1CONbits.TCKPS = 0b11; //using 1:256 prescaler
77:                	TMR1 = 0; //Clear timer 1
78:                	PR1 = T1_SLEEP_PERIOD; //Set the period for sleep
79:                	IFS0bits.T1IF = 0; //Clear the interrupt flag
80:                	IEC0bits.T1IE = 1; //Enable the timer 1 interrupt
81:                #endif //not SLEEP_MODE_RTCC    
82:                #endif //USE_SLEEP
83:                }
00283E  060000     RETURN
84:                
85:                //**********************************************************************************************************************
86:                // Start one of the software timers
87:                
88:                inline void StartTimer(uint8_t timer, uint16_t count)
89:                {
90:                	tickCount[timer] = count << 1; //Interrupt is every 500us but StartTimer() takes multiple of 1ms so multiply by 2
002840  FB8000     ZE W0, W0
002842  400000     ADD W0, W0, W0
002844  20C9E2     MOV #0xC9E, W2
002846  410000     ADD W2, W0, W0
002848  408801     ADD W1, W1, [W0]
91:                }
00284A  060000     RETURN
92:                
93:                //**********************************************************************************************************************
94:                // Check if one of the software software timers has timed out
95:                
96:                inline bool TimerDone(uint8_t timer)
002854  A7F000     BTSC W0, #15
002856  EA0000     NEG W0, W0
002858  E90000     DEC W0, W0
00285A  DE004F     LSR W0, #15, W0
97:                {
98:                	if (tickCount[timer] == 0) { //Check if counted down to zero
00284C  FB8000     ZE W0, W0
00284E  400000     ADD W0, W0, W0
002850  20C9E1     MOV #0xC9E, W1
002852  780061     MOV [W1+W0], W0
99:                		return true; //then return true
100:               	}
101:               	return false; //else return false
102:               }
00285C  060000     RETURN
103:               
104:               //**********************************************************************************************************************
105:               // Simple delay for n milliseconds (blocking)
106:               
107:               void WaitMs(uint16_t numMilliseconds)
108:               {
00285E  781F88     MOV W8, [W15++]
109:               	StartTimer(TMR_INTERNAL, numMilliseconds); //Start software timer and wait for it to count down
002860  780080     MOV W0, W1
002862  EB4000     CLR.B W0
002864  07FFED     RCALL StartTimer
110:               	while (!TimerDone(TMR_INTERNAL)) {
002866  EB4400     CLR.B W8
002868  370001     BRA .L5
00286C  784008     MOV.B W8, W0
00286E  07FFEE     RCALL TimerDone
002870  E00400     CP0.B W0
002872  32FFFB     BRA Z, .L6
111:               		Idle();
00286A  FE4001     PWRSAV #1
112:               	} //Enter idle mode to reduce power while waiting
113:               } //(timer interrupt will wake part from idle)
002874  78044F     MOV [--W15], W8
002876  060000     RETURN
114:               
115:               #ifdef USE_SLEEP                //see config.h, Application setting section
116:               //Reset the inactivity sleep timer
117:               
118:               inline void SleepTimerReset(void)
119:               {
120:               	TMR3 = 0; //Clear timer 3
121:               	TMR2 = 0; //Clear timer 2
122:               }
123:               #endif
124:               
125:               //**********************************************************************************************************************
126:               // Timer 1 interrupt routine - software timers
127:               
128:               void _ISR_NO_AUTO_PSV _T1Interrupt(void)
129:               {
0002D0  BE9F80     MOV.D W0, [W15++]
0002D2  BE9F82     MOV.D W2, [W15++]
130:               	uint8_t i;
131:               
132:               	IFS0bits.T1IF = 0; //Clear the interrupt flag
0002D4  A96084     BCLR IFS0, #3
0002D6  EB0000     CLR W0
133:               	//Decrement each software timer
134:               	for (i = 0; i < TMR_COUNT; i++) {
0002EE  500FF1     SUB W0, #0x11, [W15]
0002F0  3AFFF3     BRA NZ, .L9
135:               		if (tickCount[i] != 0) {
0002D8  400100     ADD W0, W0, W2
0002DA  20C9E3     MOV #0xC9E, W3
0002DC  790163     MOV [W3+W2], W2
0002DE  E00002     CP0 W2
0002E0  320005     BRA Z, .L8
136:               			tickCount[i]--;
0002E2  400080     ADD W0, W0, W1
0002E4  780103     MOV W3, W2
0002E6  7881E2     MOV [W2+W1], W3
0002E8  410081     ADD W2, W1, W1
0002EA  E90883     DEC W3, [W1]
0002EC  E80000     INC W0, W0
137:               		}
138:               	}
139:               }
0002F2  BE014F     MOV.D [--W15], W2
0002F4  BE004F     MOV.D [--W15], W0
0002F6  064000     RETFIE
140:               
141:               #ifdef USE_SLEEP                //see config.h, Application setting section
142:               //**********************************************************************************************************************
143:               // Timer 3 interrupt routine - inactivity timer
144:               
145:               void _ISR_NO_AUTO_PSV _T3Interrupt(void)
146:               {
147:               	IFS0bits.T3IF = 0; //Clear the interrupt flag    
148:               	appData.sleepFlag = true;
149:               }
150:               #ifndef SLEEP_MODE_RTCC
151:               //**********************************************************************************************************************
152:               // Timer 1 interrupt routine - periodic wakeup timer
153:               
154:               void _ISR_NO_AUTO_PSV _T1Interrupt(void)
155:               {
156:               	IFS0bits.T1IF = 0; //Clear the interrupt flag
157:               	appData.timer1Flag = true;
158:               }
159:               #endif //not SLEEP_MODE_RTCC
160:               #endif //USE_SLEEP
---  /root/ble/fac_relay_clone/switches.c  --------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2015 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        switches.c
29:                 * Date:        September 17, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 *
33:                 */
34:                
35:                #include <xc.h>
36:                #include "app.h"
37:                #include "config.h"
38:                #include "timers.h"
39:                
40:                extern APP_DATA appData;
41:                
42:                //Switches state machine
43:                
44:                void Switch_Tasks(void)
45:                {
46:                	//Check if switches have changed and debounce timers are expired
47:                	if (appData.sw1Changed && TimerDone(TMR_SW1_DEBOUNCE)) {
0027E6  E24B39     CP0.B 0xB39
0027E8  320007     BRA Z, .L2
0027EA  B3C050     MOV.B #0x5, W0
0027EC  07002F     RCALL TimerDone
0027EE  E00400     CP0.B W0
0027F0  320003     BRA Z, .L2
48:                
49:                		appData.sw1Changed = false; //clear individual flag
0027F2  EF6B39     CLR.B 0xB39
50:                		appData.sendSwitches = true; //set group flag to request TX
0027F4  B3C010     MOV.B #0x1, W0
0027F6  B7EB28     MOV.B WREG, 0xB28
51:                	}
52:                	if (appData.sw2Changed && TimerDone(TMR_SW2_DEBOUNCE)) {
0027F8  E24B3A     CP0.B 0xB3A
0027FA  320007     BRA Z, .L3
0027FC  B3C060     MOV.B #0x6, W0
0027FE  070026     RCALL TimerDone
002800  E00400     CP0.B W0
002802  320003     BRA Z, .L3
53:                
54:                		appData.sw2Changed = false;
002804  EF6B3A     CLR.B 0xB3A
55:                		appData.sendSwitches = true;
002806  B3C010     MOV.B #0x1, W0
002808  B7EB28     MOV.B WREG, 0xB28
56:                	}
57:                	if (appData.sw3Changed && TimerDone(TMR_SW3_DEBOUNCE)) {
00280A  E24B3B     CP0.B 0xB3B
00280C  320007     BRA Z, .L4
00280E  B3C070     MOV.B #0x7, W0
002810  07001D     RCALL TimerDone
002812  E00400     CP0.B W0
002814  320003     BRA Z, .L4
58:                
59:                		appData.sw3Changed = false;
002816  EF6B3B     CLR.B 0xB3B
60:                		appData.sendSwitches = true;
002818  B3C010     MOV.B #0x1, W0
00281A  B7EB28     MOV.B WREG, 0xB28
61:                	}
62:                	if (appData.sw4Changed && TimerDone(TMR_SW4_DEBOUNCE)) {
00281C  E24B3C     CP0.B 0xB3C
00281E  320007     BRA Z, .L1
002820  B3C080     MOV.B #0x8, W0
002822  070014     RCALL TimerDone
002824  E00400     CP0.B W0
002826  320003     BRA Z, .L1
63:                
64:                		appData.sw4Changed = false;
002828  EF6B3C     CLR.B 0xB3C
65:                		appData.sendSwitches = true;
00282A  B3C010     MOV.B #0x1, W0
00282C  B7EB28     MOV.B WREG, 0xB28
66:                	}
67:                }
00282E  060000     RETURN
68:                
69:                //Change notification interrupt
70:                //Process and start debounce timers for switch changes
71:                //The switches are well debounced in hardware
72:                //Adding the software debounce limits unneeded switch update messages
73:                //and groups together multiple switch presses that occur within the debounce period
74:                
75:                void _ISR_NO_AUTO_PSV _CNInterrupt(void)
76:                {
77:                	IFS1bits.CNIF = 0; //Clear IF
0002CC  A96086     BCLR IFS1, #3
78:                
79:                #ifdef USE_SLEEP                //see config.h, Application setting section
80:                	appData.CNint = true;
81:                	SleepTimerReset(); //Reset the inactivity sleep timer
82:                #endif
83:                
84:                }
0002CE  064000     RETFIE
---  /root/ble/fac_relay_clone/spi.c  -------------------------------------------------------------------
1:                 /* SPI Master Driver */
2:                 
3:                 #include <xc.h>
4:                 #include <stdint.h>
5:                 #include <stdbool.h>
6:                 #include <stddef.h>
7:                 #include "spi.h"
8:                 #include "config.h"
9:                 
10:                //SPI receive buffer type
11:                
12:                typedef struct {
13:                	volatile uint8_t buffer[SIZE_SPI_Buffer];
14:                	volatile uint8_t volatile *head;
15:                	volatile uint8_t *tail;
16:                	volatile uint16_t byteCount;
17:                } SPI_RX_BUFFER_T;
18:                
19:                //SPI transmit buffer type
20:                
21:                typedef struct {
22:                	volatile uint8_t buffer[SIZE_SPI_Buffer];
23:                	volatile uint8_t *head;
24:                	volatile uint8_t volatile *tail;
25:                	volatile uint16_t byteCount;
26:                } SPI_TX_BUFFER_T;
27:                
28:                //Buffer instances
29:                static SPI_RX_BUFFER_T rxBuf;
30:                static SPI_TX_BUFFER_T txBuf;
31:                
32:                void SPI_Init(void)
33:                {
34:                	SPI_SDO = 0;
00250A  A9C2C8     BCLR TRISB, #6
35:                	SPI_SCK = 0;
00250C  A9A2C8     BCLR TRISB, #5
36:                	SPI_SDI = 1;
00250E  A8E2C0     BSET TRISA, #7
37:                	SPI_CS0 = 1;
002510  A862C4     BSET LATA, #3
38:                	SPI_CS1 = 1;
002512  A8E2CD     BSET 0x2CD, #7
39:                	rxBuf.tail = &rxBuf.buffer[0]; //Initialize the pointers
002514  20B720     MOV #0xB72, W0
002516  885DA0     MOV W0, 0xBB4
40:                	rxBuf.head = &rxBuf.buffer[0];
002518  885D90     MOV W0, 0xBB2
41:                	txBuf.tail = &txBuf.buffer[0];
00251A  20BB80     MOV #0xBB8, W0
00251C  885FD0     MOV W0, 0xBFA
42:                	txBuf.head = &txBuf.buffer[0];
00251E  885FC0     MOV W0, 0xBF8
43:                	txBuf.byteCount = 0;
002520  EF2BFC     CLR 0xBFC
44:                	rxBuf.byteCount = 0;
002522  EF2BB6     CLR 0xBB6
45:                	SPI_X_IF = 0; //Clear SPI interrupt flags
002524  A9208A     BCLR IFS3, #1
46:                	SPI_E_IF = 0;
002526  A9408A     BCLR IFS3, #2
47:                	SPI_X_IE = 0; //Setup SPI Receive and Error interrupt
002528  A9209A     BCLR IEC3, #1
48:                	SPI_E_IE = 1;
00252A  A8409A     BSET IEC3, #2
49:                }
00252C  060000     RETURN
50:                
51:                void SPI_Speed(const uint8_t speed)
52:                {
53:                	switch (speed) {
00252E  504FE1     SUB.B W0, #0x1, [W15]
002530  3A0005     BRA NZ, .L6
54:                	case 1:
55:                		SSP2CON1bits.SSPM = 1; // SPI MASTER SCK speed 16MHz
002532  2FFF00     MOV #0xFFF0, W0
002534  B60212     AND SSP2CON1, WREG
002536  A00000     BSET W0, #0
002538  881090     MOV W0, SSP2CON1
56:                		break;
00253A  370004     BRA .L2
57:                	default:
58:                		SSP2CON1bits.SSPM = 2; // SPI MASTER SCK speed 1MHz
00253C  2FFF00     MOV #0xFFF0, W0
00253E  B60212     AND SSP2CON1, WREG
002540  A01000     BSET W0, #1
002542  881090     MOV W0, SSP2CON1
59:                		break;
60:                	}
61:                }
002544  060000     RETURN
62:                
63:                void SPI_ClearBufs(void)
64:                {
65:                	__builtin_disi(0x3FFF); //disable interrupts
002546  FC3FFF     DISI #0x3FFF
66:                	rxBuf.tail = &rxBuf.buffer[0]; //Initialize the pointers
002548  20B720     MOV #0xB72, W0
00254A  885DA0     MOV W0, 0xBB4
67:                	rxBuf.head = &rxBuf.buffer[0];
00254C  885D90     MOV W0, 0xBB2
68:                	txBuf.tail = &txBuf.buffer[0];
00254E  20BB80     MOV #0xBB8, W0
002550  885FD0     MOV W0, 0xBFA
69:                	txBuf.head = &txBuf.buffer[0];
002552  885FC0     MOV W0, 0xBF8
70:                	txBuf.byteCount = 0;
002554  EF2BFC     CLR 0xBFC
71:                	rxBuf.byteCount = 0;
002556  EF2BB6     CLR 0xBB6
72:                	__builtin_disi(0); //enable interrupts
002558  FC0000     DISI #0x0
73:                }
00255A  060000     RETURN
74:                
75:                void SPI_TxStart(void)
76:                {
77:                	__builtin_disi(0x3FFF); //disable interrupts
00255C  FC3FFF     DISI #0x3FFF
78:                	if (txBuf.byteCount) { // prime the transmit interrupt
00255E  E20BFC     CP0 0xBFC
002560  32000E     BRA Z, .L9
79:                		/* write data here */
80:                		SPI_X_IF = 0; //Clear interrupt flag
002562  A9208A     BCLR IFS3, #1
81:                		SPI_BUF = *txBuf.tail++; //Load next byte into the TX buffer
002564  805FD0     MOV 0xBFA, W0
002566  FB80B0     ZE [W0++], W1
002568  881081     MOV W1, SSP2BUF
00256A  885FD0     MOV W0, 0xBFA
82:                		if (txBuf.tail > &txBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
00256C  20BF71     MOV #0xBF7, W1
00256E  500F81     SUB W0, W1, [W15]
002570  360002     BRA LEU, .L10
83:                			txBuf.tail = &txBuf.buffer[0]; //Wrap pointer to beginning
002572  20BB80     MOV #0xBB8, W0
002574  885FD0     MOV W0, 0xBFA
84:                		}
85:                		txBuf.byteCount--; //Decrement byte count
002576  ED2BFC     DEC 0xBFC
86:                		SPI_X_IE = 1; //Enable transmit interrupts
002578  A8209A     BSET IEC3, #1
87:                		__builtin_disi(0); //enable interrupts
00257A  FC0000     DISI #0x0
88:                		return;
00257C  370001     BRA .L8
89:                	}
90:                	__builtin_disi(0); //enable interrupts
00257E  FC0000     DISI #0x0
91:                	return;
92:                }
002580  060000     RETURN
93:                
94:                bool SPI_IsNewRxData(void)
95:                {
96:                	__builtin_disi(0x3FFF); //disable interrupts
002582  FC3FFF     DISI #0x3FFF
97:                	if (rxBuf.byteCount == 0) { //Check if data in buffer
002584  E20BB6     CP0 0xBB6
002586  3A0003     BRA NZ, .L13
98:                		__builtin_disi(0); //enable interrupts
002588  FC0000     DISI #0x0
99:                		return(false); //No bytes in the buffer so return false
00258A  EB4000     CLR.B W0
00258C  370002     BRA .L14
100:               	}
101:               	__builtin_disi(0); //enable interrupts
00258E  FC0000     DISI #0x0
102:               	return(true); //There are bytes in the buffer
002590  B3C010     MOV.B #0x1, W0
103:               }
002592  060000     RETURN
104:               
105:               uint8_t SPI_ReadRxBuffer(void)
106:               {
107:               	uint8_t Temp;
108:               
109:               	__builtin_disi(0x3FFF); //disable interrupts
002594  FC3FFF     DISI #0x3FFF
110:               	if (rxBuf.byteCount == 0) { //For safety, do not allow read of empty buffer
002596  E20BB6     CP0 0xBB6
002598  3A0003     BRA NZ, .L16
111:               		__builtin_disi(0); //enable interrupts
00259A  FC0000     DISI #0x0
112:               		return(0); //Return zero if there is nothing in the buffer
00259C  EB4000     CLR.B W0
00259E  37000A     BRA .L17
113:               	}
114:               
115:               	rxBuf.byteCount--; //Decrement byte count
0025A0  ED2BB6     DEC 0xBB6
116:               	__builtin_disi(0); //enable interrupts
0025A2  FC0000     DISI #0x0
117:               	Temp = *rxBuf.tail++; //Get the byte and increment the pointer
0025A4  805DA1     MOV 0xBB4, W1
0025A6  784031     MOV.B [W1++], W0
0025A8  885DA1     MOV W1, 0xBB4
118:               	if (rxBuf.tail > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if at end of buffer
0025AA  20BB12     MOV #0xBB1, W2
0025AC  508F82     SUB W1, W2, [W15]
0025AE  360002     BRA LEU, .L17
119:               		rxBuf.tail = &rxBuf.buffer[0]; //then wrap the pointer to beginning
0025B0  20B721     MOV #0xB72, W1
0025B2  885DA1     MOV W1, 0xBB4
120:               	}
121:               	return(Temp);
122:               }
0025B4  060000     RETURN
123:               
124:               bool SPI_IsTxData(void)
125:               {
126:               	__builtin_disi(0x3FFF); //disable interrupts
0025B6  FC3FFF     DISI #0x3FFF
127:               	if (txBuf.byteCount == 0) { //Check if data in buffer
0025B8  E20BFC     CP0 0xBFC
0025BA  3A0003     BRA NZ, .L19
128:               		__builtin_disi(0); //enable interrupts
0025BC  FC0000     DISI #0x0
129:               		return(false); //No bytes in the buffer so return false
0025BE  EB4000     CLR.B W0
0025C0  370002     BRA .L20
130:               	}
131:               	__builtin_disi(0); //enable interrupts
0025C2  FC0000     DISI #0x0
132:               	return(true); //There are bytes in the buffer
0025C4  B3C010     MOV.B #0x1, W0
133:               }
0025C6  060000     RETURN
134:               
135:               void SPI_WriteTxBuffer(const uint8_t TxByte)
136:               {
137:               	*txBuf.head++ = TxByte; //Put the byte in the transmit buffer and increment the pointer
0025C8  805FC1     MOV 0xBF8, W1
0025CA  785880     MOV.B W0, [W1++]
0025CC  885FC1     MOV W1, 0xBF8
138:               	if (txBuf.head > &txBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if at end of buffer
0025CE  20BF70     MOV #0xBF7, W0
0025D0  508F80     SUB W1, W0, [W15]
0025D2  360002     BRA LEU, .L22
139:               		txBuf.head = &txBuf.buffer[0]; //Wrap pointer to beginning
0025D4  20BB80     MOV #0xBB8, W0
0025D6  885FC0     MOV W0, 0xBF8
140:               	}
141:               	__builtin_disi(0x3FFF); //disable interrupts
0025D8  FC3FFF     DISI #0x3FFF
142:               	if (txBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
0025DA  2003F0     MOV #0x3F, W0
0025DC  E30BFC     CP 0xBFC
0025DE  3E0001     BRA GTU, .L23
143:               		txBuf.byteCount++;
0025E0  EC2BFC     INC 0xBFC
144:               	}
145:               	__builtin_disi(0); //enable interrupts
0025E2  FC0000     DISI #0x0
146:               }
0025E4  060000     RETURN
147:               
148:               //**********************************************************************************************************************
149:               // Return the number of bytes free in the TX buffer
150:               
151:               uint16_t SPI_GetTXBufferFreeSpace(void)
152:               {
153:               	uint16_t space;
154:               
155:               	__builtin_disi(0x3FFF); //disable interrupts            
0025E6  FC3FFF     DISI #0x3FFF
156:               	space = SIZE_SPI_Buffer - txBuf.byteCount;
0025E8  805FE0     MOV 0xBFC, W0
0025EC  200401     MOV #0x40, W1
0025EE  508000     SUB W1, W0, W0
157:               	__builtin_disi(0); //enable interrupts
0025EA  FC0000     DISI #0x0
158:               	return space;
159:               }
0025F0  060000     RETURN
160:               
161:               //Peek at buffer tail
162:               
163:               uint8_t SPI_PeekRxBuffer(void)
164:               {
165:               	__builtin_disi(0x3FFF); //disable interrupts
0025F2  FC3FFF     DISI #0x3FFF
166:               	if (rxBuf.byteCount == 0) { //Check if pointers are the same
0025F4  E20BB6     CP0 0xBB6
0025F6  3A0003     BRA NZ, .L26
167:               		__builtin_disi(0); //enable interrupts
0025F8  FC0000     DISI #0x0
168:               		return(NULL); //No bytes in the buffer so return NULL
0025FA  EB4000     CLR.B W0
0025FC  370003     BRA .L27
169:               	} else {
170:               		__builtin_disi(0); //enable interrupts
0025FE  FC0000     DISI #0x0
171:               		return *rxBuf.tail;
002600  805DA0     MOV 0xBB4, W0
002602  784010     MOV.B [W0], W0
172:               	}
173:               }
002604  060000     RETURN
174:               
175:               void __attribute__((interrupt, no_auto_psv)) _MSSP2Interrupt(void)
176:               {
00036E  BE9F80     MOV.D W0, [W15++]
177:               	SPI_X_IF = 0; //Clear interrupt flag
000370  A9208A     BCLR IFS3, #1
178:               	if (txBuf.byteCount > 0) { //Check if more data is in the buffer
000372  E20BFC     CP0 0xBFC
000374  320018     BRA Z, .L29
179:               		/* read data HERE */
180:               		*rxBuf.head++ = SPI_BUF; //Put received byte in the buffer
000376  801081     MOV SSP2BUF, W1
000378  805D90     MOV 0xBB2, W0
00037A  785801     MOV.B W1, [W0++]
00037C  885D90     MOV W0, 0xBB2
181:               		if (rxBuf.head > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
00037E  20BB11     MOV #0xBB1, W1
000380  500F81     SUB W0, W1, [W15]
000382  360002     BRA LEU, .L30
182:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
000384  20B720     MOV #0xB72, W0
000386  885D90     MOV W0, 0xBB2
183:               		}
184:               		if (rxBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
000388  2003F0     MOV #0x3F, W0
00038A  E30BB6     CP 0xBB6
00038C  3E0001     BRA GTU, .L31
185:               			rxBuf.byteCount++;
00038E  EC2BB6     INC 0xBB6
186:               		}
187:               
188:               		/* write data here */
189:               		SPI_BUF = *txBuf.tail++; //Load next byte into the TX buffer
000390  805FD0     MOV 0xBFA, W0
000392  FB80B0     ZE [W0++], W1
000394  881081     MOV W1, SSP2BUF
000396  885FD0     MOV W0, 0xBFA
190:               		if (txBuf.tail > &txBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
000398  20BF71     MOV #0xBF7, W1
00039A  500F81     SUB W0, W1, [W15]
00039C  360002     BRA LEU, .L32
191:               			txBuf.tail = &txBuf.buffer[0]; //Wrap pointer to beginning
00039E  20BB80     MOV #0xBB8, W0
0003A0  885FD0     MOV W0, 0xBFA
192:               		}
193:               		txBuf.byteCount--; //Decrement byte count
0003A2  ED2BFC     DEC 0xBFC
0003A4  370010     BRA .L28
194:               	} else {
195:               		/* read data HERE */
196:               		*rxBuf.head++ = SPI_BUF; //Put received byte in the buffer
0003A6  801081     MOV SSP2BUF, W1
0003A8  805D90     MOV 0xBB2, W0
0003AA  785801     MOV.B W1, [W0++]
0003AC  885D90     MOV W0, 0xBB2
197:               		if (rxBuf.head > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
0003AE  20BB11     MOV #0xBB1, W1
0003B0  500F81     SUB W0, W1, [W15]
0003B2  360002     BRA LEU, .L34
198:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
0003B4  20B720     MOV #0xB72, W0
0003B6  885D90     MOV W0, 0xBB2
199:               		}
200:               		if (rxBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
0003B8  2003F0     MOV #0x3F, W0
0003BA  E30BB6     CP 0xBB6
0003BC  3E0001     BRA GTU, .L35
201:               			rxBuf.byteCount++;
0003BE  EC2BB6     INC 0xBB6
202:               		}
203:               		SPI_X_IE = 0; //No more data to transmit, so stop interrupts
0003C0  A9209A     BCLR IEC3, #1
204:               		SPI_CS0 = 1; // deselect all devices here
0003C2  A862C4     BSET LATA, #3
205:               		SPI_CS1 = 1;
0003C4  A8E2CD     BSET 0x2CD, #7
206:               	}
207:               }
0003C6  BE004F     MOV.D [--W15], W0
0003C8  064000     RETFIE
208:               
209:               void __attribute__((interrupt, no_auto_psv)) _MSSP2BCInterrupt(void)
210:               {
0003CA  BE9F80     MOV.D W0, [W15++]
211:               	SPI_E_IF = 0; //Clear interrupt flag
0003CC  A9408A     BCLR IFS3, #2
212:               
213:               	//Handle an overflow error by reading next byte and clearing flags
214:               	if (SSP2CON1bits.WCOL || SSP2CON1bits.SSPOV) {
0003CE  ABE212     BTST SSP2CON1, #7
0003D0  3A0002     BRA NZ, .L37
0003D2  ABC212     BTST SSP2CON1, #6
0003D4  32000F     BRA Z, .L36
215:               		*rxBuf.head++ = SPI_BUF; //Put received byte in the buffer
0003D6  801081     MOV SSP2BUF, W1
0003D8  805D90     MOV 0xBB2, W0
0003DA  785801     MOV.B W1, [W0++]
0003DC  885D90     MOV W0, 0xBB2
216:               		if (rxBuf.head > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
0003DE  20BB11     MOV #0xBB1, W1
0003E0  500F81     SUB W0, W1, [W15]
0003E2  360002     BRA LEU, .L39
217:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
0003E4  20B720     MOV #0xB72, W0
0003E6  885D90     MOV W0, 0xBB2
218:               		}
219:               		if (rxBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
0003E8  2003F0     MOV #0x3F, W0
0003EA  E30BB6     CP 0xBB6
0003EC  3E0001     BRA GTU, .L40
220:               			rxBuf.byteCount++;
0003EE  EC2BB6     INC 0xBB6
221:               		}
222:               		SSP2CON1bits.WCOL = 0;
0003F0  A9E212     BCLR SSP2CON1, #7
223:               		SSP2CON1bits.SSPOV = 0;
0003F2  A9C212     BCLR SSP2CON1, #6
224:               	}
225:               
226:               	//Clear any other error bits
227:               
228:               }
0003F4  BE004F     MOV.D [--W15], W0
0003F6  064000     RETFIE
---  /root/ble/fac_relay_clone/main.c  ------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        main.c
29:                 * Date:        Oct 27, 2016
30:                 * Compiler:    XC16 v1.26
31:                 * 
32:                 * Remote Relay mods Oct 2016 FGB@MCHP
33:                 * ported to PIC24FV 
34:                 * Version updates
35:                 * V2.1 DFU OTA mode added, input port shared with relay #4 output
36:                 *
37:                 */
38:                
39:                #include <xc.h>
40:                #include <stdint.h>
41:                #include "app.h"
42:                #include "config.h"
43:                #include "spi.h"
44:                #include "timers.h"
45:                
46:                void initBoard(void);
47:                
48:                // PIC24FV16KM202 Configuration Bit Settings
49:                
50:                // 'C' source line config statements
51:                
52:                // FBS
53:                #pragma config BWRP = OFF               // Boot Segment Write Protect (Disabled)
54:                #pragma config BSS = OFF                // Boot segment Protect (No boot program flash segment)
55:                
56:                // FGS
57:                #pragma config GWRP = OFF               // General Segment Write Protect (General segment may be written)
58:                #pragma config GCP = OFF                // General Segment Code Protect (No Protection)
59:                
60:                // FOSCSEL
61:                #pragma config FNOSC = FRCPLL           // Oscillator Select (Fast RC Oscillator with Postscaler and PLL Module (FRCDIV+PLL))
62:                #pragma config SOSCSRC = DIG            // SOSC Source Type (Digital Mode for use with external source)
63:                #pragma config LPRCSEL = HP             // LPRC Oscillator Power and Accuracy (High Power, High Accuracy Mode)
64:                #pragma config IESO = OFF               // Internal External Switch Over bit (Internal External Switchover mode disabled (Two-speed Start-up disabled))
65:                
66:                // FOSC
67:                #pragma config POSCMOD = NONE           // Primary Oscillator Configuration bits (Primary oscillator disabled)
68:                #pragma config OSCIOFNC = IO            // CLKO Enable Configuration bit (Port I/O enabled (CLKO disabled))
69:                #pragma config POSCFREQ = LS            // Primary Oscillator Frequency Range Configuration bits (Primary oscillator/external clock input frequency less than 100kHz)
70:                #pragma config SOSCSEL = SOSCLP         // SOSC Power Selection Configuration bits (Secondary Oscillator configured for low-power operation)
71:                #pragma config FCKSM = CSECME           // Clock Switching and Monitor Selection (Both Clock Switching and Fail-safe Clock Monitor are enabled)
72:                
73:                // FWDT
74:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscale Select bits (1:32768)
75:                #pragma config FWPSA = PR128            // WDT Prescaler bit (WDT prescaler ratio of 1:128)
76:                #pragma config FWDTEN = ON              // Watchdog Timer Enable bits (WDT enabled in hardware)
77:                #pragma config WINDIS = OFF             // Windowed Watchdog Timer Disable bit (Standard WDT selected(windowed WDT disabled))
78:                
79:                // FPOR
80:                #pragma config BOREN = BOR0             // Brown-out Reset Enable bits (Brown-out Reset disabled in hardware, SBOREN bit disabled)
81:                #pragma config RETCFG = OFF             //  (Retention regulator is not available)
82:                #pragma config PWRTEN = ON              // Power-up Timer Enable bit (PWRT enabled)
83:                #pragma config I2C1SEL = SEC            // Alternate I2C1 Pin Mapping bit (Use  Alternate ASCL1/ASDA1 Pins For I2C1)
84:                #pragma config BORV = V18               // Brown-out Reset Voltage bits (Brown-out Reset set to lowest voltage (1.8V))
85:                #pragma config MCLRE = ON               // MCLR Pin Enable bit (RA5 input pin disabled, MCLR pin enabled)
86:                
87:                // FICD
88:                #pragma config ICS = PGx1               // ICD Pin Placement Select bits (EMUC/EMUD share PGC1/PGD1)
89:                
90:                // #pragma config statements should precede project file includes.
91:                // Use project enums instead of #define for ON and OFF.
92:                
93:                //**********************************************************************************************************************
94:                // Main routine - start of executable code
95:                
96:                int main(void)
97:                {
98:                	initBoard(); //Initialize the pins and peripherals
0023FC  07FF81     RCALL initBoard
99:                
100:               	while (1) {
101:               		APP_Tasks();
0023FE  07FDEC     RCALL APP_Tasks
102:               		Idle(); //Idle until an interrupt is generated
002400  FE4001     PWRSAV #1
103:               		RCONbits.IDLE = 0;
002402  A94740     BCLR RCON, #2
104:               		ClrWdt();
002404  FE6000     CLRWDT
002406  37FFFB     BRA .L3
105:               	}
106:               
107:               	//End of while(1) main loop
108:               	return(true);
109:               }
110:               
111:               //**********************************************************************************************************************
112:               // Initialize the pins and peripherals
113:               
114:               void initBoard(void)
115:               { /****************************************************************************
116:               	 * Oscillator Init
117:               	 * Clocking is setup at 32MHz sys clock and to allow USB functionality
118:               	 * Self-tune on SOF is enabled if USB is enabled and connected to host
119:               	 ***************************************************************************/
120:               	// DOZEN disabled; DOZE 1:16; CPDIV 1:1; RCDIV FRC/1; PLLEN disabled; ROI disabled;
121:               	CLKDIVbits.RCDIV = 0;
002300  2F8FF1     MOV #0xF8FF, W1
002302  207440     MOV #0x744, W0
002304  608810     AND W1, [W0], [W0]
122:               	OSCCONbits.COSC = 0x1;
002306  28FFF0     MOV #0x8FFF, W0
002308  803A13     MOV OSCCON, W3
00230A  600103     AND W0, W3, W2
00230C  A0C002     BSET W2, #12
00230E  883A12     MOV W2, OSCCON
123:               	OSCCONbits.NOSC = 0x1;
002310  803A14     MOV OSCCON, W4
002312  608104     AND W1, W4, W2
002314  A08002     BSET W2, #8
002316  883A12     MOV W2, OSCCON
124:               
125:               	// STSRC USB; STEN enabled; STOR disabled; STORPOL Interrupt when STOR is 1; STLOCK disabled; STLPOL Interrupt when STLOCK is 1; STSIDL disabled; TUN Center frequency; 
126:               	OSCTUN = 0x0;
002318  EF2748     CLR OSCTUN
127:               
128:               	//Enable low voltage retention sleep mode
129:               	RCONbits.RETEN = 1;
00231A  A88741     BSET 0x741, #4
130:               
131:               	RCONbits.SWDTEN = 0;
00231C  A9A740     BCLR RCON, #5
132:               
133:               #ifdef SET_PMD_BITS    //see config.h, Application settings section
134:               	/****************************************************************************
135:               	 * PMD bits - setting a bit disables clocking to that peripheral
136:               	 * (drops operating current by about 2 mA when used in this app)
137:               	 ***************************************************************************/
138:               	PMD1bits.T4MD = 1;
139:               
140:               #if !defined (USE_SLEEP) || defined (SLEEP_MODE_RTCC)    //see config.h, Application settings section
141:               	PMD1bits.T1MD = 1;
142:               #endif
143:               
144:               	PMD1bits.I2C1MD = 1;
145:               	PMD1bits.U2MD = 1;
146:               	PMD1bits.SPI2MD = 1;
147:               	PMD1bits.SPI1MD = 1;
148:               	PMD3bits.TXMMD = 1;
149:               
150:               #if !defined (USE_SLEEP) || !defined (SLEEP_MODE_RTCC)    //see config.h, Application settings section
151:               	PMD3bits.RTCCMD = 1;
152:               #endif
153:               
154:               	PMD3bits.PMPMD = 1;
155:               	PMD3bits.CRCMD = 1;
156:               	PMD3bits.DAC1MD = 1;
157:               	PMD3bits.U3MD = 1;
158:               	PMD3bits.I2C2MD = 1;
159:               	PMD2 = 0xFFFF;
160:               	PMD4bits.UPWMMD = 1;
161:               	PMD4bits.U4MD = 1;
162:               	PMD4bits.REFOMD = 1;
163:               	PMD4bits.CTMUMD = 1;
164:               	PMD4bits.HLVDMD = 1;
165:               	PMD5 = 0xFFFF;
166:               	PMD6 = 0xFFFF;
167:               	PMD7 = 0xFFFF;
168:               #endif
169:               
170:               	/****************************************************************************
171:               	 * GPIO Init
172:               	 ***************************************************************************/
173:               	ANSA = 0x00;
00231E  EF24E0     CLR ANSA
174:               	ANSB = 0x00;
002320  EF24E2     CLR ANSB
175:               
176:               	CNPU1 = 0;
002322  EF206E     CLR CNPU1
177:               	CNPU2 = 0;
002324  EF2070     CLR CNPU2
178:               
179:               	CNPD1 = 0;
002326  EF2056     CLR CNPD1
180:               	CNPD2 = 0;
002328  EF2058     CLR CNPD2
181:               
182:               	CNEN1 = 0x0000;
00232A  EF2062     CLR CNEN1
183:               	CNEN2 = 0x0000;
00232C  EF2064     CLR CNEN2
184:               
185:               	ODCB = 0x0000;
00232E  EF22CE     CLR ODCB
186:               
187:               	//	IEC1bits.CNIE = 1;
188:               
189:               	// SSR are outputs and open-drain
190:               	ODCBbits.ODB13 = 1;
002330  A8A2CF     BSET 0x2CF, #5
191:               	ODCBbits.ODB12 = 1;
002332  A882CF     BSET 0x2CF, #4
192:               	ODCBbits.ODB4 = 1;
002334  A882CE     BSET ODCB, #4
193:               	ODCBbits.ODB3 = 1;
002336  A862CE     BSET ODCB, #3
194:               
195:               	// LEDs are outputs and off
196:               	RELAY1 = 1;
002338  A8A2CD     BSET 0x2CD, #5
197:               	RELAY2 = 1;
00233A  A882CD     BSET 0x2CD, #4
198:               	RELAY3 = 1;
00233C  A882CC     BSET LATB, #4
199:               	RELAY4 = 1;
00233E  A862CC     BSET LATB, #3
200:               	LED5 = 0;
002340  A902CC     BCLR LATB, #0
201:               	LED6 = 0;
002342  A902CC     BCLR LATB, #0
202:               	LED7 = 0;
002344  A902CC     BCLR LATB, #0
203:               	LED_TRIS1 = 0;
002346  A9A2C9     BCLR 0x2C9, #5
204:               	LED_TRIS2 = 0;
002348  A982C9     BCLR 0x2C9, #4
205:               	LED_TRIS3 = 0;
00234A  A982C8     BCLR TRISB, #4
206:               	LED_TRIS4 = 0;
00234C  A962C8     BCLR TRISB, #3
207:               	SLED = 0;
00234E  A9C2CD     BCLR 0x2CD, #6
208:               	SLED_TRIS = 0;
002350  A9C2C9     BCLR 0x2C9, #6
209:               
210:               	//RN4020 module - UART1
211:               	BT_WAKE_HW = 1; //Dormant line is set high
002352  A842CD     BSET 0x2CD, #2
212:               	BT_WAKE_HW_TRIS = 0; //Dormant line is output
002354  A942C9     BCLR 0x2C9, #2
213:               
214:               	BT_WAKE_SW = 0; //keep low until after UART is initialized
002356  A962CD     BCLR 0x2CD, #3
215:               	BT_WAKE_SW_TRIS = 0;
002358  A962C9     BCLR 0x2C9, #3
216:               
217:               	BT_CMD = 0; //Command mode on
00235A  A902C4     BCLR LATA, #0
218:               	BT_CMD_TRIS = 0;
00235C  A902C0     BCLR TRISA, #0
219:               
220:               	BT_WS_TRIS = 1;
00235E  A842C0     BSET TRISA, #2
221:               	BT_MLDP_EV_TRIS = 1;
002360  A882C0     BSET TRISA, #4
222:               	BT_CONNECTED_TRIS = 1;
002362  A822C0     BSET TRISA, #1
223:               
224:               	U1CTS_TRIS = 1;
002364  A802C9     BSET 0x2C9, #0
225:               	U1RX_TRIS = 1;
002366  A842C8     BSET TRISB, #2
226:               	U1RTS_LAT = 0;
002368  A922CD     BCLR 0x2CD, #1
227:               	U1RTS_TRIS = 0;
00236A  A922C9     BCLR 0x2C9, #1
228:               	U1TX_TRIS = 0;
00236C  A9E2C8     BCLR TRISB, #7
229:               
230:               	// SPI Master Devices
231:               	SPI_CS0_TRIS = 0;
00236E  A962C0     BCLR TRISA, #3
232:               	SPI_CS1_TRIS = 0;
002370  A9E2C9     BCLR 0x2C9, #7
233:               
234:               	/* SPI2 HW setup */
235:               	SSP2CON1bits.SSPM = 2; // SPI MASTER SCK speed
002372  2FFF02     MOV #0xFFF0, W2
002374  801093     MOV SSP2CON1, W3
002376  610103     AND W2, W3, W2
002378  A01002     BSET W2, #1
00237A  881092     MOV W2, SSP2CON1
236:               	SSP2CON1bits.CKP = 0; // SCK polarity mode 0,0
00237C  A98212     BCLR SSP2CON1, #4
237:               	SSP2STATbits.CKE = 0; // SCK select 
00237E  A9C218     BCLR SSP2STAT, #6
238:               	SSP2STATbits.SMP = 0; // sample mid
002380  A9E218     BCLR SSP2STAT, #7
239:               	SSP2CON1bits.SSPEN = 1; // enable spi ports
002382  A8A212     BSET SSP2CON1, #5
240:               	PADCFG1bits.SCK2DIS = 0;
002384  A942FD     BCLR 0x2FD, #2
241:               	PADCFG1bits.SDA2DIS = 0;
002386  A962FD     BCLR 0x2FD, #3
242:               
243:               	/****************************************************************************
244:               	 * PPS Init - Peripheral Pin Select
245:               	 * Click Boards using PPS-controlled peripherals will require additional
246:               	 * setup here
247:               	 ***************************************************************************/
248:               	__builtin_disi(0x3FFF); //disable interrupts
002388  FC3FFF     DISI #0x3FFF
249:               
250:               	//unlock registers
251:               	__builtin_write_OSCCONL(OSCCON & 0xBF);
00238A  200BF4     MOV #0xBF, W4
00238C  803A12     MOV OSCCON, W2
00238E  620202     AND W4, W2, W4
002390  200462     MOV #0x46, W2
002392  200573     MOV #0x57, W3
002394  207425     MOV #0x742, W5
002396  784A82     MOV.B W2, [W5]
002398  784A83     MOV.B W3, [W5]
00239A  784A84     MOV.B W4, [W5]
252:               
253:               	__builtin_write_OSCCONL(OSCCON | 0x40);
00239C  803A14     MOV OSCCON, W4
00239E  A06004     BSET W4, #6
0023A0  207425     MOV #0x742, W5
0023A2  784A82     MOV.B W2, [W5]
0023A4  784A83     MOV.B W3, [W5]
0023A6  784A84     MOV.B W4, [W5]
254:               
255:               	__builtin_disi(0); //enable interrupts
0023A8  FC0000     DISI #0x0
256:               
257:               	/****************************************************************************
258:               	 * Interrupt Priorities
259:               	 * Interrupt-enabled peripherals being used for Click Boards should be
260:               	 * configured here as well
261:               	 ***************************************************************************/
262:               
263:               	// SPI
264:               	// error
265:               	IPC12bits.BCL2IP = 6;
0023AA  8005E4     MOV IPC12, W4
0023AC  608184     AND W1, W4, W3
0023AE  206002     MOV #0x600, W2
0023B0  710103     IOR W2, W3, W2
0023B2  8805E2     MOV W2, IPC12
266:               	// spi_buf
267:               	IPC12bits.SSP2IP = 5;
0023B4  2FF8F2     MOV #0xFF8F, W2
0023B6  8005E4     MOV IPC12, W4
0023B8  610184     AND W2, W4, W3
0023BA  B30503     IOR #0x50, W3
0023BC  8805E3     MOV W3, IPC12
268:               
269:               	//    UERI: U1E - UART1 Error
270:               	//    Priority: 6
271:               	IPC16bits.U1ERIP = 6;
0023BE  800624     MOV IPC16, W4
0023C0  610184     AND W2, W4, W3
0023C2  B30603     IOR #0x60, W3
0023C4  880623     MOV W3, IPC16
272:               
273:               	//    UTXI: U1TX - UART1 Transmitter
274:               	//    Priority: 5
275:               	IPC3bits.U1TXIP = 5;
0023C6  2FFF83     MOV #0xFFF8, W3
0023C8  800554     MOV IPC3, W4
0023CA  618184     AND W3, W4, W3
0023CC  B30053     IOR #0x5, W3
0023CE  880553     MOV W3, IPC3
276:               
277:               	//    URXI: U1RX - UART1 Receiver
278:               	//    Priority: 5
279:               	IPC2bits.U1RXIP = 5;
0023D0  800543     MOV IPC2, W3
0023D2  600203     AND W0, W3, W4
0023D4  250003     MOV #0x5000, W3
0023D6  718184     IOR W3, W4, W3
0023D8  880543     MOV W3, IPC2
280:               
281:               
282:               	//    TI: T1 - Timer1
283:               	//    Priority: 3
284:               	IPC0bits.T1IP = 3;
0023DA  800523     MOV IPC0, W3
0023DC  600203     AND W0, W3, W4
0023DE  230003     MOV #0x3000, W3
0023E0  718184     IOR W3, W4, W3
0023E2  880523     MOV W3, IPC0
285:               
286:               	//    RTCI: RTCC - Real-Time Clock and Calendar
287:               	//    Priority: 2
288:               	IPC15bits.RTCIP = 2;
0023E4  800614     MOV IPC15, W4
0023E6  608084     AND W1, W4, W1
0023E8  A09001     BSET W1, #9
0023EA  880611     MOV W1, IPC15
289:               
290:               	//    CN: Switches - change notification
291:               	//    Priority: 2
292:               	IPC4bits.CNIP = 2;
0023EC  B600AC     AND IPC4, WREG
0023EE  A0D000     BSET W0, #13
0023F0  880560     MOV W0, IPC4
293:               
294:               	//    ADI: ADC1 - Pipeline A/D Converter 1
295:               	//    Priority: 1
296:               	IPC3bits.AD1IP = 1;
0023F2  800550     MOV IPC3, W0
0023F4  610100     AND W2, W0, W2
0023F6  A04002     BSET W2, #4
0023F8  880552     MOV W2, IPC3
297:               }
0023FA  060000     RETURN
---  /root/ble/fac_relay_clone/link.c  ------------------------------------------------------------------
1:                 #include <xc.h>
2:                 #include <string.h>
3:                 #include <stdint.h>
4:                 #include <stdio.h>
5:                 #include <stdbool.h>
6:                 #include "config.h"
7:                 #include "app.h"
8:                 #include "spi.h"
9:                 #include "link.h"
10:                
11:                static struct LINK_DATA l_data = {LINK_BYTES};
12:                
13:                bool Write_Link_Packet(const uint8_t *data, bool start)
0027AA  4404E7     ADD W8, #0x7, W9
14:                {
002798  BE9F88     MOV.D W8, [W15++]
00279A  781F8A     MOV W10, [W15++]
00279C  780400     MOV W0, W8
00279E  784501     MOV.B W1, W10
15:                	uint16_t i;
16:                
17:                	if (!SPI_IsTxData()) {
0027A0  07FF0A     RCALL SPI_IsTxData
0027A2  784080     MOV.B W0, W1
0027A6  E00401     CP0.B W1
0027A8  3A0013     BRA NZ, .L2
18:                		for (i = 0; i < LINK_BYTES; i++) { // start with SOF char then data bytes
0027B6  540F89     SUB W8, W9, [W15]
0027B8  3AFFF9     BRA NZ, .L3
19:                			if (SPI_GetTXBufferFreeSpace() < 2)
0027AC  07FF1C     RCALL SPI_GetTXBufferFreeSpace
0027AE  500FE1     SUB W0, #0x1, [W15]
0027B0  36000E     BRA LEU, .L5
20:                				return false;
0027CE  EB4000     CLR.B W0
21:                			SPI_WriteTxBuffer(*data++); //Load byte into the transmit buffer
0027B2  784038     MOV.B [W8++], W0
0027B4  07FF09     RCALL SPI_WriteTxBuffer
22:                		}
23:                		SPI_WriteTxBuffer(SPI_CHECKMARK); //checkmark for EOF
0027BA  B3C570     MOV.B #0x57, W0
0027BC  07FF05     RCALL SPI_WriteTxBuffer
24:                
25:                		if (start) {
0027C0  E0040A     CP0.B W10
0027C2  320006     BRA Z, .L2
26:                			SPI_Speed(1); // high speed
0027C4  07FEB4     RCALL SPI_Speed
27:                			SPI_CS1 = 0; // select the PIC slave
0027C6  A9E2CD     BCLR 0x2CD, #7
28:                			SPI_TxStart(); //Start transmitting the bytes
0027C8  07FEC9     RCALL SPI_TxStart
29:                		}
30:                		return true;
0027BE  B3C010     MOV.B #0x1, W0
0027CA  B3C010     MOV.B #0x1, W0
0027CC  370001     BRA .L2
31:                	} else
32:                		return false;
0027A4  EB4000     CLR.B W0
33:                }
0027D0  78054F     MOV [--W15], W10
0027D2  BE044F     MOV.D [--W15], W8
0027D4  060000     RETURN
34:                
35:                struct LINK_DATA* Read_Link_Packet(const uint8_t *data)
36:                {
37:                	return memcpy(&l_data, data, LINK_BYTES);
0027D6  20CC01     MOV #0xCC0, W1
0027D8  090006     REPEAT #0x6
0027DA  7858B0     MOV.B [W0++], [W1++]
0027DC  B10070     SUB #0x7, W0
38:                }
0027DE  20CC00     MOV #0xCC0, W0
0027E0  060000     RETURN
39:                
40:                struct LINK_DATA* Get_Link_Packet(void)
41:                {
42:                	return &l_data;
43:                }
0027E2  20CC00     MOV #0xCC0, W0
---  /root/ble/fac_relay_clone/leds.c  ------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        leds.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 * add relay outputs
32:                 *
33:                 * LED functions
34:                 *
35:                 */
36:                
37:                #include "timers.h"
38:                #include "config.h"
39:                #include "leds.h"
40:                #include "app.h"
41:                
42:                extern APP_DATA appData;
43:                extern ADC_DATA adcData;
44:                static LED_LIGHTSHOW_T lightShow = LED_IDLE;
45:                
46:                void LED_Tasks()
47:                {
48:                	switch (lightShow) {
0021CA  806650     MOV lightShow, W0
0021CC  500FE2     SUB W0, #0x2, [W15]
0021CE  320020     BRA Z, .L5
0021D0  3E0005     BRA GTU, .L8
0021D2  E00000     CP0 W0
0021D4  320008     BRA Z, .L3
0021D6  500FE1     SUB W0, #0x1, [W15]
0021D8  3A0052     BRA NZ, .L1
0021DA  370008     BRA .L13
0021DC  500FE3     SUB W0, #0x3, [W15]
0021DE  32003F     BRA Z, .L6
0021E0  500FE4     SUB W0, #0x4, [W15]
0021E2  3A004D     BRA NZ, .L1
0021E4  37004A     BRA .L14
49:                	case LED_IDLE:
50:                		SLED = 1;
0021E6  A8C2CD     BSET 0x2CD, #6
51:                		LED6 = 0;
0021E8  A902CC     BCLR LATB, #0
52:                		break;
0021EA  370049     BRA .L1
53:                
54:                	case LED_BTLE_ADVERTISING:
55:                		if (TimerDone(TMR_LEDS)) {
0021EC  B3C010     MOV.B #0x1, W0
0021EE  07032E     RCALL TimerDone
0021F0  E00400     CP0.B W0
0021F2  320045     BRA Z, .L1
56:                			SLED ^= 1;
0021F4  801660     MOV LATB, W0
0021F6  DE004E     LSR W0, #14, W0
0021F8  EA8000     COM W0, W0
0021FA  600061     AND W0, #0x1, W0
0021FC  DD004E     SL W0, #14, W0
0021FE  2BFFF1     MOV #0xBFFF, W1
002200  801662     MOV LATB, W2
002202  608082     AND W1, W2, W1
002204  700081     IOR W0, W1, W1
002206  881661     MOV W1, LATB
57:                			StartTimer(TMR_LEDS, LED_BLINK_MS);
002208  203841     MOV #0x384, W1
00220A  B3C010     MOV.B #0x1, W0
00220C  070319     RCALL StartTimer
00220E  370037     BRA .L1
58:                		}
59:                		break;
60:                
61:                	case LED_BTLE_PAIRED:
62:                		RELAY1 = !appData.led1; // logic low turns on relay
002210  BFCB2A     MOV.B .L64, WREG
002212  A20400     BTG.B W0, #0
002214  600061     AND W0, #0x1, W0
002216  DD004D     SL W0, #13, W0
002218  2DFFF1     MOV #0xDFFF, W1
00221A  801662     MOV LATB, W2
00221C  608082     AND W1, W2, W1
00221E  700081     IOR W0, W1, W1
002220  881661     MOV W1, LATB
63:                		RELAY2 = !appData.led2;
002222  BFCB2B     MOV.B 0xB2B, WREG
002224  A20400     BTG.B W0, #0
002226  600061     AND W0, #0x1, W0
002228  DD004C     SL W0, #12, W0
00222A  2EFFF1     MOV #0xEFFF, W1
00222C  801662     MOV LATB, W2
00222E  608082     AND W1, W2, W1
002230  700081     IOR W0, W1, W1
002232  881661     MOV W1, LATB
64:                		RELAY3 = !appData.led3;
002234  BFCB2C     MOV.B 0xB2C, WREG
002236  A20400     BTG.B W0, #0
002238  600061     AND W0, #0x1, W0
00223A  DD0044     SL W0, #4, W0
00223C  2FFEF1     MOV #0xFFEF, W1
00223E  801662     MOV LATB, W2
002240  608082     AND W1, W2, W1
002242  700081     IOR W0, W1, W1
002244  881661     MOV W1, LATB
65:                		RELAY4 = !appData.led4;
002246  BFCB2D     MOV.B 0xB2D, WREG
002248  A20400     BTG.B W0, #0
00224A  600061     AND W0, #0x1, W0
00224C  DD0043     SL W0, #3, W0
00224E  2FFF71     MOV #0xFFF7, W1
002250  801662     MOV LATB, W2
002252  608082     AND W1, W2, W1
002254  700081     IOR W0, W1, W1
002256  881661     MOV W1, LATB
66:                		SLED = 1;
002258  A8C2CD     BSET 0x2CD, #6
67:                		LED6 = 0;
00225A  A902CC     BCLR LATB, #0
68:                		break;
00225C  370010     BRA .L1
69:                
70:                	case LED_ERROR:
71:                		switch (appData.error_code) {
00225E  BFCB34     MOV.B 0xB34, WREG
002260  404FE3     ADD.B W0, #0x3, [W15]
002262  320005     BRA Z, .L10
002264  404FE2     ADD.B W0, #0x2, [W15]
002266  3A0006     BRA NZ, .L12
72:                		case ERROR_INITIALIZATION:
73:                			SLED = 0;
002268  A9C2CD     BCLR 0x2CD, #6
74:                			LED6 = 1;
00226A  A802CC     BSET LATB, #0
75:                			break;
00226C  370008     BRA .L1
76:                		case ERROR_RN_FW:
77:                			SLED = 0;
00226E  A9C2CD     BCLR 0x2CD, #6
78:                			LED6 = 1;
002270  A802CC     BSET LATB, #0
79:                			break;
002272  370005     BRA .L1
80:                		default:
81:                			SLED = 0;
002274  A9C2CD     BCLR 0x2CD, #6
82:                			LED6 = 1;
002276  A802CC     BSET LATB, #0
83:                			break;
002278  370002     BRA .L1
84:                		}
85:                		break;
86:                
87:                	case LED_SLEEP:
88:                		SLED = 0;
00227A  A9C2CD     BCLR 0x2CD, #6
89:                		LED6 = 1;
00227C  A802CC     BSET LATB, #0
90:                		break;
91:                
92:                	default:
93:                		break;
94:                	}
95:                }
00227E  060000     RETURN
96:                
97:                inline void LED_SET_LightShow(LED_LIGHTSHOW_T setting)
98:                {
99:                	lightShow = setting;
002280  886650     MOV W0, lightShow
100:               }
002282  060000     RETURN
101:               
102:               //Update LEDs with status from LED update message
103:               
104:               void GetNewLEDs(void)
105:               {
106:               	if (!appData.update_packet) {
002284  E24B27     CP0.B 0xB27
002286  3A0011     BRA NZ, .L17
107:               		appData.led1 = appData.oled1;
002288  20B301     MOV #0xB30, W1
00228A  784091     MOV.B [W1], W1
00228C  20B2A2     MOV #0xB2A, W2
00228E  784901     MOV.B W1, [W2]
108:               		appData.led2 = appData.oled2;
002290  20B313     MOV #0xB31, W3
002292  784193     MOV.B [W3], W3
002294  20B2B4     MOV #0xB2B, W4
002296  784A03     MOV.B W3, [W4]
109:               		appData.led3 = appData.oled3;
002298  20B325     MOV #0xB32, W5
00229A  784295     MOV.B [W5], W5
00229C  20B2C0     MOV #0xB2C, W0
00229E  784805     MOV.B W5, [W0]
110:               		appData.led4 = appData.oled4;
0022A0  20B331     MOV #0xB33, W1
0022A2  784091     MOV.B [W1], W1
0022A4  20B2D2     MOV #0xB2D, W2
0022A6  784901     MOV.B W1, [W2]
0022A8  37002A     BRA .L16
111:               	} else {
112:               		appData.led1 = appData.receive_packet[9] == '1' ? 1 : 0;
0022AA  B3C310     MOV.B #0x31, W0
0022AC  20A673     MOV #0xA67, W3
0022AE  784193     MOV.B [W3], W3
0022B0  69C180     XOR.B W3, W0, W3
0022B2  FB8183     ZE W3, W3
0022B4  E90183     DEC W3, W3
0022B6  DE19CF     LSR W3, #15, W3
0022B8  20B2A4     MOV #0xB2A, W4
0022BA  784A03     MOV.B W3, [W4]
113:               		appData.led2 = appData.receive_packet[11] == '1' ? 1 : 0;
0022BC  20A692     MOV #0xA69, W2
0022BE  784112     MOV.B [W2], W2
0022C0  694100     XOR.B W2, W0, W2
0022C2  FB8102     ZE W2, W2
0022C4  E90102     DEC W2, W2
0022C6  DE114F     LSR W2, #15, W2
0022C8  20B2B1     MOV #0xB2B, W1
0022CA  784882     MOV.B W2, [W1]
114:               		appData.led3 = appData.receive_packet[13] == '1' ? 1 : 0;
0022CC  20A6B1     MOV #0xA6B, W1
0022CE  784091     MOV.B [W1], W1
0022D0  68C080     XOR.B W1, W0, W1
0022D2  FB8081     ZE W1, W1
0022D4  E90081     DEC W1, W1
0022D6  DE08CF     LSR W1, #15, W1
0022D8  20B2C5     MOV #0xB2C, W5
0022DA  784A81     MOV.B W1, [W5]
115:               		appData.led4 = appData.receive_packet[15] == '1' ? 1 : 0;
0022DC  20A6D4     MOV #0xA6D, W4
0022DE  784214     MOV.B [W4], W4
0022E0  6A4000     XOR.B W4, W0, W0
0022E2  FB8000     ZE W0, W0
0022E4  E90000     DEC W0, W0
0022E6  DE004F     LSR W0, #15, W0
0022E8  B7EB2D     MOV.B WREG, 0xB2D
116:               		appData.oled1 = appData.led1;
0022EA  784203     MOV.B W3, W4
0022EC  20B305     MOV #0xB30, W5
0022EE  784A84     MOV.B W4, [W5]
117:               		appData.oled2 = appData.led2;
0022F0  784182     MOV.B W2, W3
0022F2  20B315     MOV #0xB31, W5
0022F4  784A83     MOV.B W3, [W5]
118:               		appData.oled3 = appData.led3;
0022F6  784281     MOV.B W1, W5
0022F8  20B324     MOV #0xB32, W4
0022FA  784A05     MOV.B W5, [W4]
119:               		appData.oled4 = appData.led4;
0022FC  B7EB33     MOV.B WREG, 0xB33
120:               	}
121:               }
0022FE  060000     RETURN
---  /root/ble/fac_relay_clone/bluetooth.c  -------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        bluetooth.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Functions to communicate with a RN4020 Bluetooth LE module over a UART
33:                 * 
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdio.h>
39:                #include <stdbool.h>
40:                #include "bluetooth.h"
41:                #include "config.h"
42:                #include "app.h"
43:                #include "uart.h"
44:                #include "timers.h"
45:                #include <stdlib.h>
46:                #include <string.h>
47:                
48:                uint16_t BT_CheckFwVer(void);
49:                
50:                struct gatts_service_inst gatts_service[] = {
51:                	{
52:                		.gatts_if = 0, /* gatts_if not known yet, so initial is ESP_GATT_IF_NONE */
53:                	},
54:                	{
55:                		.gatts_if = 0, /* gatts_if not known yet, so initial is ESP_GATT_IF_NONE */
56:                	}
57:                };
58:                
59:                struct gatts_char_inst gatts_char[] = {
60:                	{
61:                		/* Battery Service -> Battery Level */
62:                		.service_pos = 0, // Battery service
63:                		.char_perm = ESP_GATT_PERM_READ,
64:                		.char_property = "",
65:                		.char_val = NULL,
66:                		.char_handle = "0032",
67:                		.char_nvs = "2A19"
68:                	},
69:                	{
70:                		.service_pos = 1, // heart rate service
71:                		.char_perm = ESP_GATT_PERM_READ,
72:                		.char_property = "22,02",
73:                		.char_val = NULL,
74:                		.char_handle = "001B",
75:                		.char_nvs = "2A37"
76:                	}
77:                };
78:                
79:                uint16_t get_char_handle(struct gatts_char_inst *bt, char *rxbuf)
80:                {
00179C  FA0002     LNK #0x2
00179E  BE9F88     MOV.D W8, [W15++]
0017A0  BE9F8A     MOV.D W10, [W15++]
0017A2  781F8C     MOV W12, [W15++]
0017A4  780580     MOV W0, W11
0017A6  780401     MOV W1, W8
81:                	char* pch;
82:                	uint8_t state = 0;
0017C6  EB4480     CLR.B W9
83:                
84:                	char* tempBuf = (char*) malloc(strlen(rxbuf) + 1);
0017A8  780008     MOV W8, W0
0017AA  07F7DF     RCALL _strlen
0017AC  E80000     INC W0, W0
0017AE  07F6F1     RCALL _malloc
0017B0  780500     MOV W0, W10
85:                	if (!tempBuf) {
0017B4  E0000A     CP0 W10
0017B6  32003E     BRA Z, .L2
86:                		return false;
0017B2  EB0000     CLR W0
87:                	}
88:                	strcpy(tempBuf, rxbuf);
0017B8  780088     MOV W8, W1
0017BA  78000A     MOV W10, W0
0017BC  07F7D0     RCALL _strcpy
89:                	//Parse response line by line
90:                	pch = strtok(tempBuf, "\r\n");
0017BE  294401     MOV #0x9440, W1
0017C0  78000A     MOV W10, W0
0017C2  07F7FE     RCALL _strtok
0017C4  780400     MOV W0, W8
91:                	do {
92:                		switch (state) {
0017CC  E00409     CP0.B W9
0017CE  320003     BRA Z, .L4
0017D0  54CFE1     SUB.B W9, #0x1, [W15]
0017D2  3A0027     BRA NZ, .L3
0017D4  370006     BRA .L12
93:                		case 0:
94:                			//Check if the line contains a service
95:                			if (strstr(pch, bt->char_nvs)) {
0017C8  B0020B     ADD #0x20, W11
0017D6  78008B     MOV W11, W1
0017D8  780008     MOV W8, W0
0017DA  07F7DC     RCALL _strstr
0017DC  E00000     CP0 W0
0017DE  3A001E     BRA NZ, .L9
0017E0  370020     BRA .L3
96:                				//Service found, now looking for line with characteristic
97:                				state = 1;
00181C  B3C019     MOV.B #0x1, W9
00181E  370001     BRA .L3
98:                				break;
99:                			}
100:               			break;
101:               		case 1:
102:               			if (strncmp(pch, "  ", 2)) {
0017E2  200022     MOV #0x2, W2
0017E4  294431     MOV #0x9443, W1
0017E6  780008     MOV W8, W0
0017E8  07F7C6     RCALL _strncmp
0017EA  E00000     CP0 W0
0017EC  320004     BRA Z, .L6
103:               				//String doesn't start with two spaces, so this is not a characteristic.  This is an error.
104:               				free(tempBuf);
0017EE  78000A     MOV W10, W0
0017F0  07F759     RCALL _free
105:               				return 0;
0017F2  EB0000     CLR W0
0017F4  37001F     BRA .L2
106:               			}
107:               			if (strstr(pch, bt->char_nvs)) {
0017F6  78008B     MOV W11, W1
0017F8  780008     MOV W8, W0
0017FA  07F7CC     RCALL _strstr
0017FC  E00000     CP0 W0
0017FE  320011     BRA Z, .L3
108:               				//Characteristic found, now looking for handle
109:               				char* pch2 = strchr(pch, ',') + 1;
001800  2002C1     MOV #0x2C, W1
001802  780008     MOV W8, W0
001804  07F7A2     RCALL .L3, _strchr
001806  E80000     INC W0, W0
110:               				uint16_t handle;
111:               				if (sscanf(pch2, "%x,", &handle) == 1) {
0017CA  29446C     MOV #0x9446, W12
001808  781F8E     MOV W14, [W15++]
00180A  781F8C     MOV W12, [W15++]
00180C  07F7F6     RCALL __sscanf_cdnopuxX
00180E  5787E4     SUB W15, #0x4, W15
001810  500FE1     SUB W0, #0x1, [W15]
001812  3A0006     BRA NZ, .L10
112:               					//#if DEBUG_LEVEL >= DEBUG_ALL
113:               					//                    sPortDebug->println("Setting handle");
114:               					//                    sPortDebug->println(handle, HEX);
115:               					//#endif
116:               					free(tempBuf);
001814  78000A     MOV W10, W0
001816  07F746     RCALL _free
117:               					return handle;
001818  78001E     MOV [W14], W0
00181A  37000C     BRA .L2
118:               
119:               				}
120:               				state = 0;
001820  EB4480     CLR.B W9
121:               				break;
122:               			}
123:               		}
124:               		pch = strtok(NULL, "\r\n");
001822  294401     MOV #0x9440, W1
001824  EB0000     CLR W0
001826  07F7CC     RCALL _strtok
001828  780400     MOV W0, W8
125:               	} while (pch != NULL);
00182A  E00008     CP0 W8
00182C  3AFFCF     BRA NZ, .L7, .LBE2
126:               	free(tempBuf);
00182E  78000A     MOV W10, W0
001830  07F739     RCALL _free
127:               	return 0;
001832  EB0000     CLR W0
128:               }
001834  78064F     MOV [--W15], W12
001836  BE054F     MOV.D [--W15], W10
001838  BE044F     MOV.D [--W15], W8
00183A  FA8000     ULNK
00183C  060000     RETURN
129:               
130:               
131:               //**********************************************************************************************************************
132:               // Receive a message over the Bluetooth link
133:               
134:               bool BT_ReceivePacket(char * Message)
135:               {
00183E  BE9F88     MOV.D W8, [W15++]
001840  780400     MOV W0, W8
136:               	static enum BluetoothDecodeState btDecodeState = WaitForCR; //Static so maintains state on reentry   //Byte read from the UART buffer
137:               	static uint16_t i = 0;
138:               
139:               	if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
001842  070771     RCALL UART_IsNewRxData
001844  784080     MOV.B W0, W1
001848  E00401     CP0.B W1
00184A  320026     BRA Z, .L14
140:               	{
141:               		Message[i++] = UART_ReadRxBuffer();
00184C  8064D9     MOV i, W9
00184E  070774     RCALL UART_ReadRxBuffer
001850  7CF400     MOV.B W0, [W8+W9]
001852  E80489     INC W9, W9
001854  8864D9     MOV W9, i
142:               		if (i == BT_RX_PKT_SZ) {
001856  200640     MOV #0x64, W0
001858  548F80     SUB W9, W0, [W15]
00185A  3A0001     BRA NZ, .L15
143:               			i = 0;
00185C  EF2C9A     CLR i
144:               		}
145:               
146:               		switch (btDecodeState) {
00185E  8064E0     MOV btDecodeState, W0
001860  E00000     CP0 W0
001862  320003     BRA Z, .L17
001864  500FE1     SUB W0, #0x1, [W15]
001866  3A0016     BRA NZ, .L22
001868  37000A     BRA .L23
147:               		case WaitForCR:
148:               			if (Message[i - 1] == '\r') { //See if this is the CR
00186A  8064D0     MOV i, W0
00186C  440400     ADD W8, W0, W8
00186E  97F8F8     MOV.B [W8-1], W1
001872  50CFED     SUB.B W1, #0xD, [W15]
001874  3A0011     BRA NZ, .L14
149:               				btDecodeState = WaitForLF; //Is CR so wait for LF
001876  200010     MOV #0x1, W0
001878  8864E0     MOV W0, btDecodeState
150:               			}
151:               			break;
152:               
153:               		case WaitForLF:
154:               			btDecodeState = WaitForCR; //Will be looking for a new packet next
00187E  EF2C9C     CLR btDecodeState
155:               			if (Message[i - 1] == '\n') //See if this is the LF
001880  8064D1     MOV i, W1
001882  440001     ADD W8, W1, W0
001884  97F970     MOV.B [W0-1], W2
001888  514FEA     SUB.B W2, #0xA, [W15]
00188A  3A0006     BRA NZ, .L14
156:               			{
157:               				Message[i] = NULL; //Got a complete message!
00188C  78F400     MOV.B W0, [W8+W1]
158:               				i = 0;
00188E  EF2C9A     CLR i
159:               				return true;
001890  B3C010     MOV.B #0x1, W0
001892  370002     BRA .L14
160:               			}
161:               			break;
162:               
163:               		default: //Invalid state so start looking for a new start of frame
164:               			btDecodeState = WaitForCR;
001894  EF2C9C     CLR btDecodeState
165:               		}
166:               	}
167:               	return false;
001846  EB4000     CLR.B W0
001870  EB4000     CLR.B W0
00187A  EB4000     CLR.B W0
00187C  37000D     BRA .L14
001886  EB4000     CLR.B W0
001896  EB4000     CLR.B W0
168:               }
001898  BE044F     MOV.D [--W15], W8
00189A  060000     RETURN
169:               
170:               //**********************************************************************************************************************
171:               // Send a command to the RN4020 module
172:               //Return true for success, false for busy
173:               
174:               bool BT_SendCommand(const char *data, bool wait)
0018D6  200FF9     MOV #0xFF, W9
0018D8  448488     ADD W9, W8, W9
0018DA  37FFEF     BRA .L30
175:               {
00189C  BE9F88     MOV.D W8, [W15++]
00189E  780400     MOV W0, W8
0018A0  784481     MOV.B W1, W9
176:               	uint16_t i;
177:               	//Only transmit a message if TX timer expired, or wait flag is set to false
178:               	//We limit transmission frequency to avoid overwhelming the BTLE link
179:               	if (TimerDone(TMR_BT_TX) || wait == false) {
0018A2  B3C090     MOV.B #0x9, W0
0018A4  0707D3     RCALL TimerDone
0018A6  E00400     CP0.B W0
0018A8  320004     BRA Z, .L25
0018B4  E00409     CP0.B W9
0018B6  32FFF9     BRA Z, .L28
0018B8  37000B     BRA .L29
180:               		for (i = 0; i < SIZE_TxBuffer; i++) {
0018C2  540F89     SUB W8, W9, [W15]
0018C4  3AFFFA     BRA NZ, .L30
181:               			if (*data != '\0') //Keep loading bytes until end of string
0018AA  784018     MOV.B [W8], W0
0018AC  E00400     CP0.B W0
0018AE  3A0012     BRA NZ, .L26
0018B0  37000A     BRA .L27
0018BA  784058     MOV.B [++W8], W0
0018BC  E00400     CP0.B W0
0018BE  320003     BRA Z, .L27
182:               				UART_WriteTxBuffer(*data++); //Load byte into the transmit buffer
0018C0  07074C     RCALL UART_WriteTxBuffer
0018D4  070742     RCALL UART_WriteTxBuffer
183:               			else
184:               				break;
185:               		}
186:               		UART_TxStart(); //Start transmitting the bytes
0018C6  07072D     RCALL UART_TxStart
187:               		StartTimer(TMR_BT_TX, BT_TX_MS); //Restart transmit timer
0018C8  2000A1     MOV #0xA, W1
0018CA  B3C090     MOV.B #0x9, W0
0018CC  0707B9     RCALL StartTimer
188:               		return true;
0018CE  B3C010     MOV.B #0x1, W0
189:               	}
190:               	return false;
0018B2  EB4000     CLR.B W0
191:               }
0018D0  BE044F     MOV.D [--W15], W8
0018D2  060000     RETURN
0018D4  070742     RCALL UART_WriteTxBuffer
0018D6  200FF9     MOV #0xFF, W9
0018D8  448488     ADD W9, W8, W9
0018DA  37FFEF     BRA .L30
192:               
193:               //**********************************************************************************************************************
194:               // Send a byte to the RN4020 module
195:               
196:               void BT_SendByte(char data)
197:               {
198:               	UART_WriteTxBuffer(data); //Load byte into the transmit buffer
0018DC  07073E     RCALL UART_WriteTxBuffer
199:               	UART_TxStart(); //Start transmitting the byte
0018DE  070721     RCALL UART_TxStart
200:               }
0018E0  060000     RETURN
201:               
202:               //**********************************************************************************************************************
203:               // Get a response from the RN4020 module
204:               
205:               bool BT_GetResponse(char *data)
206:               {
0018E2  BE9F88     MOV.D W8, [W15++]
0018E4  BE9F8A     MOV.D W10, [W15++]
0018E6  780480     MOV W0, W9
207:               	uint16_t byteCount = 0;
0018EE  EB0400     CLR W8
208:               	char newByte;
209:               
210:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
0018E8  202581     MOV #0x258, W1
0018EA  B3C020     MOV.B #0x2, W0
0018EC  0707A9     RCALL StartTimer
211:               
212:               	while (byteCount < BT_RX_PKT_SZ) //Don't accept more than the buffer size
0018F2  20063B     MOV #0x63, W11
00190E  540F8B     SUB W8, W11, [W15]
001910  36FFF1     BRA LEU, .L36
001912  370003     BRA .L35
213:               	{
214:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
0018F4  070718     RCALL UART_IsNewRxData
0018F6  E00400     CP0.B W0
0018F8  320006     BRA Z, .L34
215:               		{
216:               			newByte = UART_ReadRxBuffer(); //Read the data byte for processing
0018FA  07071E     RCALL UART_ReadRxBuffer
217:               			*data++ = newByte; //Add it to the buffer
0018FC  784C80     MOV.B W0, [W9]
001902  E80489     INC W9, W9
218:               			byteCount++; //Keep track of the number of bytes received
001904  E80408     INC W8, W8
219:               			if (newByte == '\n') //Check if got linefeed
0018FE  504FEA     SUB.B W0, #0xA, [W15]
001900  320009     BRA Z, .L37
220:               				return true; //If linefeed then return success
001914  B3C010     MOV.B #0x1, W0
001916  370001     BRA .L35
221:               		}
222:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
0018F0  B3C02A     MOV.B #0x2, W10
001906  78400A     MOV.B W10, W0
001908  0707A1     RCALL TimerDone
00190A  E00400     CP0.B W0
00190C  3A0005     BRA NZ, .L38
223:               			return false; //If timed out then return failure
001918  EB4000     CLR.B W0
224:               	}
225:               	return false;
226:               }
00191A  BE054F     MOV.D [--W15], W10
00191C  BE044F     MOV.D [--W15], W8
00191E  060000     RETURN
227:               
228:               //**********************************************************************************************************************
229:               // Compare the buffer with the response with one of the expected responses
230:               
231:               bool BT_CompareResponse(const char *data1, const char *data2)
001930  B00311     ADD #0x31, W1
232:               {
233:               	uint16_t i;
234:               
235:               	for (i = 0; i < 50; i++) //Compare up to 50 bytes
00193C  510F81     SUB W2, W1, [W15]
00193E  320006     BRA Z, .L47
236:               	{
237:               		if (*data1 == '\0') //See if reached end of string with no bytes different
001920  784190     MOV.B [W0], W3
001924  E00403     CP0.B W3
001926  320013     BRA Z, .L41
001932  7841D0     MOV.B [++W0], W3
001934  E00403     CP0.B W3
001936  320006     BRA Z, .L45
238:               			return true; //No bytes were different so return success
001922  B3C012     MOV.B #0x1, W2
001944  B3C012     MOV.B #0x1, W2
001946  370003     BRA .L41
239:               		else if (*data1++ != *data2++) //else see if the bytes are different
00192A  51CF91     SUB.B W3, [W1], [W15]
00192C  3A0010     BRA NZ, .L41
00192E  E80101     INC W1, W2
001938  51CF92     SUB.B W3, [W2], [W15]
00193A  3A0006     BRA NZ, .L46
001940  E80102     INC W2, W2
001942  37FFF7     BRA .L42
240:               			return false; //Bytes differ so return failure
001928  EB4100     CLR.B W2
001948  EB4100     CLR.B W2
00194A  370001     BRA .L41
241:               	}
242:               	return false; //Did not reach end of string so return failure
00194C  EB4100     CLR.B W2
243:               }
00194E  784002     MOV.B W2, W0
001950  060000     RETURN
244:               
245:               //**********************************************************************************************************************
246:               // Get a response from the RN4020 module and compare with an expected response
247:               
248:               bool BT_CheckResponse(const char *data)
249:               {
001952  B0034F     ADD #0x34, W15
001954  BE9F88     MOV.D W8, [W15++]
001956  BE9F8A     MOV.D W10, [W15++]
001958  781F8E     MOV W14, [W15++]
00195A  780580     MOV W0, W11
250:               	uint16_t i, ByteCount = 0;
001966  EB0400     CLR W8
251:               	char NewByte, Buffer[50], *BufPtr;
252:               
253:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
00195C  202581     MOV #0x258, W1
00195E  B3C020     MOV.B #0x2, W0
001960  07076F     RCALL StartTimer
254:               
255:               	BufPtr = Buffer;
001962  2FFC4E     MOV #0xFFC4, W14
001964  47070F     ADD W14, W15, W14
256:               	while (ByteCount < 50) //Don't accept more than the buffer size
00196A  20031A     MOV #0x31, W10
001986  540F8A     SUB W8, W10, [W15]
001988  36FFF1     BRA LEU, .L52
257:               	{
258:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
00196C  0706DC     RCALL UART_IsNewRxData
00196E  E00400     CP0.B W0
001970  320006     BRA Z, .L49
259:               		{
260:               			NewByte = (char) UART_ReadRxBuffer(); //Read the data byte for processing
001972  0706E2     RCALL UART_ReadRxBuffer
261:               			*BufPtr++ = NewByte; //Add it to the buffer
001974  784F00     MOV.B W0, [W14]
00197C  E8070E     INC W14, W14
262:               			ByteCount++;
001976  E80408     INC W8, W8
263:               			if (NewByte == '\n') //Check if got linefeed
001978  504FEA     SUB.B W0, #0xA, [W15]
00197A  320007     BRA Z, .L50
264:               				break; //If linefeed then we have what we want
265:               		}
266:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001968  B3C029     MOV.B #0x2, W9
00197E  784009     MOV.B W9, W0
001980  070765     RCALL TimerDone
001982  E00400     CP0.B W0
001984  3A001A     BRA NZ, .L55
267:               			return false; //If timed out then return failure
0019BA  EB4000     CLR.B W0
0019BC  370003     BRA .L51
268:               	}
269:               
270:               	BufPtr = Buffer;
271:               	for (i = 0; i < ByteCount; i++) //Compare all bytes received
00198C  E00008     CP0 W8
00198E  32001A     BRA Z, .L51
0019A2  EB0000     CLR W0
0019A4  370005     BRA .L53
0019B0  E80000     INC W0, W0
0019B2  540F80     SUB W8, W0, [W15]
0019B4  3EFFF8     BRA GTU, .L54
272:               	{
273:               		if (*data == '\0') //See if reached end of string with no bytes different
001990  78409B     MOV.B [W11], W1
001992  E00401     CP0.B W1
001994  320017     BRA Z, .L51
0019A6  7840DB     MOV.B [++W11], W1
0019A8  E00401     CP0.B W1
0019AA  320009     BRA Z, .L59
274:               			return true; //No bytes were different so return success
0019BE  B3C010     MOV.B #0x1, W0
0019C0  370001     BRA .L51
275:               		else if (*data++ != *BufPtr++) //else see if the bytes are different
001998  97C14F     MOV.B [W15-60], W2
00199A  50CF82     SUB.B W1, W2, [W15]
00199C  3A0013     BRA NZ, .L51
00199E  2FFC4E     MOV #0xFFC4, W14
0019A0  47070F     ADD W14, W15, W14
0019AC  50CFDE     SUB.B W1, [++W14], [W15]
0019AE  3A0009     BRA NZ, .L60
276:               			return false; //Bytes differ so return failure
001996  EB4000     CLR.B W0
0019C2  EB4000     CLR.B W0
277:               	}
278:               	return true; //All bytes matched so return success
00198A  B3C010     MOV.B #0x1, W0
0019B6  B3C010     MOV.B #0x1, W0
0019B8  370005     BRA .L51
279:               }
0019C4  78074F     MOV [--W15], W14
0019C6  BE054F     MOV.D [--W15], W10
0019C8  BE044F     MOV.D [--W15], W8
0019CA  B1034F     SUB #0x34, W15
0019CC  060000     RETURN
280:               
281:               //**********************************************************************************************************************
282:               // Get a response from the RN4020 module and compare with an expected response
283:               //   All incoming bytes in the position of the wildcard character are ignored
284:               //   Use this to ignore text that changes, like MAC addresses.
285:               
286:               bool BT_CheckResponseWithWildcard(const char *data, char Wildcard)
001A16  E8060C     INC W12, W12
287:               {
0019CE  B0034F     ADD #0x34, W15
0019D0  BE9F88     MOV.D W8, [W15++]
0019D2  BE9F8A     MOV.D W10, [W15++]
0019D4  781F8C     MOV W12, [W15++]
0019D6  781F8E     MOV W14, [W15++]
0019D8  780600     MOV W0, W12
0019DA  784581     MOV.B W1, W11
288:               	uint16_t i, ByteCount = 0;
0019E6  EB0400     CLR W8
289:               	char NewByte, Buffer[50], *BufPtr;
290:               
291:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
0019DC  202581     MOV #0x258, W1
0019DE  B3C020     MOV.B #0x2, W0
0019E0  07072F     RCALL StartTimer
292:               
293:               	BufPtr = Buffer;
0019E2  2FFC2E     MOV #0xFFC2, W14
0019E4  47070F     ADD W14, W15, W14
294:               	while (ByteCount < 50) //Don't accept more than the buffer size
0019EA  20031A     MOV #0x31, W10
001A06  540F8A     SUB W8, W10, [W15]
001A08  36FFF1     BRA LEU, .L66
295:               	{
296:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
0019EC  07069C     RCALL UART_IsNewRxData
0019EE  E00400     CP0.B W0
0019F0  320006     BRA Z, .L63
297:               		{
298:               			NewByte = UART_ReadRxBuffer(); //Read the data byte for processing
0019F2  0706A2     RCALL UART_ReadRxBuffer
299:               			*BufPtr++ = NewByte; //Add it to the buffer
0019F4  784F00     MOV.B W0, [W14]
0019FC  E8070E     INC W14, W14
300:               			ByteCount++;
0019F6  E80408     INC W8, W8
301:               			if (NewByte == '\n') //Check if got linefeed
0019F8  504FEA     SUB.B W0, #0xA, [W15]
0019FA  320007     BRA Z, .L64
302:               				break; //If linefeed then we have what we want
303:               		}
304:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
0019E8  B3C029     MOV.B #0x2, W9
0019FE  784009     MOV.B W9, W0
001A00  070725     RCALL TimerDone
001A02  E00400     CP0.B W0
001A04  3A001E     BRA NZ, .L71
305:               			return false; //If timed out then return failure
001A42  EB4000     CLR.B W0
001A44  370003     BRA .L65
306:               	}
307:               
308:               	BufPtr = Buffer;
309:               	for (i = 0; i < ByteCount; i++) //Compare all bytes received
001A0C  E00008     CP0 W8
001A0E  32001E     BRA Z, .L65
001A18  EB0000     CLR W0
001A1A  370004     BRA .L67
001A38  E80000     INC W0, W0
001A3A  540F80     SUB W8, W0, [W15]
001A3C  3EFFEF     BRA GTU, .L70
310:               	{
311:               		if (*data == '\0') //See if reached end of string with no bytes different
001A10  78409C     MOV.B [W12], W1
001A12  E00401     CP0.B W1
001A14  32001B     BRA Z, .L65
001A1C  784091     MOV.B [W1], W1
001A1E  E8060C     INC W12, W12
001A20  E00401     CP0.B W1
001A22  320011     BRA Z, .L74
312:               			return true; //No bytes were different so return success
001A46  B3C010     MOV.B #0x1, W0
001A48  370001     BRA .L65
313:               		else if (*data == Wildcard) //else see if expected response byte is a wildcard
001A24  50CF8B     SUB.B W1, W11, [W15]
001A26  3A0002     BRA NZ, .L68
001A28  78008C     MOV W12, W1
001A2A  370006     BRA .L69
314:               		{
315:               			data++; //Increment past wildcard byte
316:               			BufPtr++; //Increment to ignore byte corresponding to wildcard
317:               		} else if (*data++ != *BufPtr++) //else see if the bytes are different
001A2C  2FFC23     MOV #0xFFC2, W3
001A2E  41818F     ADD W3, W15, W3
001A30  784163     MOV.B [W3+W0], W2
001A32  50CF82     SUB.B W1, W2, [W15]
001A34  3A000A     BRA NZ, .L75
001A36  78008C     MOV W12, W1
318:               			return false; //Bytes differ so return failure
001A4A  EB4000     CLR.B W0
319:               	}
320:               	return true; //All bytes matched or were ignored so return success
001A0A  B3C010     MOV.B #0x1, W0
001A3E  B3C010     MOV.B #0x1, W0
001A40  370005     BRA .L65
321:               }
001A4C  78074F     MOV [--W15], W14
001A4E  78064F     MOV [--W15], W12
001A50  BE054F     MOV.D [--W15], W10
001A52  BE044F     MOV.D [--W15], W8
001A54  B1034F     SUB #0x34, W15
001A56  060000     RETURN
322:               
323:               /* update firmware via wireless app */
324:               bool BT_check_upd(void)
325:               {
001A58  BE9F88     MOV.D W8, [W15++]
001A5A  781F8A     MOV W10, [W15++]
326:               	/* Jumper on DFU OTA UPDATE */
327:               	BT_OTA_UPD_TRIS = 1; // set for jumper input
001A5C  A862C8     BSET TRISB, #3
328:               	CNPU1bits.CN7PUE = 1; // pullup for RB3
001A5E  A8E06E     BSET CNPU1, #7
329:               	WaitMs(2); // jumper pullup read delay, rise time is slow
001A60  200020     MOV #0x2, W0
001A62  0706FD     RCALL WaitMs
330:               	if (BT_OTA_UPD == 0) {
001A64  AB62CA     BTST PORTB, #3
001A66  3A0094     BRA NZ, .L78
331:               		BT_OTA_UPD_TRIS = 0; // set back to output
001A68  A962C8     BCLR TRISB, #3
332:               		BT_WAKE_SW = 1;
001A6A  A862CD     BSET 0x2CD, #3
333:               		BT_WAKE_HW = 1;
001A6C  A842CD     BSET 0x2CD, #2
334:               		BT_CMD = 0;
001A6E  A902C4     BCLR LATA, #0
335:               
336:               		WaitMs(100);
001A70  200640     MOV #0x64, W0
001A72  0706F5     RCALL WaitMs
337:               		BT_SendCommand("SF,2\r", false); // perform complete factory reset
001A74  EB4080     CLR.B W1
001A76  2944A0     MOV #0x944A, W0
001A78  07FF11     RCALL BT_SendCommand
338:               		WaitMs(100);
001A7A  200640     MOV #0x64, W0
001A7C  0706F0     RCALL WaitMs
339:               		BT_CheckResponse(AOK);
001A7E  294500     MOV #0x9450, W0
001A80  07FF68     RCALL BT_CheckResponse
340:               
341:               		BT_SendCommand("SF,2\r", false); // perform complete factory reset again
001A82  EB4080     CLR.B W1
001A84  2944A0     MOV #0x944A, W0
001A86  07FF0A     RCALL BT_SendCommand
342:               		WaitMs(100);
001A88  200640     MOV #0x64, W0
001A8A  0706E9     RCALL WaitMs
343:               		if (!BT_CheckResponse(AOK)) {
001A8C  294500     MOV #0x9450, W0
001A8E  07FF61     RCALL BT_CheckResponse
001A90  784080     MOV.B W0, W1
001A94  E00401     CP0.B W1
001A96  320082     BRA Z, .L79
344:               			return false;
001A92  EB4000     CLR.B W0
345:               		}
346:               
347:               		BT_SendCommand("SDH,4.1\r", false); // defaults
001A98  784080     MOV.B W0, W1
001A9A  294560     MOV #0x9456, W0
001A9C  07FEFF     RCALL BT_SendCommand
348:               		WaitMs(100);
001A9E  200640     MOV #0x64, W0
001AA0  0706DE     RCALL WaitMs
349:               		if (!BT_CheckResponse(AOK)) {
001AA2  294500     MOV #0x9450, W0
001AA4  07FF56     RCALL BT_CheckResponse
001AA6  784080     MOV.B W0, W1
001AAA  E00401     CP0.B W1
001AAC  320077     BRA Z, .L79
350:               			return false;
001AA8  EB4000     CLR.B W0
351:               		}
352:               		BT_SendCommand("SDM,RN4020\r", false); // defaults
001AAE  784080     MOV.B W0, W1
001AB0  2945F0     MOV #0x945F, W0
001AB2  07FEF4     RCALL BT_SendCommand
353:               		WaitMs(100);
001AB4  200640     MOV #0x64, W0
001AB6  0706D3     RCALL WaitMs
354:               		if (!BT_CheckResponse(AOK)) {
001AB8  294500     MOV #0x9450, W0
001ABA  07FF4B     RCALL BT_CheckResponse
001ABC  784080     MOV.B W0, W1
001AC0  E00401     CP0.B W1
001AC2  32006C     BRA Z, .L79
355:               			return false;
001ABE  EB4000     CLR.B W0
356:               		}
357:               
358:               		BT_SendCommand("SDN,Microchip\r", false); // defaults
001AC4  784080     MOV.B W0, W1
001AC6  2946B0     MOV #0x946B, W0
001AC8  07FEE9     RCALL BT_SendCommand
359:               		WaitMs(100);
001ACA  200640     MOV #0x64, W0
001ACC  0706C8     RCALL WaitMs
360:               		if (!BT_CheckResponse(AOK)) {
001ACE  294500     MOV #0x9450, W0
001AD0  07FF40     RCALL BT_CheckResponse
001AD2  784080     MOV.B W0, W1
001AD6  E00401     CP0.B W1
001AD8  320061     BRA Z, .L79
361:               			return false;
001AD4  EB4000     CLR.B W0
362:               		}
363:               
364:               		BT_SendCommand("SP,7\r", false); // defaults
001ADA  784080     MOV.B W0, W1
001ADC  2947A0     MOV #0x947A, W0
001ADE  07FEDE     RCALL BT_SendCommand
365:               		WaitMs(100);
001AE0  200640     MOV #0x64, W0
001AE2  0706BD     RCALL WaitMs
366:               		if (!BT_CheckResponse(AOK)) {
001AE4  294500     MOV #0x9450, W0
001AE6  07FF35     RCALL BT_CheckResponse
001AE8  784080     MOV.B W0, W1
001AEC  E00401     CP0.B W1
001AEE  320056     BRA Z, .L79
367:               			return false;
001AEA  EB4000     CLR.B W0
368:               		}
369:               
370:               		BT_SendCommand("SS,C0000000\r", false); // add service
001AF0  784080     MOV.B W0, W1
001AF2  294800     MOV #0x9480, W0
001AF4  07FED3     RCALL BT_SendCommand
371:               		WaitMs(100);
001AF6  200640     MOV #0x64, W0
001AF8  0706B2     RCALL WaitMs
372:               		if (!BT_CheckResponse(AOK)) {
001AFA  294500     MOV #0x9450, W0
001AFC  07FF2A     RCALL BT_CheckResponse
001AFE  784080     MOV.B W0, W1
001B02  E00401     CP0.B W1
001B04  32004B     BRA Z, .L79
373:               			return false;
001B00  EB4000     CLR.B W0
374:               		}
375:               
376:               		BT_SendCommand("SR,32008000\r", false); // support MLDP, enable OTA (peripheral mode is enabled by default)
001B06  784080     MOV.B W0, W1
001B08  2948D0     MOV #0x948D, W0
001B0A  07FEC8     RCALL BT_SendCommand
377:               		WaitMs(100);
001B0C  200640     MOV #0x64, W0
001B0E  0706A7     RCALL WaitMs
378:               		if (!BT_CheckResponse(AOK)) {
001B10  294500     MOV #0x9450, W0
001B12  07FF1F     RCALL BT_CheckResponse
001B14  784080     MOV.B W0, W1
001B18  E00401     CP0.B W1
001B1A  320040     BRA Z, .L79
379:               			return false;
001B16  EB4000     CLR.B W0
380:               		}
381:               		BT_SendCommand("R,1\r", false); //Force reboot
001B1C  784080     MOV.B W0, W1
001B1E  2949A0     MOV #0x949A, W0
001B20  07FEBD     RCALL BT_SendCommand
382:               
383:               		//Wait for WS status high
384:               		StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
001B22  20FA01     MOV #0xFA0, W1
001B24  B3C020     MOV.B #0x2, W0
001B26  07068C     RCALL StartTimer
385:               		while (BT_WS == 0) {
001B2A  370004     BRA .L80
001B34  AB42C2     BTST PORTA, #2
001B36  32FFFA     BRA Z, .L81
386:               			if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001B28  B3C028     MOV.B #0x2, W8
001B2C  784008     MOV.B W8, W0
001B2E  07068E     RCALL TimerDone
001B30  E00400     CP0.B W0
001B32  3A0031     BRA NZ, .L95
387:               			{
388:               				return false;
001B96  EB4000     CLR.B W0
001B98  370001     BRA .L79
389:               			}
390:               		}
391:               
392:               		//Wait for end of "CMD\r\n" - we don't check for full "CMD\r\n" string because we may 
393:               		//miss some bits or bytes at the beginning while the UART starts up
394:               		StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
001B38  20FA01     MOV #0xFA0, W1
001B3A  B3C020     MOV.B #0x2, W0
001B3C  070681     RCALL StartTimer
395:               		while (UART_ReadRxBuffer() != '\n') {
001B40  370004     BRA .L82
001B4A  0705F6     RCALL UART_ReadRxBuffer
001B4C  504FEA     SUB.B W0, #0xA, [W15]
001B4E  3AFFF9     BRA NZ, .L83
396:               			if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001B3E  B3C028     MOV.B #0x2, W8
001B42  784008     MOV.B W8, W0
001B44  070683     RCALL TimerDone
001B46  E00400     CP0.B W0
001B48  3A0028     BRA NZ, .L96
397:               			{
398:               				return false;
001B9A  EB4000     CLR.B W0
399:               			}
400:               		}
401:               
402:               		BT_SendCommand("I\r", false); // MLDP mode
001B50  EB4080     CLR.B W1
001B52  2949F0     MOV #0x949F, W0
001B54  07FEA3     RCALL BT_SendCommand
403:               		BT_SendCommand("A\r", false); // start advertising
001B56  EB4080     CLR.B W1
001B58  294A20     MOV #0x94A2, W0
001B5A  07FEA0     RCALL BT_SendCommand
404:               
405:               		/* wait loop controller for power cycle/reset after firmware update */
406:               		while (true) {
407:               			while (true) { // fast flash waiting for OTA
408:               				ClrWdt();
001B60  FE6000     CLRWDT
409:               				while (UART_IsNewRxData()) { //While buffer contains old data
001B64  370006     BRA .L99
001B72  0705D9     RCALL UART_IsNewRxData
001B74  E00400     CP0.B W0
001B76  3AFFF7     BRA NZ, .L86
410:               					UART_ReadRxBuffer(); //Keep reading until empty
001B66  0705E8     RCALL UART_ReadRxBuffer
411:               					if (!UART_IsNewRxData()) {
001B68  0705DE     RCALL UART_IsNewRxData
001B6A  E00400     CP0.B W0
001B6C  3A0002     BRA NZ, .L99
412:               						WaitMs(200);
001B62  200C88     MOV #0xC8, W8
001B6E  780008     MOV W8, W0
001B70  070676     RCALL WaitMs
413:               					}
414:               				}
415:               				WaitMs(110);
001B78  2006E0     MOV #0x6E, W0
001B7A  070671     RCALL WaitMs
416:               				SLED = !SLED;
001B5C  240009     MOV #0x4000, W9
001B5E  2BFFFA     MOV #0xBFFF, W10
001B7C  801661     MOV LATB, W1
001B7E  648001     AND W9, W1, W0
001B80  E90000     DEC W0, W0
001B82  DE004F     LSR W0, #15, W0
001B84  DD004E     SL W0, #14, W0
001B86  801662     MOV LATB, W2
001B88  650082     AND W10, W2, W1
001B8A  700081     IOR W0, W1, W1
001B8C  881661     MOV W1, LATB
417:               			}
001B8E  37FFE8     BRA .L87
418:               
419:               		}
420:               
421:               	}
422:               	BT_OTA_UPD_TRIS = 0;
001B90  A962C8     BCLR TRISB, #3
423:               	return true;
001B92  B3C010     MOV.B #0x1, W0
001B94  370003     BRA .L79
424:               }
001B9C  78054F     MOV [--W15], W10
001B9E  BE044F     MOV.D [--W15], W8
001BA0  060000     RETURN
425:               
426:               //**********************************************************************************************************************
427:               // Set up the RN4020 module
428:               
429:               bool BT_SetupModule(void)
430:               {
001D04  FA001C     LNK #0x1C
001D06  781F88     MOV W8, [W15++]
431:               	uint16_t version_code;
432:               
433:               	/* check for over the air firmware updates */
434:               	BT_check_upd();
001D08  07FEA7     RCALL BT_check_upd
435:               
436:               	//Check RN4020 module's firmware version for version specific setups
437:               	version_code = BT_CheckFwVer();
001D0A  07FFA0     RCALL BT_CheckFwVer
001D0C  780400     MOV W0, W8
438:               
439:               	BT_SendCommand("sf,2\r", false); //Get RN4020 module feature settings
001D0E  EB4080     CLR.B W1
001D10  294C80     MOV #0x94C8, W0
001D12  07FDC4     RCALL BT_SendCommand
440:               	if (!BT_CheckResponse(AOK)) {
001D14  294500     MOV #0x9450, W0
001D16  07FE1D     RCALL BT_CheckResponse
001D18  784080     MOV.B W0, W1
001D1C  E00401     CP0.B W1
001D1E  3200F9     BRA Z, .L139
441:               		return false;
001D1A  EB4000     CLR.B W0
442:               	}
443:               
444:               	//Send "GR" to get feature settings
445:               	BT_SendCommand("gr\r", false); //Get RN4020 module feature settings
001D20  784080     MOV.B W0, W1
001D22  294CE0     MOV #0x94CE, W0
001D24  07FDBB     RCALL BT_SendCommand
446:               	if (!BT_CheckResponse("26060000\r\n")) //Check if features are set for auto advertise and flow control, No Input, no output, no direct advertisement
001D26  294D20     MOV #0x94D2, W0
001D28  07FE14     RCALL BT_CheckResponse
001D2A  E00400     CP0.B W0
001D2C  3A0009     BRA NZ, .L140
447:               	{ //auto enable MLDP, suppress messages during MLDP
448:               		BT_SendCommand("sr,26060000\r", false); //Features not correct so set features
001D2E  EB4080     CLR.B W1
001D30  294DD0     MOV #0x94DD, W0
001D32  07FDB4     RCALL BT_SendCommand
449:               		if (!BT_CheckResponse(AOK)) {
001D34  294500     MOV #0x9450, W0
001D36  07FE0D     RCALL BT_CheckResponse
001D38  784080     MOV.B W0, W1
001D3C  E00401     CP0.B W1
001D3E  3200E9     BRA Z, .L139
450:               			return false;
001D3A  EB4000     CLR.B W0
451:               		}
452:               	}
453:               
454:               	char macAddr[16];
455:               	BT_SendCommand("gds\r", false); // Get mac address
001D40  EB4080     CLR.B W1
001D42  294EA0     MOV #0x94EA, W0
001D44  07FDAB     RCALL BT_SendCommand
456:               	while (!BT_ReceivePacket(macAddr));
001D46  78000E     MOV W14, W0
001D48  07FD7A     RCALL BT_ReceivePacket
001D4A  E00400     CP0.B W0
001D4C  32FFFC     BRA Z, .L141
457:               
458:               	char message[12];
459:               	macAddr[12] = '\0';
001D4E  EB4000     CLR.B W0
001D50  984F40     MOV.B W0, [W14+12]
460:               	sprintf(message, "sn,%s_BT\r", &macAddr[8]);
001D52  471FE8     ADD W14, #0x8, [W15++]
001D54  294EF0     MOV #0x94EF, W0
001D56  781F80     MOV W0, [W15++]
001D58  470070     ADD W14, #0x10, W0
001D5A  07F706     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
461:               
462:               	BT_SendCommand(message, false); //Set advertise name
001D5C  EB4080     CLR.B W1
001D5E  470070     ADD W14, #0x10, W0
001D60  07FD9D     RCALL BT_SendCommand
463:               	if (!BT_CheckResponse(AOK)) {
001D62  294500     MOV #0x9450, W0
001D64  07FDF6     RCALL BT_CheckResponse
001D66  784080     MOV.B W0, W1
001D68  5787E4     SUB W15, #0x4, W15
001D6C  E00401     CP0.B W1
001D6E  3200D1     BRA Z, .L139
464:               		return false;
001D6A  EB4000     CLR.B W0
465:               	}
466:               
467:               	BT_SendCommand("gs\r", false);
001D70  784080     MOV.B W0, W1
001D72  294F90     MOV #0x94F9, W0
001D74  07FD93     RCALL BT_SendCommand
468:               	if (!BT_CheckResponse("F0000001\r\n")) {
001D76  294FD0     MOV #0x94FD, W0
001D78  07FDEC     RCALL BT_CheckResponse
001D7A  E00400     CP0.B W0
001D7C  3A0009     BRA NZ, .L142
469:               		//Send "SS" to set user defined private profiles and ID/Battery in 1.33 firmware
470:               		BT_SendCommand("ss,F0000001\r", false);
001D7E  EB4080     CLR.B W1
001D80  295080     MOV #0x9508, W0
001D82  07FD8C     RCALL BT_SendCommand
471:               		if (!BT_CheckResponse(AOK)) {
001D84  294500     MOV #0x9450, W0
001D86  07FDE5     RCALL BT_CheckResponse
001D88  784080     MOV.B W0, W1
001D8C  E00401     CP0.B W1
001D8E  3200C1     BRA Z, .L139
472:               			return false;
001D8A  EB4000     CLR.B W0
473:               		}
474:               	}
475:               
476:               	BT_SendCommand("s-,FRC-\r", false); // set serialized name  Bluetooth-friendly name
001D90  EB4080     CLR.B W1
001D92  295150     MOV #0x9515, W0
001D94  07FD83     RCALL BT_SendCommand
477:               	if (!BT_CheckResponse(AOK)) {
001D96  294500     MOV #0x9450, W0
001D98  07FDDC     RCALL BT_CheckResponse
001D9A  784080     MOV.B W0, W1
001D9E  E00401     CP0.B W1
001DA0  3200B8     BRA Z, .L139
478:               		return false;
001D9C  EB4000     CLR.B W0
479:               	}
480:               
481:               	//  initial connection parameters 
482:               	BT_SendCommand("st,003c,0000,0064\r", false);
001DA2  784080     MOV.B W0, W1
001DA4  2951E0     MOV #0x951E, W0
001DA6  07FD7A     RCALL BT_SendCommand
483:               	if (!BT_CheckResponse(AOK)) {
001DA8  294500     MOV #0x9450, W0
001DAA  07FDD3     RCALL BT_CheckResponse
001DAC  784080     MOV.B W0, W1
001DB0  E00401     CP0.B W1
001DB2  3200AF     BRA Z, .L139
484:               		return false;
001DAE  EB4000     CLR.B W0
485:               	}
486:               
487:               	// Clear all settings of defined services and characteristics
488:               	BT_SendCommand("pz\r", false);
001DB4  784080     MOV.B W0, W1
001DB6  295310     MOV #0x9531, W0
001DB8  07FD71     RCALL BT_SendCommand
489:               	if (!BT_CheckResponse(AOK)) {
001DBA  294500     MOV #0x9450, W0
001DBC  07FDCA     RCALL BT_CheckResponse
001DBE  784080     MOV.B W0, W1
001DC2  E00401     CP0.B W1
001DC4  3200A6     BRA Z, .L139
490:               		return false;
001DC0  EB4000     CLR.B W0
491:               	}
492:               
493:               	if (version_code >= 33) { // V1.33.4 public services
001DC6  200200     MOV #0x20, W0
001DC8  540F80     SUB W8, W0, [W15]
001DCA  360048     BRA LEU, .L143
494:               		// Public BTLE services and characteristics
495:               
496:               		// heart rate service with standard 16-bit UUID
497:               		BT_SendCommand("ps,"PUBLIC_HR_UUID",\r", false);
001DCC  EB4080     CLR.B W1
001DCE  295350     MOV #0x9535, W0
001DD0  07FD65     RCALL BT_SendCommand
498:               		if (!BT_CheckResponse(AOK)) {
001DD2  294500     MOV #0x9450, W0
001DD4  07FDBE     RCALL BT_CheckResponse
001DD6  784080     MOV.B W0, W1
001DDA  E00401     CP0.B W1
001DDC  32009A     BRA Z, .L139
499:               			return false;
001DD8  EB4000     CLR.B W0
500:               		}
501:               
502:               		// heart rate measurement characteristic
503:               		BT_SendCommand("pc,"PUBLIC_HR_CHAR_HRM",12,04\r", false); //Notify, Read
001DDE  784080     MOV.B W0, W1
001DE0  2953F0     MOV #0x953F, W0
001DE2  07FD5C     RCALL BT_SendCommand
504:               		if (!BT_CheckResponse(AOK)) {
001DE4  294500     MOV #0x9450, W0
001DE6  07FDB5     RCALL BT_CheckResponse
001DE8  784080     MOV.B W0, W1
001DEC  E00401     CP0.B W1
001DEE  320091     BRA Z, .L139
505:               			return false;
001DEA  EB4000     CLR.B W0
506:               		}
507:               
508:               		// heart body sensor location characteristic
509:               		BT_SendCommand("pc,"PUBLIC_HR_CHAR_BSL",06,01\r", false); //Write , Read
001DF0  784080     MOV.B W0, W1
001DF2  2954E0     MOV #0x954E, W0
001DF4  07FD53     RCALL BT_SendCommand
510:               		if (!BT_CheckResponse(AOK)) {
001DF6  294500     MOV #0x9450, W0
001DF8  07FDAC     RCALL BT_CheckResponse
001DFA  784080     MOV.B W0, W1
001DFE  E00401     CP0.B W1
001E00  320088     BRA Z, .L139
511:               			return false;
001DFC  EB4000     CLR.B W0
512:               		}
513:               
514:               		// heart rate control point characteristic
515:               		BT_SendCommand("pc,"PUBLIC_HR_CHAR_RCP",06,01\r", false); //Write , Read
001E02  784080     MOV.B W0, W1
001E04  2955D0     MOV #0x955D, W0
001E06  07FD4A     RCALL BT_SendCommand
516:               		if (!BT_CheckResponse(AOK)) {
001E08  294500     MOV #0x9450, W0
001E0A  07FDA3     RCALL BT_CheckResponse
001E0C  784080     MOV.B W0, W1
001E10  E00401     CP0.B W1
001E12  32007F     BRA Z, .L139
517:               			return false;
001E0E  EB4000     CLR.B W0
518:               		}
519:               
520:               		//  Automation IO service with standard 16-bit UUID
521:               		BT_SendCommand("ps,"PUBLIC_AIO_UUID",\r", false);
001E14  784080     MOV.B W0, W1
001E16  2956C0     MOV #0x956C, W0
001E18  07FD41     RCALL BT_SendCommand
522:               		if (!BT_CheckResponse(AOK)) {
001E1A  294500     MOV #0x9450, W0
001E1C  07FD9A     RCALL BT_CheckResponse
001E1E  784080     MOV.B W0, W1
001E22  E00401     CP0.B W1
001E24  320076     BRA Z, .L139
523:               			return false;
001E20  EB4000     CLR.B W0
524:               		}
525:               
526:               		// Automation IO digital characteristic
527:               		BT_SendCommand("pc,"PUBLIC_AIO_CHAR_DIG",16,08,33\r", false); //Notify, Write , Read
001E26  784080     MOV.B W0, W1
001E28  295760     MOV #0x9576, W0
001E2A  07FD38     RCALL BT_SendCommand
528:               		if (!BT_CheckResponse(AOK)) {
001E2C  294500     MOV #0x9450, W0
001E2E  07FD91     RCALL BT_CheckResponse
001E30  784080     MOV.B W0, W1
001E34  E00401     CP0.B W1
001E36  32006D     BRA Z, .L139
529:               			return false;
001E32  EB4000     CLR.B W0
530:               		}
531:               
532:               		// Automation IO analog characteristic
533:               		BT_SendCommand("pc,"PUBLIC_AIO_CHAR_ANA",16,02,33\r", false); //Notify, Write , Read
001E38  784080     MOV.B W0, W1
001E3A  295880     MOV #0x9588, W0
001E3C  07FD2F     RCALL BT_SendCommand
534:               		if (!BT_CheckResponse(AOK)) {
001E3E  294500     MOV #0x9450, W0
001E40  07FD88     RCALL BT_CheckResponse
001E42  784080     MOV.B W0, W1
001E46  E00401     CP0.B W1
001E48  320064     BRA Z, .L139
535:               			return false;
001E44  EB4000     CLR.B W0
536:               		}
537:               
538:               		// Automation IO agg characteristic
539:               		BT_SendCommand("pc,"PUBLIC_AIO_CHAR_AGG",12,0F,33\r", false); //Notify, Read
001E4A  784080     MOV.B W0, W1
001E4C  2959A0     MOV #0x959A, W0
001E4E  07FD26     RCALL BT_SendCommand
540:               		if (!BT_CheckResponse(AOK)) {
001E50  294500     MOV #0x9450, W0
001E52  07FD7F     RCALL BT_CheckResponse
001E54  784080     MOV.B W0, W1
001E58  E00401     CP0.B W1
001E5A  32005B     BRA Z, .L139
541:               			return false;
001E56  EB4000     CLR.B W0
542:               		}
543:               	}
544:               
545:               	// set power to max
546:               	BT_SendCommand("sp,7\r", false);
001E5C  EB4080     CLR.B W1
001E5E  295AC0     MOV #0x95AC, W0
001E60  07FD1D     RCALL BT_SendCommand
547:               	if (!BT_CheckResponse(AOK)) {
001E62  294500     MOV #0x9450, W0
001E64  07FD76     RCALL BT_CheckResponse
001E66  784080     MOV.B W0, W1
001E6A  E00401     CP0.B W1
001E6C  320052     BRA Z, .L139
548:               		return false;
001E68  EB4000     CLR.B W0
549:               	}
550:               
551:               	// set software version
552:               	BT_SendCommand("sdr,"APP_VERSION_STR"\r", false);
001E6E  784080     MOV.B W0, W1
001E70  295B20     MOV #0x95B2, W0
001E72  07FD14     RCALL BT_SendCommand
553:               	if (!BT_CheckResponse(AOK)) {
001E74  294500     MOV #0x9450, W0
001E76  07FD6D     RCALL BT_CheckResponse
001E78  784080     MOV.B W0, W1
001E7C  E00401     CP0.B W1
001E7E  320049     BRA Z, .L139
554:               		return false;
001E7A  EB4000     CLR.B W0
555:               	}
556:               
557:               	// Private BTLE services and characteristics
558:               
559:               	//Send "ps" to set user defined service UUID
560:               	BT_SendCommand("ps,"PRIVATE_SERVICE",\r", false);
001E80  784080     MOV.B W0, W1
001E82  295BB0     MOV #0x95BB, W0
001E84  07FD0B     RCALL BT_SendCommand
561:               	if (!BT_CheckResponse(AOK)) {
001E86  294500     MOV #0x9450, W0
001E88  07FD64     RCALL BT_CheckResponse
001E8A  784080     MOV.B W0, W1
001E8E  E00401     CP0.B W1
001E90  320040     BRA Z, .L139
562:               		return false;
001E8C  EB4000     CLR.B W0
563:               	}
564:               
565:               	// Custom button characteristic with generated UUID
566:               	BT_SendCommand("pc,"PRIVATE_CHAR_SWITCHES",22,02\r", false); //Notify, Read
001E92  784080     MOV.B W0, W1
001E94  295E10     MOV #0x95E1, W0
001E96  07FD02     RCALL BT_SendCommand
567:               	if (!BT_CheckResponse(AOK)) {
001E98  294500     MOV #0x9450, W0
001E9A  07FD5B     RCALL BT_CheckResponse
001E9C  784080     MOV.B W0, W1
001EA0  E00401     CP0.B W1
001EA2  320037     BRA Z, .L139
568:               		return false;
001E9E  EB4000     CLR.B W0
569:               	}
570:               
571:               	// Custom potentiometer characteristic with generated UUID
572:               	BT_SendCommand("pc,"PRIVATE_CHAR_POTENTIOMETER",22,02\r", false); //Notify, Read
001EA4  784080     MOV.B W0, W1
001EA6  2960C0     MOV #0x960C, W0
001EA8  07FCF9     RCALL BT_SendCommand
573:               	if (!BT_CheckResponse(AOK)) {
001EAA  294500     MOV #0x9450, W0
001EAC  07FD52     RCALL BT_CheckResponse
001EAE  784080     MOV.B W0, W1
001EB2  E00401     CP0.B W1
001EB4  32002E     BRA Z, .L139
574:               		return false;
001EB0  EB4000     CLR.B W0
575:               	}
576:               
577:               	// Custom LED characteristic with generated UUID
578:               	BT_SendCommand("pc,"PRIVATE_CHAR_LEDS",0A,04\r", false); //Write , Read
001EB6  784080     MOV.B W0, W1
001EB8  296370     MOV #0x9637, W0
001EBA  07FCF0     RCALL BT_SendCommand
579:               	if (!BT_CheckResponse(AOK)) {
001EBC  294500     MOV #0x9450, W0
001EBE  07FD49     RCALL BT_CheckResponse
001EC0  784080     MOV.B W0, W1
001EC4  E00401     CP0.B W1
001EC6  320025     BRA Z, .L139
580:               		return false;
001EC2  EB4000     CLR.B W0
581:               	}
582:               
583:               	// Custom RELAY characteristic with generated UUID
584:               	BT_SendCommand("pc,"PRIVATE_CHAR_RELAYS",0A,04\r", false); //Write , Read
001EC8  784080     MOV.B W0, W1
001ECA  296620     MOV #0x9662, W0
001ECC  07FCE7     RCALL BT_SendCommand
585:               	if (!BT_CheckResponse(AOK)) {
001ECE  294500     MOV #0x9450, W0
001ED0  07FD40     RCALL BT_CheckResponse
001ED2  784080     MOV.B W0, W1
001ED6  E00401     CP0.B W1
001ED8  32001C     BRA Z, .L139
586:               		return false;
001ED4  EB4000     CLR.B W0
587:               	}
588:               
589:               	// Custom analog input characteristic with generated UUID //Write , Read
590:               	BT_SendCommand("pc,"PRIVATE_CHAR_ADC_CHAN",0A,04\r", false);
001EDA  784080     MOV.B W0, W1
001EDC  2968D0     MOV #0x968D, W0
001EDE  07FCDE     RCALL BT_SendCommand
591:               	if (!BT_CheckResponse(AOK)) {
001EE0  294500     MOV #0x9450, W0
001EE2  07FD37     RCALL BT_CheckResponse
001EE4  784080     MOV.B W0, W1
001EE8  E00401     CP0.B W1
001EEA  320013     BRA Z, .L139
592:               		return false;
001EE6  EB4000     CLR.B W0
593:               	}
594:               
595:               	// Custom digital device characteristic with generated UUID //Write , Read
596:               	BT_SendCommand("pc,"PRIVATE_CHAR_PIC_SLAVE",0A,0F\r", false);
001EEC  784080     MOV.B W0, W1
001EEE  296B80     MOV #0x96B8, W0
001EF0  07FCD5     RCALL BT_SendCommand
597:               	if (!BT_CheckResponse(AOK)) {
001EF2  294500     MOV #0x9450, W0
001EF4  07FD2E     RCALL BT_CheckResponse
001EF6  784080     MOV.B W0, W1
001EFA  E00401     CP0.B W1
001EFC  32000A     BRA Z, .L139
598:               		return false;
001EF8  EB4000     CLR.B W0
599:               	}
600:               
601:               	BT_SendCommand("wc\r", false); //Command to clear script, just in case there is a script
001EFE  784080     MOV.B W0, W1
001F00  296E30     MOV #0x96E3, W0
001F02  07FCCC     RCALL BT_SendCommand
602:               	if (!BT_CheckResponse(AOK)) {
001F04  294500     MOV #0x9450, W0
001F06  07FD25     RCALL BT_CheckResponse
001F08  784080     MOV.B W0, W1
001F0C  E00401     CP0.B W1
001F0E  320001     BRA Z, .L139
603:               		return false;
001F0A  EB4000     CLR.B W0
604:               	}
605:               
606:               	//Send "R,1" to save changes and reboot
607:               	return BT_RebootEnFlow();
001F10  07FE48     RCALL BT_RebootEnFlow
608:               }
001F12  78044F     MOV [--W15], W8
001F14  FA8000     ULNK
001F16  060000     RETURN
609:               
610:               //**********************************************************************************************************************
611:               // Reboot the module and enable flow control on PIC UART
612:               
613:               bool BT_RebootEnFlow(void)
614:               {
001BA2  BE9F88     MOV.D W8, [W15++]
615:               	bool do_ls = true, good_boot; // causes a control lockup if enabled
616:               	//Send "R,1" to save changes and reboot
617:               	BT_SendCommand("r,1\r", false); //Force reboot
001BA4  EB4080     CLR.B W1
001BA6  294A50     MOV #0x94A5, W0
001BA8  07FE79     RCALL BT_SendCommand
618:               	if (!BT_CheckResponse("Reboot\r\n")) {
001BAA  294AA0     MOV #0x94AA, W0
001BAC  07FED2     RCALL BT_CheckResponse
001BB0  E00400     CP0.B W0
001BB2  320049     BRA Z, .L101
619:               		return false;
001BAE  EB4400     CLR.B W8
620:               	}
621:               
622:               	//Disable UART while TX line from RN is low during reset and bootup
623:               	StartTimer(TMR_RN_COMMS, 1000);
001BB4  203E81     MOV #0x3E8, W1
001BB6  B3C020     MOV.B #0x2, W0
001BB8  070643     RCALL StartTimer
624:               	U1MODE &= 0x7FFF;
001BBA  A9E221     BCLR 0x221, #7
625:               	while (U1RX_PORT) {
001BBE  370004     BRA .L102
001BC8  AB42CA     BTST PORTB, #2
001BCA  3AFFFA     BRA NZ, .L104
626:               		if (TimerDone(TMR_RN_COMMS)) {
001BBC  B3C028     MOV.B #0x2, W8
001BC0  784008     MOV.B W8, W0
001BC2  070644     RCALL TimerDone
001BC4  E00400     CP0.B W0
001BC6  3A0002     BRA NZ, .L103
627:               			break;
628:               		}
629:               	}
630:               	StartTimer(TMR_RN_COMMS, 4000);
001BCC  20FA01     MOV #0xFA0, W1
001BCE  B3C020     MOV.B #0x2, W0
001BD0  070637     RCALL StartTimer
631:               	while (!U1RX_PORT) {
001BD4  370004     BRA .L105
001BDE  AB42CA     BTST PORTB, #2
001BE0  32FFFA     BRA Z, .L107
632:               		if (TimerDone(TMR_RN_COMMS)) {
001BD2  B3C028     MOV.B #0x2, W8
001BD6  784008     MOV.B W8, W0
001BD8  070639     RCALL TimerDone
001BDA  E00400     CP0.B W0
001BDC  3A0002     BRA NZ, .L106
633:               			break;
634:               		}
635:               	}
636:               	UART_RX_IF = 0; //Clear UART Receive interrupt flag
001BE2  A96085     BCLR 0x85, #3
637:               	U1MODE |= 0x8200; //Enable UART, use RTC/CTS flow control
001BE4  282000     MOV #0x8200, W0
001BE6  B72220     IOR U1MODE
638:               	U1STA |= 0x0400; //Enable transmit
001BE8  A84223     BSET 0x223, #2
639:               
640:               	//Clear out NULL char(s) and other garbage if present after reboot, wait for first char of CMD\r\n response
641:               	StartTimer(TMR_RN_COMMS, 4000);
001BEA  20FA01     MOV #0xFA0, W1
001BEC  B3C020     MOV.B #0x2, W0
001BEE  070628     RCALL StartTimer
642:               	while (UART_ReadRxBuffer() != 'C') {
001BF0  B3C438     MOV.B #0x43, W8
001BF4  370007     BRA .L108
001C04  070599     RCALL UART_ReadRxBuffer
001C06  504F88     SUB.B W0, W8, [W15]
001C08  3AFFFA     BRA NZ, .L119
643:               		while (!UART_IsNewRxData()) {
001BFE  070593     RCALL UART_IsNewRxData
001C00  E00400     CP0.B W0
001C02  32FFF9     BRA Z, .L109
644:               			if (TimerDone(TMR_RN_COMMS)) { //Check if timed out
001BF2  B3C029     MOV.B #0x2, W9
001BF6  784009     MOV.B W9, W0
001BF8  070629     RCALL TimerDone
001BFA  E00400     CP0.B W0
001BFC  3A0023     BRA NZ, .L115
645:               				return false; //If timed out then return failure
001C44  EB4400     CLR.B W8
646:               			}
647:               		}
648:               	}
649:               
650:               	good_boot = BT_CheckResponse("MD\r\n"); //Check that we received CMD indicating reboot is done
001C0A  294B30     MOV #0x94B3, W0
001C0C  07FEA2     RCALL BT_CheckResponse
001C0E  784400     MOV.B W0, W8
651:               
652:               	if (do_ls) {
653:               		BT_SendCommand("LS\r", false); // list services
001C10  EB4080     CLR.B W1
001C12  294B80     MOV #0x94B8, W0
001C14  07FE43     RCALL BT_SendCommand
654:               		WaitMs(10);
001C16  2000A0     MOV #0xA, W0
001C18  070622     RCALL WaitMs
655:               		U1MODE &= 0x7FFF;
001C1A  A9E221     BCLR 0x221, #7
656:               		WaitMs(1000);
001C1C  203E80     MOV #0x3E8, W0
001C1E  07061F     RCALL WaitMs
657:               		UART_RX_IF = 0; //Clear UART Receive interrupt flag
001C20  A96085     BCLR 0x85, #3
658:               		U1MODE |= 0x8200; //Enable UART, use RTC/CTS flow control
001C22  282000     MOV #0x8200, W0
001C24  B72220     IOR U1MODE
659:               		U1STA |= 0x0400; //Enable transmit
001C26  A84223     BSET 0x223, #2
660:               
661:               		//flush UART RX buffer as a precaution before starting app state machine
662:               		while (UART_IsNewRxData()) { //While buffer contains old data
001C2A  370006     BRA .L118
001C38  070576     RCALL UART_IsNewRxData
001C3A  E00400     CP0.B W0
001C3C  3AFFF7     BRA NZ, .L113
663:               			UART_ReadRxBuffer(); //Keep reading until empty
001C2C  070585     RCALL UART_ReadRxBuffer
664:               			if (!UART_IsNewRxData()) {
001C2E  07057B     RCALL UART_IsNewRxData
001C30  E00400     CP0.B W0
001C32  3A0002     BRA NZ, .L118
665:               				WaitMs(100);
001C28  200649     MOV #0x64, W9
001C34  780009     MOV W9, W0
001C36  070613     RCALL WaitMs
666:               			}
667:               		}
668:               		//Clear any UART error bits
669:               		U1STAbits.FERR = 0;
001C3E  A94222     BCLR U1STA, #2
670:               		U1STAbits.PERR = 0;
001C40  A96222     BCLR U1STA, #3
671:               	}
672:               
673:               	return good_boot; //Check that we received CMD indicating reboot is done	
001C42  370001     BRA .L101
674:               }
001C46  784008     MOV.B W8, W0
001C48  BE044F     MOV.D [--W15], W8
001C4A  060000     RETURN
675:               
676:               #ifdef VERIFY_RN_FW_VER
677:               //Retrieve firmware version on module and check against the required version
678:               //Returns true if version is correct; false if not or communication failure
679:               
680:               uint16_t BT_CheckFwVer(void)
681:               {
001C4C  FA007E     LNK #0x7E
001C4E  781F88     MOV W8, [W15++]
682:               	char fpVer[20];
683:               	char *pfpVer = fpVer;
684:               	char strVer[100];
685:               	char *pstrVer = strVer;
001C9E  4700F4     ADD W14, #0x14, W1
001CA0  370001     BRA .L126
001CA2  4700F4     ADD W14, #0x14, W1
686:               	uint16_t verMajor,
687:               		verMinor,
688:               		verPatch;
689:               
690:               	//flush UART RX buffer just in case there's old data
691:               	while (UART_IsNewRxData()) { //While buffer contains old data
001C52  370003     BRA .L121
001C5A  070565     RCALL UART_IsNewRxData
001C5C  E00400     CP0.B W0
001C5E  3AFFFA     BRA NZ, .L122
692:               		UART_ReadRxBuffer(); //Keep reading until empty
001C54  070571     RCALL UART_ReadRxBuffer
693:               		WaitMs(100);
001C50  200648     MOV #0x64, W8
001C56  780008     MOV W8, W0
001C58  070602     RCALL WaitMs
694:               	}
695:               
696:               	StartTimer(TMR_RN_COMMS, 2000);
001C60  207D01     MOV #0x7D0, W1
001C62  B3C020     MOV.B #0x2, W0
001C64  0705ED     RCALL StartTimer
697:               	BT_SendCommand("v\r", false); // Get firmware version
001C66  EB4080     CLR.B W1
001C68  294BC0     MOV #0x94BC, W0
001C6A  07FE18     RCALL BT_SendCommand
698:               	while (!BT_ReceivePacket(strVer)) {
001C6E  370004     BRA .L123
001C78  470074     ADD W14, #0x14, W0
001C7A  07FDE1     RCALL BT_ReceivePacket
001C7C  E00400     CP0.B W0
001C7E  32FFF8     BRA Z, .L125
699:               		if (TimerDone(TMR_RN_COMMS)) {
001C6C  B3C028     MOV.B #0x2, W8
001C70  784008     MOV.B W8, W0
001C72  0705EC     RCALL TimerDone
001C74  E00400     CP0.B W0
001C76  3A0040     BRA NZ, .L132
700:               			return false;
001CF8  EB0000     CLR W0
001CFA  370001     BRA .L124
701:               		}
702:               	}
703:               
704:               	//Skip to first digit
705:               	while ((*pstrVer < '0' || *pstrVer > '9') && *pstrVer != NULL) {
001C80  90504E     MOV.B [W14+20], W0
001C82  B3CD01     MOV.B #0xD0, W1
001C84  404081     ADD.B W0, W1, W1
001C86  50CFE9     SUB.B W1, #0x9, [W15]
001C88  36000A     BRA LEU, .L133
001C8A  E00400     CP0.B W0
001C8C  32000A     BRA Z, .L134
001C8E  470075     ADD W14, #0x15, W0
001C90  B3CD04     MOV.B #0xD0, W4
001C92  780080     MOV W0, W1
001C94  784130     MOV.B [W0++], W2
001C96  414184     ADD.B W2, W4, W3
001C98  51CFE9     SUB.B W3, #0x9, [W15]
001C9A  3E0008     BRA GTU, .L127
001C9C  370003     BRA .L126
001CA4  78028E     MOV W14, W5
001CAC  E00402     CP0.B W2
001CAE  3AFFF1     BRA NZ, .L129
001CB0  37FFF9     BRA .L126
706:               		pstrVer++;
707:               	}
708:               	//Extract version number
709:               	while ((*pstrVer >= '0' && *pstrVer <= '9') || *pstrVer == '.') {
001CA6  B3CD03     MOV.B #0xD0, W3
001CA8  B3C2E4     MOV.B #0x2E, W4
001CAA  370004     BRA .L128
001CB4  784031     MOV.B [W1++], W0
001CB6  404103     ADD.B W0, W3, W2
001CB8  514FE9     SUB.B W2, #0x9, [W15]
001CBA  36FFFB     BRA LEU, .L130
001CBC  504F84     SUB.B W0, W4, [W15]
001CBE  32FFF9     BRA Z, .L130
710:               		*pfpVer = *pstrVer;
001CB2  785A80     MOV.B W0, [W5++]
711:               		pfpVer++;
712:               		pstrVer++;
713:               	}
714:               	*pfpVer = '\0';
001CC0  EB4A80     CLR.B [W5]
715:               
716:               	//Tokenize and convert to unsigned
717:               	sscanf(fpVer, "%u.%u.%u", &verMajor, &verMinor, &verPatch);
001CC2  2007C0     MOV #0x7C, W0
001CC4  471F80     ADD W14, W0, [W15++]
001CC6  2007A1     MOV #0x7A, W1
001CC8  471F81     ADD W14, W1, [W15++]
001CCA  500064     SUB W0, #0x4, W0
001CCC  471F80     ADD W14, W0, [W15++]
001CCE  294BF0     MOV #0x94BF, W0
001CD0  781F80     MOV W0, [W15++]
001CD2  78000E     MOV W14, W0
001CD4  07F592     RCALL __sscanf_cdnopuxX
718:               
719:               	//Verify version number
720:               	if ((verMajor != RN_FW_VER_MAJOR133) && (verMajor != RN_FW_VER_MAJOR)) {
001CD6  5787E8     SUB W15, #0x8, W15
001CDA  9038CE     MOV [W14+120], W1
001CDC  508FE1     SUB W1, #0x1, [W15]
001CDE  3A000F     BRA NZ, .L124
721:               		return false;
001CD8  EB0000     CLR W0
722:               	}
723:               	if ((verMinor != RN_FW_VER_MINOR133) && (verMinor != RN_FW_VER_MINOR)) {
001CE0  90385E     MOV [W14+122], W0
001CE2  200211     MOV #0x21, W1
001CE4  500F81     SUB W0, W1, [W15]
001CE6  320002     BRA Z, .L131
001CE8  500FF7     SUB W0, #0x17, [W15]
001CEA  3A0008     BRA NZ, .L136
724:               		return false;
001CFC  EB0000     CLR W0
725:               	}
726:               	if ((verPatch != RN_FW_VER_PATCH133) && (verPatch != RN_FW_VER_PATCH)) {
001CEC  9038EE     MOV [W14+124], W1
001CEE  5080E4     SUB W1, #0x4, W1
001CF0  508FE1     SUB W1, #0x1, [W15]
001CF2  360005     BRA LEU, .L124
727:               		return false;
001CF4  EB0000     CLR W0
001CF6  370003     BRA .L124
728:               	}
729:               
730:               	return verMinor;
731:               }
001CFE  78044F     MOV [--W15], W8
001D00  FA8000     ULNK
001D02  060000     RETURN
732:               #endif //VERIFY_RN_FW_VER
---  /root/ble/fac_relay_clone/automio.c  ---------------------------------------------------------------
1:                 #include "automio.h"
2:                 
3:                 static void gpio_set(struct ble_automation_io *aio, uint8_t value)
4:                 {
5:                 	uint32_t pin = aio->gpio.pin_number;
6:                 
7:                 	if (value) {
8:                 		//		nrf_gpio_pin_set(pin);
9:                 	} else {
10:                		//		nrf_gpio_pin_clear(pin);
11:                	}
12:                }
13:                
14:                static uint8_t gpio_get(struct ble_automation_io *aio)
15:                {
16:                	uint8_t val;
17:                	if (aio->gpio.output) {
18:                		val = BLE_DIGITAL_OUTPUT_STATE;
19:                	} else {
20:                		//		val = nrf_gpio_pin_read(aio->gpio.pin_number);
21:                	}
22:                
23:                	return val;
24:                }
002878  B3C030     MOV.B #0x3, W0
00287A  060000     RETURN
25:                
26:                void ble_automation_io_refresh(struct ble_automation_io *aio)
27:                {
00287C  781F88     MOV W8, [W15++]
00287E  780400     MOV W0, W8
28:                	uint8_t value = gpio_get(aio);
002880  780008     MOV W8, W0
002882  07FFFA     RCALL .Letext0, .LFE3, _gpio_get, .Ltext0, .LFB1
29:                	if (value != aio->value_digital) {
30:                		// TODO: notify clients
31:                	}
32:                	aio->value_digital = value;
002884  784C00     MOV.B W0, [W8]
33:                }
002886  78044F     MOV [--W15], W8
002888  060000     RETURN
34:                
35:                static void init_gpio(struct ble_automation_io *aio)
36:                {
37:                	uint32_t pin = aio->gpio.pin_number;
38:                	bool output = aio->gpio.output;
39:                
40:                	if (output) {
41:                		//		nrf_gpio_cfg_output(pin);
42:                		gpio_set(aio, (int) aio->gpio.default_value);
43:                		ble_automation_io_refresh(aio);
44:                	} else {
45:                		//		nrf_gpio_cfg_input(pin, NRF_GPIO_PIN_NOPULL);
46:                	}
47:                }
---  /root/ble/fac_relay_clone/app.c  -------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        app.c
29:                 * Date:        July 24, 2014
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 */
33:                
34:                // *****************************************************************************
35:                // *****************************************************************************
36:                // Section: Included Files
37:                // *****************************************************************************
38:                // *****************************************************************************
39:                
40:                #include <xc.h>
41:                #include <stdint.h>
42:                #include <stdbool.h>
43:                #include <stdio.h>
44:                #include <string.h>
45:                #include "app.h"
46:                #include "config.h"
47:                #include "timers.h"
48:                #include "uart.h"
49:                #include "bluetooth.h"
50:                #include "adc.h"
51:                #include "leds.h"
52:                #include "switches.h"
53:                #include "rtcc.h"
54:                #include "sleep.h"
55:                #include "spi.h"
56:                #include "link.h"
57:                #include "automio.h"
58:                
59:                APP_DATA appData;
60:                ADC_DATA adcData;
61:                AIO_DATA aioData;
62:                
63:                //Primary application state machine
64:                
65:                void APP_Tasks(void)
66:                {
67:                #ifdef USE_SLEEP                //see config.h, Application setting section
68:                	APP_STATE_T savedState;
69:                	int16_t potDiff;
70:                
71:                	//Has inactivity timer expired?
72:                	if (appData.sleepFlag) {
73:                		savedState = appData.state; //Save context
74:                		appData.state = APP_SLEEP; //Enter sleep state
75:                	}
76:                #endif
77:                
78:                	//Update LED outputs
79:                	LED_Tasks();
001FD8  0700F8     RCALL LED_Tasks
80:                
81:                	switch (appData.state) {
001FDA  8052E0     MOV appData, W0
001FDC  500FE1     SUB W0, #0x1, [W15]
001FDE  32000F     BRA Z, .L20
001FE0  390005     BRA NC, .L19
001FE2  500FE2     SUB W0, #0x2, [W15]
001FE4  32000F     BRA Z, .L21
001FE6  500FE3     SUB W0, #0x3, [W15]
001FE8  3A00EF     BRA NZ, .L17
001FEA  370013     BRA .L37
82:                		//Initial state
83:                	case APP_INITIALIZE:
84:                		if (APP_Initialize()) {
001FEC  07FF95     RCALL APP_Initialize
001FEE  E00400     CP0.B W0
001FF0  320003     BRA Z, .L23
85:                			appData.state = APP_BLUETOOTH_ADVERTISE;
001FF2  200020     MOV #0x2, W0
001FF4  8852E0     MOV W0, appData
001FF6  3700E8     BRA .L17
86:                		} else {
87:                			appData.state = APP_INITIALIZATION_ERROR;
001FF8  200010     MOV #0x1, W0
001FFA  8852E0     MOV W0, appData
001FFC  3700E5     BRA .L17
88:                		}
89:                		break;
90:                
91:                		//Initialization failed
92:                	case APP_INITIALIZATION_ERROR:
93:                		LED_SET_LightShow(LED_ERROR);
001FFE  200030     MOV #0x3, W0
002000  07013F     RCALL LED_SET_LightShow
94:                		break;
002002  3700E2     BRA .L17
95:                
96:                		//We're not connected to a device - advertise mode
97:                	case APP_BLUETOOTH_ADVERTISE:
98:                		LED_SET_LightShow(LED_BTLE_ADVERTISING);
002004  200010     MOV #0x1, W0
002006  07013C     RCALL LED_SET_LightShow
99:                		if (BT_CONNECTED) {
002008  AB22C2     BTST PORTA, #1
00200A  3200DE     BRA Z, .L17
100:               			appData.state = APP_BLUETOOTH_PAIRED;
00200C  200030     MOV #0x3, W0
00200E  8852E0     MOV W0, appData
002010  3700DB     BRA .L17
101:               		}
102:               		break;
103:               
104:               		//We are connected to a BTLE device
105:               	case APP_BLUETOOTH_PAIRED:
106:               		//Update LEDs
107:               		LED_SET_LightShow(LED_BTLE_PAIRED);
002012  200020     MOV #0x2, W0
002014  070135     RCALL LED_SET_LightShow
108:               		//Check to see if we are still connected; return to advertise state if not
109:               		if (!BT_CONNECTED) {
002016  AB22C2     BTST PORTA, #1
002018  3A0006     BRA NZ, .L24
110:               			appData.update_packet = false;
00201A  EF6B27     CLR.B 0xB27
111:               			LED_SET_LightShow(LED_BTLE_ADVERTISING);
00201C  200010     MOV #0x1, W0
00201E  070130     RCALL LED_SET_LightShow
112:               			appData.state = APP_BLUETOOTH_ADVERTISE;
002020  200020     MOV #0x2, W0
002022  8852E0     MOV W0, appData
113:               			break;
002024  3700D1     BRA .L17
114:               		}
115:               
116:               		//Check if switches have changed and debounce timers are expired
117:               		Switch_Tasks();
002026  0703DF     RCALL Switch_Tasks
118:               		if (appData.sendSwitches) { //New switch status to send?
002028  E24B28     CP0.B 0xB28
00202A  32001A     BRA Z, .L25
119:               			//Form message
120:               			sprintf(appData.transmit_packet, "shw,"PRIVATE_CHAR_SWITCHES_H",%d%d%d%d\r", appData.sw1, appData.sw2, appData.sw3, appData.sw4);
00202C  20B383     MOV #0xB38, W3
00202E  784193     MOV.B [W3], W3
002030  20B372     MOV #0xB37, W2
002032  784112     MOV.B [W2], W2
002034  20B361     MOV #0xB36, W1
002036  784091     MOV.B [W1], W1
002038  BFCB35     MOV.B 0xB35, WREG
00203A  FB8183     ZE W3, W3
00203C  781F83     MOV W3, [W15++]
00203E  FB8102     ZE W2, W2
002040  781F82     MOV W2, [W15++]
002042  FB8081     ZE W1, W1
002044  781F81     MOV W1, [W15++]
002046  FB8000     ZE W0, W0
002048  781F80     MOV W0, [W15++]
00204A  296E80     MOV #0x96E8, W0
00204C  781F80     MOV W0, [W15++]
00204E  20AC20     MOV #0xAC2, W0
002050  07F58B     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
121:               			//Try to transmit the message; reset flag if successful
122:               			if (BT_SendCommand(appData.transmit_packet, true)) {
002052  B3C011     MOV.B #0x1, W1
002054  20AC20     MOV #0xAC2, W0
002056  07FC22     RCALL BT_SendCommand
002058  5787EA     SUB W15, #0xA, W15
00205A  E00400     CP0.B W0
00205C  320001     BRA Z, .L25
123:               				appData.sendSwitches = false;
00205E  EF6B28     CLR.B 0xB28
124:               			}
125:               		}
126:               
127:               		//Process ADC accumulator value if oversampling is complete
128:               		if (appData.accumReady) {
002060  E24B3E     CP0.B 0xB3E
002062  320003     BRA Z, .L26
129:               			ADC_ProcAccum();
002064  07032C     RCALL ADC_ProcAccum
130:               #ifdef USE_SLEEP                //see config.h, Application setting section
131:               			potDiff = appData.potValue - appData.potValueOld; //Reset the inactivity sleep timer if pot has changed
132:               			if (potDiff > POT_KEEP_AWAKE_DELTA || potDiff < -POT_KEEP_AWAKE_DELTA) {
133:               				SleepTimerReset();
134:               			}
135:               #endif
136:               			appData.accumReady = false; //Clear app flags
002066  EF6B3E     CLR.B 0xB3E
137:               			appData.ADCinUse = false;
002068  EF6B3F     CLR.B 0xB3F
138:               		}
139:               
140:               		// packet transmission queue, TimerDone puts packet in the transmission stream
141:               
142:               		//Start new ADC read if timer expired, not currently sampling, and not waiting to process accumulator
143:               		if (TimerDone(TMR_ADC) && appData.ADCinUse == false) {
00206A  B3C030     MOV.B #0x3, W0
00206C  0703EF     RCALL TimerDone
00206E  E00400     CP0.B W0
002070  320008     BRA Z, .L27
002072  E24B3F     CP0.B 0xB3F
002074  3A0006     BRA NZ, .L27
144:               			if (ADC_Tasks()) {
002076  0702D6     RCALL ADC_Tasks
002078  E00400     CP0.B W0
00207A  320003     BRA Z, .L27
145:               				StartTimer(TMR_ADC, ADC_REFRESH_MS);
00207C  2000A1     MOV #0xA, W1
00207E  B3C030     MOV.B #0x3, W0
002080  0703DF     RCALL StartTimer
146:               			} //Restart timer once module is up and running
147:               		}
148:               
149:               		//Transmit new potentiometer reading?
150:               		if (TimerDone(TMR_POT)) {
002082  B3C040     MOV.B #0x4, W0
002084  0703E3     RCALL TimerDone
002086  E00400     CP0.B W0
002088  320017     BRA Z, .L28
151:               			//Send message only if pot value has changed
152:               			if (appData.potValue != appData.potValueLastTX) {
00208A  805A20     MOV 0xB44, W0
00208C  E30B48     CP .L66
00208E  320011     BRA Z, .L29
153:               				//Form message
154:               				sprintf(appData.transmit_packet, "shw,"PRIVATE_CHAR_POTENTIOMETER_H",%04d\r\n", appData.potValue);
002090  781F80     MOV W0, [W15++]
002092  296FB0     MOV #0x96FB, W0
002094  781F80     MOV W0, [W15++]
002096  20AC20     MOV #0xAC2, W0
002098  07F567     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
155:               				//Try to transmit the message; reset timer if successful
156:               				if (BT_SendCommand(appData.transmit_packet, true)) {
00209A  B3C011     MOV.B #0x1, W1
00209C  20AC20     MOV #0xAC2, W0
00209E  07FBFE     RCALL BT_SendCommand
0020A0  5787E4     SUB W15, #0x4, W15
0020A2  E00400     CP0.B W0
0020A4  320009     BRA Z, .L28
157:               					appData.potValueLastTX = appData.potValue;
0020A6  F80B44     PUSH 0xB44
0020A8  F90B48     POP .L66
158:               					StartTimer(TMR_POT, POT_TX_MS);
0020AA  200321     MOV #0x32, W1
0020AC  B3C040     MOV.B #0x4, W0
0020AE  0703C8     RCALL StartTimer
0020B0  370003     BRA .L28
159:               				}
160:               			} else {
161:               				StartTimer(TMR_POT, POT_TX_MS);
0020B2  200321     MOV #0x32, W1
0020B4  B3C040     MOV.B #0x4, W0
0020B6  0703C4     RCALL StartTimer
162:               			} //value not changed - skip this transmission
163:               		}
164:               
165:               		if (TimerDone(TMR_BATT)) {
0020B8  B3C0D0     MOV.B #0xD, W0
0020BA  0703C8     RCALL TimerDone
0020BC  E00400     CP0.B W0
0020BE  320011     BRA Z, .L30
166:               			//Form message
167:               			sprintf(appData.transmit_packet, "suw,"PUBLIC_BATT_CHAR_BL",%02d\r", (appData.potValue >> 6)&0b00111111);
0020C0  805A20     MOV 0xB44, W0
0020C2  DE0046     LSR W0, #6, W0
0020C4  B203F0     AND #0x3F, W0
0020C6  781F80     MOV W0, [W15++]
0020C8  2970B0     MOV #0x970B, W0
0020CA  781F80     MOV W0, [W15++]
0020CC  20AC20     MOV #0xAC2, W0
0020CE  07F54C     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
168:               			//Try to transmit the message; reset timer if successful
169:               			if (BT_SendCommand(appData.transmit_packet, true)) {
0020D0  B3C011     MOV.B #0x1, W1
0020D2  20AC20     MOV #0xAC2, W0
0020D4  07FBE3     RCALL BT_SendCommand
0020D6  5787E4     SUB W15, #0x4, W15
0020D8  E00400     CP0.B W0
0020DA  320003     BRA Z, .L30
170:               				StartTimer(TMR_BATT, BATT_TX_MS);
0020DC  200641     MOV #0x64, W1
0020DE  B3C0D0     MOV.B #0xD, W0
0020E0  0703AF     RCALL StartTimer
171:               			}
172:               		}
173:               
174:               		if (TimerDone(TMR_HR)) {
0020E2  B3C0C0     MOV.B #0xC, W0
0020E4  0703B3     RCALL TimerDone
0020E6  E00400     CP0.B W0
0020E8  320022     BRA Z, .L31
175:               			//Form message
176:               			sprintf(appData.transmit_packet, "suw,"PUBLIC_HR_CHAR_HRM",%02x%02x%02x%02x\r", 0x08, (appData.potValue >> 4)&0xff, appData.hrmEnergy & 0x00ff, appData.hrmEnergy >> 8); // format mask and ADC data
0020EA  805A61     MOV 0xB4C, W1
0020EC  DE0848     LSR W1, #8, W0
0020EE  781F80     MOV W0, [W15++]
0020F0  200FF0     MOV #0xFF, W0
0020F2  609F80     AND W1, W0, [W15++]
0020F4  805A21     MOV 0xB44, W1
0020F6  DE08C4     LSR W1, #4, W1
0020F8  609F80     AND W1, W0, [W15++]
0020FA  200080     MOV #0x8, W0
0020FC  781F80     MOV W0, [W15++]
0020FE  2971A0     MOV #0x971A, W0
002100  781F80     MOV W0, [W15++]
002102  20AC20     MOV #0xAC2, W0
002104  07F531     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
177:               			//Try to transmit the message; reset timer if successful
178:               			if (BT_SendCommand(appData.transmit_packet, true)) {
002106  B3C011     MOV.B #0x1, W1
002108  20AC20     MOV #0xAC2, W0
00210A  07FBC8     RCALL BT_SendCommand
00210C  5787EA     SUB W15, #0xA, W15
00210E  E00400     CP0.B W0
002110  32000E     BRA Z, .L31
179:               				StartTimer(TMR_HR, HR_TX_MS);
002112  200501     MOV #0x50, W1
002114  B3C0C0     MOV.B #0xC, W0
002116  070394     RCALL StartTimer
180:               				sprintf(appData.transmit_packet, "suw,"PUBLIC_HR_CHAR_BSL",%02x\r", 3);
002118  200030     MOV #0x3, W0
00211A  781F80     MOV W0, [W15++]
00211C  297350     MOV #0x9735, W0
00211E  781F80     MOV W0, [W15++]
002120  20AC20     MOV #0xAC2, W0
002122  07F522     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
181:               				BT_SendCommand(appData.transmit_packet, false);
002124  EB4080     CLR.B W1
002126  20AC20     MOV #0xAC2, W0
002128  07FBB9     RCALL BT_SendCommand
182:               				appData.hrmEnergy++;
00212A  EC2B4C     INC 0xB4C
00212C  5787E4     SUB W15, #0x4, W15
183:               			}
184:               		}
185:               
186:               		if (TimerDone(TMR_AIO_DIG)) {
00212E  B3C0E0     MOV.B #0xE, W0
002130  07038D     RCALL TimerDone
002132  E00400     CP0.B W0
002134  32000D     BRA Z, .L32
187:               			//Form message
188:               			sprintf(appData.transmit_packet, "shw,"PUBLIC_AIO_CHAR_DIG_H",0101010101010101\r"); // digital data
002136  297440     MOV #0x9744, W0
002138  20AC21     MOV #0xAC2, W1
00213A  09001A     REPEAT #0x1A
00213C  7858B0     MOV.B [W0++], [W1++]
00213E  B101B0     SUB #0x1B, W0
189:               			//Try to transmit the message; reset timer if successful
190:               			if (BT_SendCommand(appData.transmit_packet, true)) {
002140  B3C011     MOV.B #0x1, W1
002142  20AC20     MOV #0xAC2, W0
002144  07FBAB     RCALL BT_SendCommand
002146  E00400     CP0.B W0
002148  320003     BRA Z, .L32
191:               				StartTimer(TMR_AIO_DIG, AIO_TX_MS);
00214A  200281     MOV #0x28, W1
00214C  B3C0E0     MOV.B #0xE, W0
00214E  070378     RCALL StartTimer
192:               			}
193:               		}
194:               
195:               		//Process any new messages received from RN module
196:               		appData.got_packet = BT_ReceivePacket(appData.receive_packet); //Get new message if one has been received from the RN4020
002150  20A5E0     MOV #0xA5E, W0
002152  07FB75     RCALL BT_ReceivePacket
002154  B7EB26     MOV.B WREG, 0xB26
197:               		if (appData.got_packet == true) { //true if new packet received
002156  E00400     CP0.B W0
002158  320037     BRA Z, .L17
198:               
199:               			appData.packet_data = Get_Link_Packet();
00215A  070343     RCALL Get_Link_Packet
00215C  885A70     MOV W0, .L74
200:               			appData.packet_data->dac1 = appData.potValue & 0xff;
00215E  20B441     MOV #0xB44, W1
002160  784091     MOV.B [W1], W1
002162  984011     MOV.B W1, [W0+1]
201:               			appData.packet_data->dac2 = appData.potValue >> 8;
002164  805A70     MOV .L74, W0
002166  20B451     MOV #0xB45, W1
002168  784091     MOV.B [W1], W1
00216A  984021     MOV.B W1, [W0+2]
202:               			Write_Link_Packet((uint8_t *) appData.packet_data, true);
00216C  B3C011     MOV.B #0x1, W1
00216E  805A70     MOV .L74, W0
002170  070313     RCALL Write_Link_Packet
203:               
204:               			if (strstr(appData.receive_packet, "WV,001E,")) { //Check for LED update message 1.23
002172  2975F1     MOV #0x975F, W1
002174  20A5E0     MOV #0xA5E, W0
002176  07F30E     RCALL _strstr
002178  E00000     CP0 W0
00217A  320003     BRA Z, .L33
205:               				GetNewLEDs(); //Latch new LED values
00217C  070083     RCALL GetNewLEDs
206:               				appData.update_packet = true;
00217E  B3C010     MOV.B #0x1, W0
002180  B7EB27     MOV.B WREG, 0xB27
207:               			}
208:               			if (strstr(appData.receive_packet, "WV,"PRIVATE_CHAR_LEDS_H",")) { //Check for LED update message 1.33
002182  297681     MOV #0x9768, W1
002184  20A5E0     MOV #0xA5E, W0
002186  07F306     RCALL _strstr
002188  E00000     CP0 W0
00218A  320003     BRA Z, .L34
209:               				GetNewLEDs(); //Latch new LED values
00218C  07007B     RCALL GetNewLEDs
210:               				appData.update_packet = true;
00218E  B3C010     MOV.B #0x1, W0
002190  B7EB27     MOV.B WREG, 0xB27
211:               			}
212:               			//
213:               			//Other message handling can be added here
214:               			//
215:               			//receive new SPI ADC channel
216:               			if (strstr(appData.receive_packet, "WV,"PRIVATE_CHAR_ADC_CHAN_H",")) {
002192  297711     MOV #0x9771, W1
002194  20A5E0     MOV #0xA5E, W0
002196  07F2FE     RCALL _strstr
002198  E00000     CP0 W0
00219A  320001     BRA Z, .L35
217:               				GetNewADC_Chan(); // new ADC config data
00219C  070295     RCALL GetNewADC_Chan
218:               			}
219:               			//receive new SPI SLAVE request
220:               			if (strstr(appData.receive_packet, "WV,"PRIVATE_CHAR_PIC_SLAVE_H",")) {
221:               
222:               			}
223:               			// HRM energy expended reset
224:               			if (strstr(appData.receive_packet, "WV,"PUBLIC_HR_CHAR_RCP_H",01.")) {
00219E  2977A1     MOV #0x977A, W1
0021A0  20A5E0     MOV #0xA5E, W0
0021A2  07F2F8     RCALL _strstr
0021A4  E00000     CP0 W0
0021A6  320001     BRA Z, .L36
225:               				appData.hrmEnergy = 0;
0021A8  EF2B4C     CLR 0xB4C
226:               			}
227:               			//receive new BATTERY request
228:               			if (strstr(appData.receive_packet, "RV,"PUBLIC_BATT_CHAR_H".")) {
0021AA  297861     MOV #0x9786, W1
0021AC  20A5E0     MOV #0xA5E, W0
0021AE  07F2F2     RCALL _strstr
0021B0  E00000     CP0 W0
0021B2  32000A     BRA Z, .L17
229:               				//Form message
230:               				sprintf(appData.transmit_packet, "suw,"PUBLIC_BATT_CHAR_BL",%d\r", 63);
0021B4  2003F0     MOV #0x3F, W0
0021B6  781F80     MOV W0, [W15++]
0021B8  2978F0     MOV #0x978F, W0
0021BA  781F80     MOV W0, [W15++]
0021BC  20AC20     MOV #0xAC2, W0
0021BE  07F4D4     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
231:               				//Try to transmit the message; reset timer if successful
232:               				BT_SendCommand(appData.transmit_packet, false);
0021C0  EB4080     CLR.B W1
0021C2  20AC20     MOV #0xAC2, W0
0021C4  07FB6B     RCALL BT_SendCommand
0021C6  5787E4     SUB W15, #0x4, W15
233:               			}
234:               		}
235:               		break;
236:               
237:               #ifdef USE_SLEEP                //see config.h, Application setting section        
238:               		//Put micro and RN module to sleep - any button press will cause wake up
239:               	case APP_SLEEP:
240:               		appData.sleepFlag = 0; //clear flag and call sleep function
241:               		APP_SleepNow();
242:               		appData.state = savedState; //Woken from sleep; restore state
243:               		break;
244:               #endif //USE_SLEEP
245:               
246:               	default:
247:               		break;
248:               	} //end switch(appData.state)
249:               } //end APP_Tasks()
0021C8  060000     RETURN
250:               
251:               //Sets up the RN module
252:               
253:               bool APP_Initialize(void)
254:               {
001F18  781F88     MOV W8, [W15++]
255:               	/****************************************************************************
256:               	 * Initialize appData structure
257:               	 ***************************************************************************/
258:               	appData.error_code = ERROR_NONE;
001F1A  B3C010     MOV.B #0x1, W0
001F1C  B7EB34     MOV.B WREG, 0xB34
259:               	appData.got_packet = false;
001F1E  EF6B26     CLR.B 0xB26
260:               	appData.potValue = 0;
001F20  EF2B44     CLR 0xB44
261:               	appData.potValueOld = 0xFFFF;
001F22  EB8080     SETM W1
001F24  885A31     MOV W1, 0xB46
262:               	appData.potValueLastTX = 0xFFFF;
001F26  885A41     MOV W1, .L66
263:               	appData.state = APP_INITIALIZE;
001F28  EF2A5C     CLR appData
264:               	appData.sw1 = false;
001F2A  EF6B35     CLR.B 0xB35
265:               	appData.sw2 = false;
001F2C  EF6B36     CLR.B 0xB36
266:               	appData.sw3 = false;
001F2E  EF6B37     CLR.B 0xB37
267:               	appData.sw4 = false;
001F30  EF6B38     CLR.B .L92
268:               	appData.led1 = 0;
001F32  EF6B2A     CLR.B .L64
269:               	appData.led2 = 0;
001F34  EF6B2B     CLR.B 0xB2B
270:               	appData.led3 = 0;
001F36  EF6B2C     CLR.B 0xB2C
271:               	appData.led4 = 0;
001F38  EF6B2D     CLR.B 0xB2D
272:               	appData.led5 = 0;
001F3A  EF6B2E     CLR.B 0xB2E
273:               	appData.led6 = 0;
001F3C  EF6B2F     CLR.B 0xB2F
274:               	appData.update_packet = true;
001F3E  B7EB27     MOV.B WREG, 0xB27
275:               	appData.sw1Changed = false;
001F40  EF6B39     CLR.B 0xB39
276:               	appData.sw2Changed = false;
001F42  EF6B3A     CLR.B 0xB3A
277:               	appData.sw3Changed = false;
001F44  EF6B3B     CLR.B 0xB3B
278:               	appData.sw4Changed = false;
001F46  EF6B3C     CLR.B 0xB3C
279:               	appData.sendSwitches = false;
001F48  EF6B28     CLR.B 0xB28
280:               	appData.ADCcalFlag = false;
001F4A  EF6B29     CLR.B 0xB29
281:               	appData.sleepFlag = false;
001F4C  EF6B42     CLR.B .L67
282:               	appData.RTCCalarm = false;
001F4E  EF6B3D     CLR.B 0xB3D
283:               	appData.accumReady = false;
001F50  EF6B3E     CLR.B 0xB3E
284:               	appData.ADCinUse = false;
001F52  EF6B3F     CLR.B 0xB3F
285:               	appData.timer1Flag = false;
001F54  EF6B40     CLR.B 0xB40
286:               
287:               	/****************************************************************************
288:               	 * Peripherals Init
289:               	 ***************************************************************************/
290:               	ADC_Init(); //Initialize the pADC
001F56  070357     RCALL ADC_Init
291:               	UART_Init(); //Initialize the UART
001F58  0703CD     RCALL UART_Init
292:               	Timers_Init(); //Initialize the timers
001F5A  07046A     RCALL Timers_Init
293:               	SPI_Init();
001F5C  0702D6     RCALL SPI_Init
294:               
295:               #ifdef USE_SLEEP            //see config.h, Application settings section
296:               #ifdef SLEEP_MODE_RTCC
297:               	RTCC_Init();
298:               #endif  //SLEEP_MODE_RTCC
299:               #endif  //USE_SLEEP
300:               
301:               	BT_WAKE_SW = 1; //wake module
001F5E  A862CD     BSET 0x2CD, #3
302:               	//Wait for WS status high
303:               	StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
001F60  20FA01     MOV #0xFA0, W1
001F62  B3C020     MOV.B #0x2, W0
001F64  07046D     RCALL StartTimer
304:               	while (BT_WS == 0) {
001F68  370008     BRA .L2
001F7A  AB42C2     BTST PORTA, #2
001F7C  32FFF6     BRA Z, .L4
305:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001F66  B3C028     MOV.B #0x2, W8
001F6A  784008     MOV.B W8, W0
001F6C  07046F     RCALL TimerDone
001F6E  E00400     CP0.B W0
001F70  320004     BRA Z, .L2
306:               		{
307:               			appData.error_code = ERROR_INITIALIZATION;
001F72  B3CFE0     MOV.B #0xFE, W0
001F74  B7EB34     MOV.B WREG, 0xB34
308:               			return false;
001F76  EB4000     CLR.B W0
001F78  37002D     BRA .L3
309:               		}
310:               	}
311:               
312:               	//Wait for end of "CMD\r\n" - we don't check for full "CMD\r\n" string because we may 
313:               	//miss some bits or bytes at the beginning while the UART starts up
314:               	StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
001F7E  20FA01     MOV #0xFA0, W1
001F80  B3C020     MOV.B #0x2, W0
001F82  07045E     RCALL StartTimer
315:               	while (UART_ReadRxBuffer() != '\n') {
001F86  370008     BRA .L5
001F98  0703CF     RCALL UART_ReadRxBuffer
001F9A  504FEA     SUB.B W0, #0xA, [W15]
001F9C  3AFFF5     BRA NZ, .L6
316:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001F84  B3C028     MOV.B #0x2, W8
001F88  784008     MOV.B W8, W0
001F8A  070460     RCALL TimerDone
001F8C  E00400     CP0.B W0
001F8E  320004     BRA Z, .L5
317:               		{
318:               			appData.error_code = ERROR_INITIALIZATION;
001F90  B3CFE0     MOV.B #0xFE, W0
001F92  B7EB34     MOV.B WREG, 0xB34
319:               			return false;
001F94  EB4000     CLR.B W0
001F96  37001E     BRA .L3
320:               		}
321:               	}
322:               
323:               	//Module is now in command mode and ready for input
324:               	if (!BT_SetupModule()) { //Setup RN4020 module
001F9E  07FEB2     RCALL BT_SetupModule
001FA0  E00400     CP0.B W0
001FA2  3A0004     BRA NZ, .L7
325:               		appData.error_code = ERROR_INITIALIZATION;
001FA4  B3CFE0     MOV.B #0xFE, W0
001FA6  B7EB34     MOV.B WREG, 0xB34
326:               		return false;
001FA8  EB4000     CLR.B W0
001FAA  370014     BRA .L3
327:               	}
328:               
329:               #ifdef VERIFY_RN_FW_VER
330:               	//Verify RN4020 module's firmware version
331:               	if (!(appData.version_code = BT_CheckFwVer())) {
001FAC  07FE4F     RCALL BT_CheckFwVer
001FAE  885A50     MOV W0, 0xB4A
001FB2  E00000     CP0 W0
001FB4  3A000A     BRA NZ, .L16
332:               		appData.error_code = ERROR_RN_FW;
001FB6  B3CFD0     MOV.B #0xFD, W0
001FB8  B7EB34     MOV.B WREG, 0xB34
333:               		return false;
001FBA  EB4000     CLR.B W0
001FBC  37000B     BRA .L3
334:               	}
335:               #endif // VERIFY_RN_FW_VER 
336:               
337:               	//flush UART RX buffer as a precaution before starting app state machine
338:               	while (UART_IsNewRxData()) { //While buffer contains old data
001FCA  0703AD     RCALL UART_IsNewRxData
001FCC  E00400     CP0.B W0
001FCE  3AFFF7     BRA NZ, .L10
339:               		UART_ReadRxBuffer(); //Keep reading until empty
001FBE  0703BC     RCALL UART_ReadRxBuffer
340:               		if (!UART_IsNewRxData()) {
001FC0  0703B2     RCALL UART_IsNewRxData
001FC2  E00400     CP0.B W0
001FC4  3A0002     BRA NZ, .L16
341:               			WaitMs(100);
001FB0  200648     MOV #0x64, W8
001FC6  780008     MOV W8, W0
001FC8  07044A     RCALL WaitMs
342:               		}
343:               	}
344:               
345:               	SLED = 1; // init completed
001FD0  A8C2CD     BSET 0x2CD, #6
346:               	return true;
001FD2  B3C010     MOV.B #0x1, W0
347:               }
001FD4  78044F     MOV [--W15], W8
001FD6  060000     RETURN
---  /root/ble/fac_relay_clone/adc.c  -------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        adc.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 * modified for MCP3208 device Nov 2016
32:                 *
33:                 *
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdbool.h>
39:                #include "adc.h"
40:                #include "spi.h"
41:                #include "app.h"
42:                #include "config.h"
43:                #include "timers.h"
44:                
45:                extern APP_DATA appData;
46:                extern ADC_DATA adcData;
47:                
48:                /******************************************************************************
49:                 * Function:        void ADC_Init()
50:                 *
51:                 * PreCondition:    None
52:                 *
53:                 * Input:           None
54:                 *
55:                 * Output:          None
56:                 *
57:                 * Side Effects:    None
58:                 *
59:                 * Overview:        This routine initializes the ADC 
60:                 *                 
61:                 * Note:
62:                 *
63:                 *****************************************************************************/
64:                
65:                void ADC_Init()
66:                {
67:                	adcData.mcp3208_cmd.ld = 0; // clear the command word
002606  20B500     MOV #0xB50, W0
002608  EB0800     CLR [W0]
00260A  781030     MOV [W0++], [W0--]
68:                	adcData.chan = 0;
00260C  EB4080     CLR.B W1
00260E  984061     MOV.B W1, [W0+6]
69:                	adcData.mcp3208_cmd.map.start_bit = 1;
002610  900090     MOV [W0+2], W1
70:                	adcData.mcp3208_cmd.map.single_diff = 1;
002612  B30061     IOR #0x6, W1
71:                	adcData.mcp3208_cmd.map.index = 0; // channel
002614  23FFF2     MOV #0x3FFF, W2
002616  610810     AND W2, [W0], [W0]
002618  A10001     BCLR W1, #0
00261A  980011     MOV W1, [W0+2]
72:                	appData.ADCcalFlag = true;
00261C  B3C010     MOV.B #0x1, W0
00261E  B7EB29     MOV.B WREG, 0xB29
73:                	SPI_CS0 = 1;
002620  A862C4     BSET LATA, #3
74:                }
002622  060000     RETURN
75:                
76:                //State machine for restarting ADC and taking new readings from pot
77:                //Returns true when SPI data has been returned from the mpc3208; false otherwise
78:                
79:                bool ADC_Tasks(void)
80:                {
002624  BE9F88     MOV.D W8, [W15++]
81:                	static uint8_t count = 0;
82:                
83:                	/* send the command sequence to the adc */
84:                	if (!adcData.mcp3208_cmd.map.in_progress) {
002626  AB8B53     BTST 0xB53, #4
002628  3A003D     BRA NZ, .L12
85:                		adcData.mcp3208_cmd.map.in_progress = true;
00262A  20B500     MOV #0xB50, W0
00262C  900090     MOV [W0+2], W1
00262E  A0C001     BSET W1, #12
86:                		adcData.mcp3208_cmd.map.finish = false;
002630  A1B001     BCLR W1, #11
002632  980011     MOV W1, [W0+2]
87:                		count = 0;
002634  EF6CC8     CLR.B .L39
88:                		if (!SPI_IsTxData()) {
002636  07FFBF     RCALL SPI_IsTxData
002638  784080     MOV.B W0, W1
00263C  E00401     CP0.B W1
00263E  3A003D     BRA NZ, .L4
89:                			adcData.mcp3208_cmd.map.single_diff = 1;
002640  20B508     MOV #0xB50, W8
002642  900118     MOV [W8+2], W2
002644  A01002     BSET W2, #1
90:                			adcData.mcp3208_cmd.map.index = adcData.chan;
002646  900038     MOV [W8+6], W0
002648  DD00CE     SL W0, #14, W1
00264A  23FFF3     MOV #0x3FFF, W3
00264C  618198     AND W3, [W8], W3
00264E  718C01     IOR W3, W1, [W8]
002650  DE0042     LSR W0, #2, W0
002652  6000E1     AND W0, #0x1, W1
002654  780002     MOV W2, W0
002656  A10000     BCLR W0, #0
002658  708000     IOR W1, W0, W0
00265A  980410     MOV W0, [W8+2]
91:                			SPI_ClearBufs(); // dump the spi buffers
00265C  07FF74     RCALL SPI_ClearBufs
92:                			SPI_WriteTxBuffer(adcData.mcp3208_cmd.bd[2]);
00265E  904028     MOV.B [W8+2], W0
002660  07FFB3     RCALL SPI_WriteTxBuffer
93:                			SPI_WriteTxBuffer(adcData.mcp3208_cmd.bd[1]);
002662  904018     MOV.B [W8+1], W0
002664  07FFB1     RCALL SPI_WriteTxBuffer
94:                			SPI_WriteTxBuffer(adcData.mcp3208_cmd.bd[0]);
002666  784018     MOV.B [W8], W0
002668  07FFAF     RCALL SPI_WriteTxBuffer
95:                			SPI_CS0 = 0; // select the ADC
00266A  A962C4     BCLR LATA, #3
96:                			SPI_Speed(0);
00266C  EB4000     CLR.B W0
00266E  07FF5F     RCALL SPI_Speed
97:                			SPI_TxStart();
002670  07FF75     RCALL SPI_TxStart
98:                		}
99:                		return false;
00263A  EB4000     CLR.B W0
002672  EB4000     CLR.B W0
002674  370022     BRA .L4
100:               	}
101:               
102:               	/* read the returned spi data from the buffer and format it */
103:               	if (adcData.mcp3208_cmd.map.in_progress) {
104:               		while (SPI_IsNewRxData()) {
0026A4  07FF6E     RCALL SPI_IsNewRxData
0026A6  E00400     CP0.B W0
0026A8  3AFFE6     BRA NZ, .L9
105:               			switch (count) {
002676  BFCCC8     MOV.B .L39, WREG
002678  504FE1     SUB.B W0, #0x1, [W15]
00267A  320003     BRA Z, .L6
00267C  504FE2     SUB.B W0, #0x2, [W15]
00267E  3A0010     BRA NZ, .L13
002680  370005     BRA .L14
106:               			case 1:
107:               				adcData.potValue = (SPI_ReadRxBuffer()&0x0f) << 8;
002682  07FF88     RCALL SPI_ReadRxBuffer
002684  60006F     AND W0, #0xF, W0
002686  DD0048     SL W0, #8, W0
002688  885AA0     MOV W0, .L13
108:               				break;
00268A  37000B     BRA .L8
109:               			case 2:
110:               				adcData.potValue += SPI_ReadRxBuffer();
00268C  20B508     MOV #0xB50, W8
00268E  9004A8     MOV [W8+4], W9
002690  07FF81     RCALL SPI_ReadRxBuffer
002692  FB8000     ZE W0, W0
002694  400489     ADD W0, W9, W9
002696  980429     MOV W9, [W8+4]
111:               				adcData.mcp3208_cmd.map.finish = true;
002698  900018     MOV [W8+2], W0
00269A  A0B000     BSET W0, #11
00269C  980410     MOV W0, [W8+2]
112:               				break;
00269E  370001     BRA .L8
113:               			default:
114:               				SPI_ReadRxBuffer(); // eat extra bytes
0026A0  07FF79     RCALL SPI_ReadRxBuffer
115:               				break;
116:               			}
117:               			count++;
0026A2  EC6CC8     INC.B .L39
118:               		}
119:               	}
120:               
121:               	/* cleanup for next time */
122:               	if (adcData.mcp3208_cmd.map.finish) {
0026AA  AB6B53     BTST 0xB53, #3
0026AC  320006     BRA Z, .L4
123:               		adcData.mcp3208_cmd.map.in_progress = false;
0026AE  20B500     MOV #0xB50, W0
0026B0  900090     MOV [W0+2], W1
0026B2  A1C001     BCLR W1, #12
0026B4  980011     MOV W1, [W0+2]
124:               		appData.accumReady = true;
0026B6  B3C010     MOV.B #0x1, W0
0026B8  B7EB3E     MOV.B WREG, 0xB3E
125:               		return true;
126:               	}
127:               
128:               	return false;
129:               }
0026BA  BE044F     MOV.D [--W15], W8
0026BC  060000     RETURN
130:               
131:               //Process the accumulator value once it is ready
132:               //And update stored potentiometer values
133:               
134:               void ADC_ProcAccum(void)
135:               {
136:               	appData.potValueOld = appData.potValue; //Save previous value
0026BE  F80B44     PUSH 0xB44
0026C0  F90B46     POP 0xB46
137:               	appData.potValue = adcData.potValue;
0026C2  F80B54     PUSH .L13
0026C4  F90B44     POP 0xB44
138:               }
0026C6  060000     RETURN
139:               
140:               //ADC ISR
141:               
142:               void _ISR_NO_AUTO_PSV _ISR _ADC1Interrupt(void)
143:               {
144:               	IFS0bits.AD1IF = 0;
0002C8  A9A085     BCLR 0x85, #5
145:               	//Accumulation complete
146:               
147:               }
0002CA  064000     RETFIE
148:               
149:               void GetNewADC_Chan(void)
150:               {
151:               	adcData.chan = appData.receive_packet[9] == '1' ? 1 : 0; // update adc channel 
0026C8  B3C310     MOV.B #0x31, W0
0026CA  20A672     MOV #0xA67, W2
0026CC  784112     MOV.B [W2], W2
0026CE  694100     XOR.B W2, W0, W2
0026D0  FB8102     ZE W2, W2
0026D2  E90102     DEC W2, W2
0026D4  DE114F     LSR W2, #15, W2
152:               	adcData.chan += appData.receive_packet[11] == '1' ? 2 : 0;
0026D6  EB4080     CLR.B W1
0026D8  E34A69     CP.B 0xA69
0026DA  3A0001     BRA NZ, .L18
0026DC  B3C021     MOV.B #0x2, W1
0026DE  40C082     ADD.B W1, W2, W1
153:               	adcData.chan += appData.receive_packet[13] == '1' ? 4 : 0;
0026E0  EB4000     CLR.B W0
0026E2  B3C312     MOV.B #0x31, W2
0026E4  20A6B3     MOV #0xA6B, W3
0026E6  784193     MOV.B [W3], W3
0026E8  51CF82     SUB.B W3, W2, [W15]
0026EA  3A0001     BRA NZ, .L19
0026EC  B3C040     MOV.B #0x4, W0
0026EE  40C000     ADD.B W1, W0, W0
0026F0  B7EB56     MOV.B WREG, 0xB56
154:               }
0026F2  060000     RETURN
