Disassembly Listing for blecm_dk
Generated From:
/sdd/work/fac_relay_clone/blecm_dk.X/dist/default/production/blecm_dk.X.production.elf
Nov 4, 2016 12:29:52 PM

---  /sdd/work/fac_relay_clone/uart.c  ------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        uart.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Uart functions
33:                 * 
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdbool.h>
39:                #include <stddef.h>
40:                #include "uart.h"
41:                #include "config.h"
42:                
43:                //UART receive buffer type
44:                
45:                typedef struct {
46:                	volatile uint8_t buffer[SIZE_RxBuffer];
47:                	volatile uint8_t volatile *head;
48:                	volatile uint8_t *tail;
49:                	volatile uint16_t byteCount;
50:                } UART_RX_BUFFER_T;
51:                
52:                //UART transmit buffer type
53:                
54:                typedef struct {
55:                	volatile uint8_t buffer[SIZE_TxBuffer];
56:                	volatile uint8_t *head;
57:                	volatile uint8_t volatile *tail;
58:                	volatile uint16_t byteCount;
59:                } UART_TX_BUFFER_T;
60:                
61:                //Buffer instances
62:                static UART_RX_BUFFER_T rxBuf;
63:                static UART_TX_BUFFER_T txBuf;
64:                
65:                //**********************************************************************************************************************
66:                // Initialize the UART to communicate with the Bluetooth module
67:                
68:                void UART_Init(void)
69:                {
70:                	rxBuf.tail = &rxBuf.buffer[0]; //Initialize the pointers
00212C  208000     MOV #0x800, W0
00212E  884810     MOV W0, 0x902
71:                	rxBuf.head = &rxBuf.buffer[0];
002130  884800     MOV W0, 0x900
72:                	txBuf.tail = &txBuf.buffer[0];
002132  209060     MOV #0x906, W0
002134  885040     MOV W0, 0xA08
73:                	txBuf.head = &txBuf.buffer[0];
002136  885030     MOV W0, 0xA06
74:                	txBuf.byteCount = rxBuf.byteCount = 0;
002138  EF2904     CLR 0x904
00213A  F80904     PUSH 0x904
00213C  F90A0A     POP 0xA0A
75:                
76:                	U1BRG = 34; //Baud rate 115,200 - actually 115,384 baud 0.16% error
00213E  200220     MOV #0x22, W0
002140  881140     MOV W0, U1BRG
77:                	//	U1BRG = 7;
78:                	U1MODE = 0x8008; //Enable UART, no flow control, BRGH = 1 for high speed baud mode
002142  280080     MOV #0x8008, W0
002144  881100     MOV W0, U1MODE
79:                	U1STA = 0x0400; //Enable transmit
002146  204000     MOV #0x400, W0
002148  881110     MOV W0, U1STA
80:                	UART_RX_IF = 0; //Clear UART interrupt flags
00214A  A96085     BCLR 0x85, #3
81:                	UART_ER_IF = 0;
00214C  A9208C     BCLR IFS4, #1
82:                	UART_RX_IE = 1; //Enable UART Receive and Error interrupt
00214E  A86095     BSET 0x95, #3
83:                	UART_ER_IE = 1;
002150  A8209C     BSET IEC4, #1
84:                }
002152  060000     RETURN
85:                
86:                //**********************************************************************************************************************
87:                // Start transmission by enabling the UART transmit interrupt
88:                
89:                inline void UART_TxStart(void)
90:                {
91:                	UART_TX_IE = 1; //Enable transmit interrupts
002154  A88095     BSET 0x95, #4
92:                }
002156  060000     RETURN
93:                
94:                //**********************************************************************************************************************
95:                // See if there are one or more bytes in the receive buffer
96:                
97:                bool UART_IsNewRxData(void)
98:                {
99:                	__builtin_disi(0x3FFF); //disable interrupts
002158  FC3FFF     DISI #0x3FFF
100:               	if (rxBuf.byteCount == 0) { //Check if data in buffer
00215A  E20904     CP0 0x904
00215C  3A0003     BRA NZ, 0x2164
101:               		__builtin_disi(0); //enable interrupts
00215E  FC0000     DISI #0x0
102:               		return(false); //No bytes in the buffer so return false
002160  EB4000     CLR.B W0
002162  370002     BRA 0x2168
103:               	}
104:               	__builtin_disi(0); //enable interrupts
002164  FC0000     DISI #0x0
105:               	return(true); //There are bytes in the buffer
002166  B3C010     MOV.B #0x1, W0
106:               }
002168  060000     RETURN
107:               
108:               //**********************************************************************************************************************
109:               // Read a byte from the receive buffer
110:               
111:               uint8_t UART_ReadRxBuffer(void)
112:               {
113:               	uint8_t Temp;
114:               
115:               	__builtin_disi(0x3FFF); //disable interrupts
00216A  FC3FFF     DISI #0x3FFF
116:               	if (rxBuf.byteCount == 0) { //For safety, do not allow read of empty buffer
00216C  E20904     CP0 0x904
00216E  3A0003     BRA NZ, 0x2176
117:               		__builtin_disi(0); //enable interrupts
002170  FC0000     DISI #0x0
118:               		return(0); //Return zero if there is nothing in the buffer
002172  EB4000     CLR.B W0
002174  37000A     BRA 0x218A
119:               	}
120:               
121:               	rxBuf.byteCount--; //Decrement byte count
002176  ED2904     DEC 0x904
122:               	__builtin_disi(0); //enable interrupts
002178  FC0000     DISI #0x0
123:               	Temp = *rxBuf.tail++; //Get the byte and increment the pointer
00217A  804811     MOV 0x902, W1
00217C  784031     MOV.B [W1++], W0
00217E  884811     MOV W1, 0x902
124:               	if (rxBuf.tail > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if at end of buffer
002180  208FF2     MOV #0x8FF, W2
002182  508F82     SUB W1, W2, [W15]
002184  360002     BRA LEU, 0x218A
125:               		rxBuf.tail = &rxBuf.buffer[0]; //then wrap the pointer to beginning
002186  208001     MOV #0x800, W1
002188  884811     MOV W1, 0x902
126:               	}
127:               	return(Temp);
128:               }
00218A  060000     RETURN
129:               
130:               //**********************************************************************************************************************
131:               // Write a byte to the transmit buffer
132:               
133:               void UART_WriteTxBuffer(const uint8_t TxByte)
134:               {
135:               	*txBuf.head++ = TxByte; //Put the byte in the transmit buffer and increment the pointer
00218C  805031     MOV 0xA06, W1
00218E  785880     MOV.B W0, [W1++]
002190  885031     MOV W1, 0xA06
136:               	if (txBuf.head > &txBuf.buffer[SIZE_TxBuffer - 1]) { //Check if at end of buffer
002192  20A050     MOV #0xA05, W0
002194  508F80     SUB W1, W0, [W15]
002196  360002     BRA LEU, 0x219C
137:               		txBuf.head = &txBuf.buffer[0]; //Wrap pointer to beginning
002198  209060     MOV #0x906, W0
00219A  885030     MOV W0, 0xA06
138:               	}
139:               	__builtin_disi(0x3FFF); //disable interrupts
00219C  FC3FFF     DISI #0x3FFF
140:               	if (txBuf.byteCount < SIZE_TxBuffer) { //Increment byte count
00219E  200FF0     MOV #0xFF, W0
0021A0  E30A0A     CP 0xA0A
0021A2  3E0001     BRA GTU, 0x21A6
141:               		txBuf.byteCount++;
0021A4  EC2A0A     INC 0xA0A
142:               	}
143:               	__builtin_disi(0); //enable interrupts
0021A6  FC0000     DISI #0x0
144:               }
0021A8  060000     RETURN
145:               
146:               //**********************************************************************************************************************
147:               // Return the number of bytes free in the TX buffer
148:               
149:               uint16_t UART_GetTXBufferFreeSpace(void)
150:               {
151:               	uint16_t space;
152:               
153:               	__builtin_disi(0x3FFF); //disable interrupts            
0021AA  FC3FFF     DISI #0x3FFF
154:               	space = SIZE_TxBuffer - txBuf.byteCount;
0021AC  805050     MOV 0xA0A, W0
0021B0  201001     MOV #0x100, W1
0021B2  508000     SUB W1, W0, W0
155:               	__builtin_disi(0); //enable interrupts
0021AE  FC0000     DISI #0x0
156:               	return space;
157:               }
0021B4  060000     RETURN
158:               
159:               //Peek at buffer tail
160:               
161:               uint8_t UART_PeekRxBuffer(void)
162:               {
163:               	__builtin_disi(0x3FFF); //disable interrupts
0021B6  FC3FFF     DISI #0x3FFF
164:               	if (rxBuf.byteCount == 0) { //Check if pointers are the same
0021B8  E20904     CP0 0x904
0021BA  3A0003     BRA NZ, 0x21C2
165:               		__builtin_disi(0); //enable interrupts
0021BC  FC0000     DISI #0x0
166:               		return(NULL); //No bytes in the buffer so return NULL
0021BE  EB4000     CLR.B W0
0021C0  370003     BRA 0x21C8
167:               	} else {
168:               		__builtin_disi(0); //enable interrupts
0021C2  FC0000     DISI #0x0
169:               		return *rxBuf.tail;
0021C4  804810     MOV 0x902, W0
0021C6  784010     MOV.B [W0], W0
170:               	}
171:               }
0021C8  060000     RETURN
172:               
173:               //**********************************************************************************************************************
174:               // Interrupt routine for UART receive interrupts
175:               
176:               void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt(void)
177:               {
0021CA  BE9F80     MOV.D W0, [W15++]
178:               	UART_RX_IF = 0; //Clear UART Receive interrupt flag
0021CC  A96085     BCLR 0x85, #3
179:               	*rxBuf.head++ = UART_RX_BUF; //Put received byte in the buffer
0021CE  801131     MOV U1RXREG, W1
0021D0  804800     MOV 0x900, W0
0021D2  785801     MOV.B W1, [W0++]
0021D4  884800     MOV W0, 0x900
180:               	if (rxBuf.head > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if end of buffer
0021D6  208FF1     MOV #0x8FF, W1
0021D8  500F81     SUB W0, W1, [W15]
0021DA  360002     BRA LEU, 0x21E0
181:               		rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
0021DC  208000     MOV #0x800, W0
0021DE  884800     MOV W0, 0x900
182:               	}
183:               	if (rxBuf.byteCount < SIZE_RxBuffer) { //Increment byte count
0021E0  200FF0     MOV #0xFF, W0
0021E2  E30904     CP 0x904
0021E4  3E0001     BRA GTU, 0x21E8
184:               		rxBuf.byteCount++;
0021E6  EC2904     INC 0x904
185:               	}
186:               }
0021E8  BE004F     MOV.D [--W15], W0
0021EA  064000     RETFIE
187:               
188:               //**********************************************************************************************************************
189:               // Interrupt routine for UART transmit interrupts
190:               
191:               void __attribute__((interrupt, no_auto_psv)) _U1TXInterrupt(void)
192:               {
0021EC  BE9F80     MOV.D W0, [W15++]
193:               	if (txBuf.byteCount > 0) //Check if more data is in the buffer
0021EE  E20A0A     CP0 0xA0A
0021F0  32000E     BRA Z, 0x220E
194:               	{
195:               		//Only do anything if hardware buffer has space
196:               		if (!UART_FULL) {
0021F2  AB2223     BTST 0x223, #1
0021F4  3A000D     BRA NZ, 0x2210
197:               			UART_TX_IF = 0; //Clear UART 1 TX interrupt flag
0021F6  A98085     BCLR 0x85, #4
198:               			UART_TX_BUF = *txBuf.tail++; //Load next byte into the TX buffer
0021F8  805040     MOV 0xA08, W0
0021FA  FB80B0     ZE [W0++], W1
0021FC  881121     MOV W1, U1TXREG
0021FE  885040     MOV W0, 0xA08
199:               			if (txBuf.tail > &txBuf.buffer[SIZE_TxBuffer - 1]) { //Check if end of buffer
002200  20A051     MOV #0xA05, W1
002202  500F81     SUB W0, W1, [W15]
002204  360002     BRA LEU, 0x220A
200:               				txBuf.tail = &txBuf.buffer[0]; //Wrap pointer to beginning
002206  209060     MOV #0x906, W0
002208  885040     MOV W0, 0xA08
201:               			}
202:               			txBuf.byteCount--; //Decrement byte count
00220A  ED2A0A     DEC 0xA0A
00220C  370001     BRA 0x2210
203:               		}
204:               	} else {
205:               		UART_TX_IE = 0; //No more data to transmit, so stop interrupts
00220E  A98095     BCLR 0x95, #4
206:               	}
207:               }
002210  BE004F     MOV.D [--W15], W0
002212  064000     RETFIE
208:               
209:               //**********************************************************************************************************************
210:               // Interrupt routine for UART error interrupts
211:               
212:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void)
213:               {
002214  BE9F80     MOV.D W0, [W15++]
214:               	IFS4bits.U1ERIF = 0; //Clear interrupt flag
002216  A9208C     BCLR IFS4, #1
215:               
216:               	//Handle an overflow error by reading next byte and clearing flag
217:               	if (U1STAbits.OERR == 1) {
002218  AB2222     BTST U1STA, #1
00221A  32000E     BRA Z, 0x2238
218:               		*rxBuf.head++ = UART_RX_BUF; //Put received byte in the buffer
00221C  801131     MOV U1RXREG, W1
00221E  804800     MOV 0x900, W0
002220  785801     MOV.B W1, [W0++]
002222  884800     MOV W0, 0x900
219:               		if (rxBuf.head > &rxBuf.buffer[SIZE_RxBuffer - 1]) { //Check if end of buffer
002224  208FF1     MOV #0x8FF, W1
002226  500F81     SUB W0, W1, [W15]
002228  360002     BRA LEU, 0x222E
220:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
00222A  208000     MOV #0x800, W0
00222C  884800     MOV W0, 0x900
221:               		}
222:               		if (rxBuf.byteCount < SIZE_RxBuffer) { //Increment byte count
00222E  200FF0     MOV #0xFF, W0
002230  E30904     CP 0x904
002232  3E0001     BRA GTU, 0x2236
223:               			rxBuf.byteCount++;
002234  EC2904     INC 0x904
224:               		}
225:               		U1STAbits.OERR = 0;
002236  A92222     BCLR U1STA, #1
226:               	}
227:               
228:               	//Clear any other error bits
229:               	U1STAbits.FERR = 0;
002238  A94222     BCLR U1STA, #2
230:               	U1STAbits.PERR = 0;
00223A  A96222     BCLR U1STA, #3
231:               }
00223C  BE004F     MOV.D [--W15], W0
00223E  064000     RETFIE
---  /sdd/work/fac_relay_clone/timers.c  ----------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        timers.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Timer functions
33:                 *
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdbool.h>
39:                #include "config.h"
40:                #include "timers.h"
41:                #include "app.h"
42:                
43:                extern APP_DATA appData;
44:                
45:                static volatile uint16_t tickCount[TMR_COUNT] = {0};
46:                
47:                //**********************************************************************************************************************
48:                // Initialize the timers
49:                
50:                void Timers_Init(void)
51:                {
52:                	//Timer 1 is used for interrupt based software timers counting 1ms intervals to a resolution of 500us
53:                	T1CON = TIMER_OFF; //Timer 1 off
002506  EF2104     CLR T1CON
54:                	TMR1 = 0; //Clear timer 1
002508  EF2100     CLR TMR1
55:                	PR1 = TIMER_500US_PERIOD; //Set the period value for 500us
00250A  21F3F0     MOV #0x1F3F, W0
00250C  880810     MOV W0, PR1
56:                	T1CON |= TIMER_ON_PRESCALE1; //using 1:1 prescaler and turn on timer 1
00250E  800821     MOV T1CON, W1
002510  280000     MOV #0x8000, W0
002512  700001     IOR W0, W1, W0
002514  880820     MOV W0, T1CON
57:                	IFS0bits.T1IF = 0; //Clear the interrupt flag
002516  A96084     BCLR IFS0, #3
58:                	IEC0bits.T1IE = 1; //Enable the timer 1 interrupt
002518  A86094     BSET IEC0, #3
59:                
60:                #ifdef USE_SLEEP                //see config.h, Application setting section
61:                	//Timer 2/3 is used in 32-bit mode as inactivity timer to trigger sleep mode
62:                	T2CON = TIMER_OFF; //Timer 3 off
63:                	TMR3 = 0; //Clear timer 3
64:                	TMR2 = 0; //Clear timer 2
65:                	T2CONbits.T32 = 1; //Enable 32-bit mode
66:                	PR3 = (uint16_t) (SLEEP_TIME >> 16); //Set the period value - msw
67:                	PR2 = (uint16_t) (SLEEP_TIME | 0x0000FFFF); //lsw
68:                	T2CON |= TIMER_ON_PRESCALE256; //using 1:256 prescaler and turn on timer 3
69:                	IFS0bits.T3IF = 0; //Clear the interrupt flag
70:                	IEC0bits.T3IE = 1; //Enable the timer 3 interrupt
71:                
72:                #ifndef SLEEP_MODE_RTCC         //we'll be using Timer 1 for periodic wakeup
73:                	T1CON = 0x0000; //Timer 1 off
74:                	T1CONbits.T1ECS = 0b10; //Clock source LPRC
75:                	T1CONbits.TCS = 1;
76:                	T1CONbits.TCKPS = 0b11; //using 1:256 prescaler
77:                	TMR1 = 0; //Clear timer 1
78:                	PR1 = T1_SLEEP_PERIOD; //Set the period for sleep
79:                	IFS0bits.T1IF = 0; //Clear the interrupt flag
80:                	IEC0bits.T1IE = 1; //Enable the timer 1 interrupt
81:                #endif //not SLEEP_MODE_RTCC    
82:                #endif //USE_SLEEP
83:                }
00251A  060000     RETURN
84:                
85:                //**********************************************************************************************************************
86:                // Start one of the software timers
87:                
88:                inline void StartTimer(uint8_t timer, uint16_t count)
89:                {
90:                	tickCount[timer] = count << 1; //Interrupt is every 500us but StartTimer() takes multiple of 1ms so multiply by 2
00251C  FB8000     ZE W0, W0
00251E  400000     ADD W0, W0, W0
002520  20B8A2     MOV #0xB8A, W2
002522  410000     ADD W2, W0, W0
002524  408801     ADD W1, W1, [W0]
00253A  400000     ADD W0, W0, W0
00253C  885C50     MOV W0, tickCount
91:                }
002526  060000     RETURN
92:                
93:                //**********************************************************************************************************************
94:                // Check if one of the software software timers has timed out
95:                
96:                inline bool TimerDone(uint8_t timer)
002530  A7F000     BTSC W0, #15
002532  EA0000     NEG W0, W0
002534  E90000     DEC W0, W0
002536  DE004F     LSR W0, #15, W0
97:                {
98:                	if (tickCount[timer] == 0) { //Check if counted down to zero
002528  FB8000     ZE W0, W0
00252A  400000     ADD W0, W0, W0
00252C  20B8A1     MOV #0xB8A, W1
00252E  780061     MOV [W1+W0], W0
99:                		return true; //then return true
100:               	}
101:               	return false; //else return false
102:               }
002538  060000     RETURN
103:               
104:               //**********************************************************************************************************************
105:               // Simple delay for n milliseconds (blocking)
106:               
107:               void WaitMs(uint16_t numMilliseconds)
108:               {
109:               	StartTimer(TMR_INTERNAL, numMilliseconds); //Start software timer and wait for it to count down
110:               	while (!TimerDone(TMR_INTERNAL)) {
00253E  E20B8A     CP0 tickCount
002540  320003     BRA Z, 0x2548
002544  E20B8A     CP0 tickCount
002546  3AFFFD     BRA NZ, 0x2542
111:               		Idle();
002542  FE4001     PWRSAV #1
112:               	} //Enter idle mode to reduce power while waiting
113:               } //(timer interrupt will wake part from idle)
002548  060000     RETURN
114:               
115:               #ifdef USE_SLEEP                //see config.h, Application setting section
116:               //Reset the inactivity sleep timer
117:               
118:               inline void SleepTimerReset(void)
119:               {
120:               	TMR3 = 0; //Clear timer 3
121:               	TMR2 = 0; //Clear timer 2
122:               }
123:               #endif
124:               
125:               //**********************************************************************************************************************
126:               // Timer 1 interrupt routine - software timers
127:               
128:               void _ISR_NO_AUTO_PSV _T1Interrupt(void)
129:               {
00254A  BE9F80     MOV.D W0, [W15++]
00254C  BE9F82     MOV.D W2, [W15++]
130:               	uint8_t i;
131:               
132:               	IFS0bits.T1IF = 0; //Clear the interrupt flag
00254E  A96084     BCLR IFS0, #3
002550  EB0000     CLR W0
133:               	//Decrement each software timer
134:               	for (i = 0; i < TMR_COUNT; i++) {
002568  500FEC     SUB W0, #0xC, [W15]
00256A  3AFFF3     BRA NZ, 0x2552
135:               		if (tickCount[i] != 0) {
002552  400080     ADD W0, W0, W1
002554  20B8A2     MOV #0xB8A, W2
002556  7880E2     MOV [W2+W1], W1
002558  E00001     CP0 W1
00255A  320005     BRA Z, 0x2566
136:               			tickCount[i]--;
00255C  400180     ADD W0, W0, W3
00255E  780082     MOV W2, W1
002560  798161     MOV [W1+W3], W2
002562  408183     ADD W1, W3, W3
002564  E90982     DEC W2, [W3]
002566  E80000     INC W0, W0
137:               		}
138:               	}
139:               }
00256C  BE014F     MOV.D [--W15], W2
00256E  BE004F     MOV.D [--W15], W0
002570  064000     RETFIE
140:               
141:               #ifdef USE_SLEEP                //see config.h, Application setting section
142:               //**********************************************************************************************************************
143:               // Timer 3 interrupt routine - inactivity timer
144:               
145:               void _ISR_NO_AUTO_PSV _T3Interrupt(void)
146:               {
147:               	IFS0bits.T3IF = 0; //Clear the interrupt flag    
148:               	appData.sleepFlag = true;
149:               }
150:               #ifndef SLEEP_MODE_RTCC
151:               //**********************************************************************************************************************
152:               // Timer 1 interrupt routine - periodic wakeup timer
153:               
154:               void _ISR_NO_AUTO_PSV _T1Interrupt(void)
155:               {
156:               	IFS0bits.T1IF = 0; //Clear the interrupt flag
157:               	appData.timer1Flag = true;
158:               }
159:               #endif //not SLEEP_MODE_RTCC
160:               #endif //USE_SLEEP
---  /sdd/work/fac_relay_clone/switches.c  --------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2015 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        switches.c
29:                 * Date:        September 17, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 *
33:                 */
34:                
35:                #include <xc.h>
36:                #include "app.h"
37:                #include "config.h"
38:                #include "timers.h"
39:                
40:                extern APP_DATA appData;
41:                
42:                //Switches state machine
43:                
44:                void Switch_Tasks(void)
45:                {
46:                	//Check if switches have changed and debounce timers are expired
47:                	if (appData.sw1Changed && TimerDone(TMR_SW1_DEBOUNCE)) {
002572  E24AE4     CP0.B 0xAE4
002574  320007     BRA Z, 0x2584
002576  B3C050     MOV.B #0x5, W0
002578  07FFD7     RCALL TimerDone
00257A  E00400     CP0.B W0
00257C  320003     BRA Z, 0x2584
48:                
49:                		appData.sw1Changed = false; //clear individual flag
00257E  EF6AE4     CLR.B 0xAE4
50:                		appData.sendSwitches = true; //set group flag to request TX
002580  B3C010     MOV.B #0x1, W0
002582  B7EAD7     MOV.B WREG, 0xAD7
51:                	}
52:                	if (appData.sw2Changed && TimerDone(TMR_SW2_DEBOUNCE)) {
002584  E24AE5     CP0.B 0xAE5
002586  320007     BRA Z, 0x2596
002588  B3C060     MOV.B #0x6, W0
00258A  07FFCE     RCALL TimerDone
00258C  E00400     CP0.B W0
00258E  320003     BRA Z, 0x2596
53:                
54:                		appData.sw2Changed = false;
002590  EF6AE5     CLR.B 0xAE5
55:                		appData.sendSwitches = true;
002592  B3C010     MOV.B #0x1, W0
002594  B7EAD7     MOV.B WREG, 0xAD7
56:                	}
57:                	if (appData.sw3Changed && TimerDone(TMR_SW3_DEBOUNCE)) {
002596  E24AE6     CP0.B 0xAE6
002598  320007     BRA Z, 0x25A8
00259A  B3C070     MOV.B #0x7, W0
00259C  07FFC5     RCALL TimerDone
00259E  E00400     CP0.B W0
0025A0  320003     BRA Z, 0x25A8
58:                
59:                		appData.sw3Changed = false;
0025A2  EF6AE6     CLR.B 0xAE6
60:                		appData.sendSwitches = true;
0025A4  B3C010     MOV.B #0x1, W0
0025A6  B7EAD7     MOV.B WREG, 0xAD7
61:                	}
62:                	if (appData.sw4Changed && TimerDone(TMR_SW4_DEBOUNCE)) {
0025A8  E24AE7     CP0.B 0xAE7
0025AA  320007     BRA Z, 0x25BA
0025AC  B3C080     MOV.B #0x8, W0
0025AE  07FFBC     RCALL TimerDone
0025B0  E00400     CP0.B W0
0025B2  320003     BRA Z, 0x25BA
63:                
64:                		appData.sw4Changed = false;
0025B4  EF6AE7     CLR.B 0xAE7
65:                		appData.sendSwitches = true;
0025B6  B3C010     MOV.B #0x1, W0
0025B8  B7EAD7     MOV.B WREG, 0xAD7
66:                	}
67:                }
0025BA  060000     RETURN
68:                
69:                //Change notification interrupt
70:                //Process and start debounce timers for switch changes
71:                //The switches are well debounced in hardware
72:                //Adding the software debounce limits unneeded switch update messages
73:                //and groups together multiple switch presses that occur within the debounce period
74:                
75:                void _ISR_NO_AUTO_PSV _CNInterrupt(void)
76:                {
77:                	IFS1bits.CNIF = 0; //Clear IF
0025BC  A96086     BCLR IFS1, #3
78:                
79:                #ifdef USE_SLEEP                //see config.h, Application setting section
80:                	appData.CNint = true;
81:                	SleepTimerReset(); //Reset the inactivity sleep timer
82:                #endif
83:                
84:                }
0025BE  064000     RETFIE
---  /sdd/work/fac_relay_clone/spi.c  -------------------------------------------------------------------
1:                 /* SPI Master Driver */
2:                 
3:                 #include <xc.h>
4:                 #include <stdint.h>
5:                 #include <stdbool.h>
6:                 #include <stddef.h>
7:                 #include "spi.h"
8:                 #include "config.h"
9:                 
10:                //SPI receive buffer type
11:                
12:                typedef struct {
13:                	volatile uint8_t buffer[SIZE_SPI_Buffer];
14:                	volatile uint8_t volatile *head;
15:                	volatile uint8_t *tail;
16:                	volatile uint16_t byteCount;
17:                } SPI_RX_BUFFER_T;
18:                
19:                //SPI transmit buffer type
20:                
21:                typedef struct {
22:                	volatile uint8_t buffer[SIZE_SPI_Buffer];
23:                	volatile uint8_t *head;
24:                	volatile uint8_t volatile *tail;
25:                	volatile uint16_t byteCount;
26:                } SPI_TX_BUFFER_T;
27:                
28:                //Buffer instances
29:                static SPI_RX_BUFFER_T rxBuf;
30:                static SPI_TX_BUFFER_T txBuf;
31:                
32:                void SPI_Init(void)
33:                {
34:                	SPI_SDO = 0;
001E2E  A9C2C8     BCLR TRISB, #6
35:                	SPI_SCK = 0;
001E30  A9A2C8     BCLR TRISB, #5
36:                	SPI_SDI = 1;
001E32  A8E2C0     BSET TRISA, #7
37:                	SPI_CS0 = 1;
001E34  A862C4     BSET LATA, #3
38:                	rxBuf.tail = &rxBuf.buffer[0]; //Initialize the pointers
001E36  20AFE0     MOV #0xAFE, W0
001E38  885A00     MOV W0, 0xB40
39:                	rxBuf.head = &rxBuf.buffer[0];
001E3A  8859F0     MOV W0, 0xB3E
40:                	txBuf.tail = &txBuf.buffer[0];
001E3C  20B440     MOV #0xB44, W0
001E3E  885C30     MOV W0, 0xB86
41:                	txBuf.head = &txBuf.buffer[0];
001E40  885C20     MOV W0, 0xB84
42:                	txBuf.byteCount = 0;
001E42  EF2B88     CLR 0xB88
43:                	rxBuf.byteCount = 0;
001E44  EF2B42     CLR 0xB42
44:                
45:                	/* SPI2 HW setup */
46:                	SSP2CON1bits.SSPM = 2; // SPI SCK speed
001E46  801090     MOV SSP2CON1, W0
001E48  A10000     BCLR W0, #0
001E4A  A01000     BSET W0, #1
001E4C  A12000     BCLR W0, #2
001E4E  A13000     BCLR W0, #3
001E50  881090     MOV W0, SSP2CON1
47:                	SSP2CON1bits.CKP = 0; // SCK polarity mode 0,0
001E52  A98212     BCLR SSP2CON1, #4
48:                	SSP2STATbits.CKE = 0; // SCK select 
001E54  A9C218     BCLR SSP2STAT, #6
49:                	SSP2STATbits.SMP = 0; // sample mid
001E56  A9E218     BCLR SSP2STAT, #7
50:                	SSP2CON1bits.SSPEN = 1; // enable spi ports
001E58  A8A212     BSET SSP2CON1, #5
51:                	PADCFG1bits.SCK2DIS = 0;
001E5A  A942FD     BCLR 0x2FD, #2
52:                	PADCFG1bits.SDA2DIS = 0;
001E5C  A962FD     BCLR 0x2FD, #3
53:                
54:                	SPI_X_IF = 0; //Clear SPI interrupt flags
001E5E  A9208A     BCLR IFS3, #1
55:                	SPI_E_IF = 0;
001E60  A9408A     BCLR IFS3, #2
56:                	SPI_X_IE = 0; //Setup SPI Receive and Error interrupt
001E62  A9209A     BCLR IEC3, #1
57:                	SPI_E_IE = 1;
001E64  A8409A     BSET IEC3, #2
58:                }
001E66  060000     RETURN
59:                
60:                void SPI_ClearBufs(void)
61:                {
62:                	__builtin_disi(0x3FFF); //disable interrupts
001E68  FC3FFF     DISI #0x3FFF
63:                	rxBuf.tail = &rxBuf.buffer[0]; //Initialize the pointers
001E6A  20AFE0     MOV #0xAFE, W0
001E6C  885A00     MOV W0, 0xB40
64:                	rxBuf.head = &rxBuf.buffer[0];
001E6E  8859F0     MOV W0, 0xB3E
65:                	txBuf.tail = &txBuf.buffer[0];
001E70  20B440     MOV #0xB44, W0
001E72  885C30     MOV W0, 0xB86
66:                	txBuf.head = &txBuf.buffer[0];
001E74  885C20     MOV W0, 0xB84
67:                	txBuf.byteCount = 0;
001E76  EF2B88     CLR 0xB88
68:                	rxBuf.byteCount = 0;
001E78  EF2B42     CLR 0xB42
69:                	__builtin_disi(0); //enable interrupts
001E7A  FC0000     DISI #0x0
70:                }
001E7C  060000     RETURN
71:                
72:                void SPI_TxStart(void)
73:                {
74:                	__builtin_disi(0x3FFF); //disable interrupts
001E7E  FC3FFF     DISI #0x3FFF
75:                	if (txBuf.byteCount) { // prime the transmit interrupt
001E80  E20B88     CP0 0xB88
001E82  32000E     BRA Z, 0x1EA0
76:                		/* write data here */
77:                		SPI_X_IF = 0; //Clear interrupt flag
001E84  A9208A     BCLR IFS3, #1
78:                		SPI_BUF = *txBuf.tail++; //Load next byte into the TX buffer
001E86  805C30     MOV 0xB86, W0
001E88  FB80B0     ZE [W0++], W1
001E8A  881081     MOV W1, SSP2BUF
001E8C  885C30     MOV W0, 0xB86
79:                		if (txBuf.tail > &txBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
001E8E  20B831     MOV #0xB83, W1
001E90  500F81     SUB W0, W1, [W15]
001E92  360002     BRA LEU, 0x1E98
80:                			txBuf.tail = &txBuf.buffer[0]; //Wrap pointer to beginning
001E94  20B440     MOV #0xB44, W0
001E96  885C30     MOV W0, 0xB86
81:                		}
82:                		txBuf.byteCount--; //Decrement byte count
001E98  ED2B88     DEC 0xB88
83:                		SPI_X_IE = 1; //Enable transmit interrupts
001E9A  A8209A     BSET IEC3, #1
84:                		__builtin_disi(0); //enable interrupts
001E9C  FC0000     DISI #0x0
85:                		return;
001E9E  370001     BRA 0x1EA2
86:                	}
87:                	__builtin_disi(0); //enable interrupts
001EA0  FC0000     DISI #0x0
88:                	return;
89:                }
001EA2  060000     RETURN
90:                
91:                bool SPI_IsNewRxData(void)
92:                {
93:                	__builtin_disi(0x3FFF); //disable interrupts
001EA4  FC3FFF     DISI #0x3FFF
94:                	if (rxBuf.byteCount == 0) { //Check if data in buffer
001EA6  E20B42     CP0 0xB42
001EA8  3A0003     BRA NZ, 0x1EB0
95:                		__builtin_disi(0); //enable interrupts
001EAA  FC0000     DISI #0x0
96:                		return(false); //No bytes in the buffer so return false
001EAC  EB4000     CLR.B W0
001EAE  370002     BRA 0x1EB4
97:                	}
98:                	__builtin_disi(0); //enable interrupts
001EB0  FC0000     DISI #0x0
99:                	return(true); //There are bytes in the buffer
001EB2  B3C010     MOV.B #0x1, W0
100:               }
001EB4  060000     RETURN
101:               
102:               uint8_t SPI_ReadRxBuffer(void)
103:               {
104:               	uint8_t Temp;
105:               
106:               	__builtin_disi(0x3FFF); //disable interrupts
001EB6  FC3FFF     DISI #0x3FFF
107:               	if (rxBuf.byteCount == 0) { //For safety, do not allow read of empty buffer
001EB8  E20B42     CP0 0xB42
001EBA  3A0003     BRA NZ, 0x1EC2
108:               		__builtin_disi(0); //enable interrupts
001EBC  FC0000     DISI #0x0
109:               		return(0); //Return zero if there is nothing in the buffer
001EBE  EB4000     CLR.B W0
001EC0  37000A     BRA 0x1ED6
110:               	}
111:               
112:               	rxBuf.byteCount--; //Decrement byte count
001EC2  ED2B42     DEC 0xB42
113:               	__builtin_disi(0); //enable interrupts
001EC4  FC0000     DISI #0x0
114:               	Temp = *rxBuf.tail++; //Get the byte and increment the pointer
001EC6  805A01     MOV 0xB40, W1
001EC8  784031     MOV.B [W1++], W0
001ECA  885A01     MOV W1, 0xB40
115:               	if (rxBuf.tail > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if at end of buffer
001ECC  20B3D2     MOV #0xB3D, W2
001ECE  508F82     SUB W1, W2, [W15]
001ED0  360002     BRA LEU, 0x1ED6
116:               		rxBuf.tail = &rxBuf.buffer[0]; //then wrap the pointer to beginning
001ED2  20AFE1     MOV #0xAFE, W1
001ED4  885A01     MOV W1, 0xB40
117:               	}
118:               	return(Temp);
119:               }
001ED6  060000     RETURN
120:               
121:               bool SPI_IsTxData(void)
122:               {
123:               	__builtin_disi(0x3FFF); //disable interrupts
001ED8  FC3FFF     DISI #0x3FFF
124:               	if (txBuf.byteCount == 0) { //Check if data in buffer
001EDA  E20B88     CP0 0xB88
001EDC  3A0003     BRA NZ, 0x1EE4
125:               		__builtin_disi(0); //enable interrupts
001EDE  FC0000     DISI #0x0
126:               		return(false); //No bytes in the buffer so return false
001EE0  EB4000     CLR.B W0
001EE2  370002     BRA 0x1EE8
127:               	}
128:               	__builtin_disi(0); //enable interrupts
001EE4  FC0000     DISI #0x0
129:               	return(true); //There are bytes in the buffer
001EE6  B3C010     MOV.B #0x1, W0
130:               }
001EE8  060000     RETURN
131:               
132:               void SPI_WriteTxBuffer(const uint8_t TxByte)
133:               {
134:               	*txBuf.head++ = TxByte; //Put the byte in the transmit buffer and increment the pointer
001EEA  805C21     MOV 0xB84, W1
001EEC  785880     MOV.B W0, [W1++]
001EEE  885C21     MOV W1, 0xB84
135:               	if (txBuf.head > &txBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if at end of buffer
001EF0  20B830     MOV #0xB83, W0
001EF2  508F80     SUB W1, W0, [W15]
001EF4  360002     BRA LEU, 0x1EFA
136:               		txBuf.head = &txBuf.buffer[0]; //Wrap pointer to beginning
001EF6  20B440     MOV #0xB44, W0
001EF8  885C20     MOV W0, 0xB84
137:               	}
138:               	__builtin_disi(0x3FFF); //disable interrupts
001EFA  FC3FFF     DISI #0x3FFF
139:               	if (txBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
001EFC  2003F0     MOV #0x3F, W0
001EFE  E30B88     CP 0xB88
001F00  3E0001     BRA GTU, 0x1F04
140:               		txBuf.byteCount++;
001F02  EC2B88     INC 0xB88
141:               	}
142:               	__builtin_disi(0); //enable interrupts
001F04  FC0000     DISI #0x0
143:               }
001F06  060000     RETURN
144:               
145:               //**********************************************************************************************************************
146:               // Return the number of bytes free in the TX buffer
147:               
148:               uint16_t SPI_GetTXBufferFreeSpace(void)
149:               {
150:               	uint16_t space;
151:               
152:               	__builtin_disi(0x3FFF); //disable interrupts            
001F08  FC3FFF     DISI #0x3FFF
153:               	space = SIZE_SPI_Buffer - txBuf.byteCount;
001F0A  805C40     MOV 0xB88, W0
001F0E  200401     MOV #0x40, W1
001F10  508000     SUB W1, W0, W0
154:               	__builtin_disi(0); //enable interrupts
001F0C  FC0000     DISI #0x0
155:               	return space;
156:               }
001F12  060000     RETURN
157:               
158:               //Peek at buffer tail
159:               
160:               uint8_t SPI_PeekRxBuffer(void)
161:               {
162:               	__builtin_disi(0x3FFF); //disable interrupts
001F14  FC3FFF     DISI #0x3FFF
163:               	if (rxBuf.byteCount == 0) { //Check if pointers are the same
001F16  E20B42     CP0 0xB42
001F18  3A0003     BRA NZ, 0x1F20
164:               		__builtin_disi(0); //enable interrupts
001F1A  FC0000     DISI #0x0
165:               		return(NULL); //No bytes in the buffer so return NULL
001F1C  EB4000     CLR.B W0
001F1E  370003     BRA 0x1F26
166:               	} else {
167:               		__builtin_disi(0); //enable interrupts
001F20  FC0000     DISI #0x0
168:               		return *rxBuf.tail;
001F22  805A00     MOV 0xB40, W0
001F24  784010     MOV.B [W0], W0
169:               	}
170:               }
001F26  060000     RETURN
171:               
172:               void __attribute__((interrupt, no_auto_psv)) _MSSP2Interrupt(void)
173:               {
001F28  BE9F80     MOV.D W0, [W15++]
174:               	SPI_X_IF = 0; //Clear interrupt flag
001F2A  A9208A     BCLR IFS3, #1
175:               	if (txBuf.byteCount > 0) { //Check if more data is in the buffer
001F2C  E20B88     CP0 0xB88
001F2E  320018     BRA Z, 0x1F60
176:               		/* read data HERE */
177:               		*rxBuf.head++ = SPI_BUF; //Put received byte in the buffer
001F30  801081     MOV SSP2BUF, W1
001F32  8059F0     MOV 0xB3E, W0
001F34  785801     MOV.B W1, [W0++]
001F36  8859F0     MOV W0, 0xB3E
178:               		if (rxBuf.head > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
001F38  20B3D1     MOV #0xB3D, W1
001F3A  500F81     SUB W0, W1, [W15]
001F3C  360002     BRA LEU, 0x1F42
179:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
001F3E  20AFE0     MOV #0xAFE, W0
001F40  8859F0     MOV W0, 0xB3E
180:               		}
181:               		if (rxBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
001F42  2003F0     MOV #0x3F, W0
001F44  E30B42     CP 0xB42
001F46  3E0001     BRA GTU, 0x1F4A
182:               			rxBuf.byteCount++;
001F48  EC2B42     INC 0xB42
183:               		}
184:               
185:               		/* write data here */
186:               		SPI_BUF = *txBuf.tail++; //Load next byte into the TX buffer
001F4A  805C30     MOV 0xB86, W0
001F4C  FB80B0     ZE [W0++], W1
001F4E  881081     MOV W1, SSP2BUF
001F50  885C30     MOV W0, 0xB86
187:               		if (txBuf.tail > &txBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
001F52  20B831     MOV #0xB83, W1
001F54  500F81     SUB W0, W1, [W15]
001F56  360002     BRA LEU, 0x1F5C
188:               			txBuf.tail = &txBuf.buffer[0]; //Wrap pointer to beginning
001F58  20B440     MOV #0xB44, W0
001F5A  885C30     MOV W0, 0xB86
189:               		}
190:               		txBuf.byteCount--; //Decrement byte count
001F5C  ED2B88     DEC 0xB88
001F5E  37000F     BRA 0x1F7E
191:               	} else {
192:               		/* read data HERE */
193:               		*rxBuf.head++ = SPI_BUF; //Put received byte in the buffer
001F60  801081     MOV SSP2BUF, W1
001F62  8059F0     MOV 0xB3E, W0
001F64  785801     MOV.B W1, [W0++]
001F66  8859F0     MOV W0, 0xB3E
194:               		if (rxBuf.head > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
001F68  20B3D1     MOV #0xB3D, W1
001F6A  500F81     SUB W0, W1, [W15]
001F6C  360002     BRA LEU, 0x1F72
195:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
001F6E  20AFE0     MOV #0xAFE, W0
001F70  8859F0     MOV W0, 0xB3E
196:               		}
197:               		if (rxBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
001F72  2003F0     MOV #0x3F, W0
001F74  E30B42     CP 0xB42
001F76  3E0001     BRA GTU, 0x1F7A
198:               			rxBuf.byteCount++;
001F78  EC2B42     INC 0xB42
199:               		}
200:               		SPI_X_IE = 0; //No more data to transmit, so stop interrupts
001F7A  A9209A     BCLR IEC3, #1
201:               		SPI_CS0 = 1; // deselect all devices here
001F7C  A862C4     BSET LATA, #3
202:               //		SPI_CS1 = 1;
203:               	}
204:               }
001F7E  BE004F     MOV.D [--W15], W0
001F80  064000     RETFIE
205:               
206:               void __attribute__((interrupt, no_auto_psv)) _MSSP2BCInterrupt(void)
207:               {
001F82  BE9F80     MOV.D W0, [W15++]
208:               	SPI_E_IF = 0; //Clear interrupt flag
001F84  A9408A     BCLR IFS3, #2
209:               
210:               	//Handle an overflow error by reading next byte and clearing flags
211:               	if (SSP2CON1bits.WCOL || SSP2CON1bits.SSPOV) {
001F86  ABE212     BTST SSP2CON1, #7
001F88  3A0002     BRA NZ, 0x1F8E
001F8A  ABC212     BTST SSP2CON1, #6
001F8C  32000F     BRA Z, 0x1FAC
212:               		*rxBuf.head++ = SPI_BUF; //Put received byte in the buffer
001F8E  801081     MOV SSP2BUF, W1
001F90  8059F0     MOV 0xB3E, W0
001F92  785801     MOV.B W1, [W0++]
001F94  8859F0     MOV W0, 0xB3E
213:               		if (rxBuf.head > &rxBuf.buffer[SIZE_SPI_Buffer - 1]) { //Check if end of buffer
001F96  20B3D1     MOV #0xB3D, W1
001F98  500F81     SUB W0, W1, [W15]
001F9A  360002     BRA LEU, 0x1FA0
214:               			rxBuf.head = &rxBuf.buffer[0]; //Wrap pointer to beginning
001F9C  20AFE0     MOV #0xAFE, W0
001F9E  8859F0     MOV W0, 0xB3E
215:               		}
216:               		if (rxBuf.byteCount < SIZE_SPI_Buffer) { //Increment byte count
001FA0  2003F0     MOV #0x3F, W0
001FA2  E30B42     CP 0xB42
001FA4  3E0001     BRA GTU, 0x1FA8
217:               			rxBuf.byteCount++;
001FA6  EC2B42     INC 0xB42
218:               		}
219:               		SSP2CON1bits.WCOL = 0;
001FA8  A9E212     BCLR SSP2CON1, #7
220:               		SSP2CON1bits.SSPOV = 0;
001FAA  A9C212     BCLR SSP2CON1, #6
221:               	}
222:               
223:               	//Clear any other error bits
224:               
225:               }
001FAC  BE004F     MOV.D [--W15], W0
001FAE  064000     RETFIE
---  /sdd/work/fac_relay_clone/main.c  ------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        main.c
29:                 * Date:        Oct 27, 2016
30:                 * Compiler:    XC16 v1.26
31:                 * 
32:                 * Remote Relay mods Oct 2016 FGB@MCHP
33:                 * ported to PIC24FV 
34:                 * Version updates
35:                 * V2.1 DFU OTA mode added, input port shared with relay #4 output
36:                 *
37:                 */
38:                
39:                #include <xc.h>
40:                #include <stdint.h>
41:                #include "app.h"
42:                #include "config.h"
43:                #include "spi.h"
44:                #include "timers.h"
45:                
46:                void initBoard(void);
47:                
48:                // PIC24FV16KM202 Configuration Bit Settings
49:                
50:                // 'C' source line config statements
51:                
52:                // FBS
53:                #pragma config BWRP = OFF               // Boot Segment Write Protect (Disabled)
54:                #pragma config BSS = OFF                // Boot segment Protect (No boot program flash segment)
55:                
56:                // FGS
57:                #pragma config GWRP = OFF               // General Segment Write Protect (General segment may be written)
58:                #pragma config GCP = OFF                // General Segment Code Protect (No Protection)
59:                
60:                // FOSCSEL
61:                #pragma config FNOSC = FRCPLL           // Oscillator Select (Fast RC Oscillator with Postscaler and PLL Module (FRCDIV+PLL))
62:                #pragma config SOSCSRC = DIG            // SOSC Source Type (Digital Mode for use with external source)
63:                #pragma config LPRCSEL = HP             // LPRC Oscillator Power and Accuracy (High Power, High Accuracy Mode)
64:                #pragma config IESO = OFF               // Internal External Switch Over bit (Internal External Switchover mode disabled (Two-speed Start-up disabled))
65:                
66:                // FOSC
67:                #pragma config POSCMOD = NONE           // Primary Oscillator Configuration bits (Primary oscillator disabled)
68:                #pragma config OSCIOFNC = IO            // CLKO Enable Configuration bit (Port I/O enabled (CLKO disabled))
69:                #pragma config POSCFREQ = LS            // Primary Oscillator Frequency Range Configuration bits (Primary oscillator/external clock input frequency less than 100kHz)
70:                #pragma config SOSCSEL = SOSCLP         // SOSC Power Selection Configuration bits (Secondary Oscillator configured for low-power operation)
71:                #pragma config FCKSM = CSECME           // Clock Switching and Monitor Selection (Both Clock Switching and Fail-safe Clock Monitor are enabled)
72:                
73:                // FWDT
74:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscale Select bits (1:32768)
75:                #pragma config FWPSA = PR128            // WDT Prescaler bit (WDT prescaler ratio of 1:128)
76:                #pragma config FWDTEN = ON              // Watchdog Timer Enable bits (WDT enabled in hardware)
77:                #pragma config WINDIS = OFF             // Windowed Watchdog Timer Disable bit (Standard WDT selected(windowed WDT disabled))
78:                
79:                // FPOR
80:                #pragma config BOREN = BOR0             // Brown-out Reset Enable bits (Brown-out Reset disabled in hardware, SBOREN bit disabled)
81:                #pragma config RETCFG = OFF             //  (Retention regulator is not available)
82:                #pragma config PWRTEN = ON              // Power-up Timer Enable bit (PWRT enabled)
83:                #pragma config I2C1SEL = SEC            // Alternate I2C1 Pin Mapping bit (Use  Alternate ASCL1/ASDA1 Pins For I2C1)
84:                #pragma config BORV = V18               // Brown-out Reset Voltage bits (Brown-out Reset set to lowest voltage (1.8V))
85:                #pragma config MCLRE = ON               // MCLR Pin Enable bit (RA5 input pin disabled, MCLR pin enabled)
86:                
87:                // FICD
88:                #pragma config ICS = PGx1               // ICD Pin Placement Select bits (EMUC/EMUD share PGC1/PGD1)
89:                
90:                // #pragma config statements should precede project file includes.
91:                // Use project enums instead of #define for ON and OFF.
92:                
93:                //**********************************************************************************************************************
94:                // Main routine - start of executable code
95:                
96:                int main(void)
97:                {
98:                	initBoard(); //Initialize the pins and peripherals
00232A  07FF8A     RCALL initBoard
99:                
100:               	while (1) {
101:               		APP_Tasks();
00232C  07FCED     RCALL APP_Tasks
102:               		Idle(); //Idle until an interrupt is generated
00232E  FE4001     PWRSAV #1
103:               		RCONbits.IDLE = 0;
002330  A94740     BCLR RCON, #2
104:               //		if (SPI_GetTXBufferFreeSpace() > 8) {
105:               //			SPI_WriteTxBuffer(0x81);
106:               //			SPI_WriteTxBuffer('O');
107:               //			SPI_WriteTxBuffer('U');
108:               //			SPI_WriteTxBuffer(0xff);
109:               //			SPI_TxStart();
110:               //			WaitMs(2);
111:               //		}
112:               		ClrWdt();
002332  FE6000     CLRWDT
002334  37FFFB     BRA 0x232C
113:               	}
114:               
115:               	//End of while(1) main loop
116:               	return(true);
117:               }
118:               
119:               //**********************************************************************************************************************
120:               // Initialize the pins and peripherals
121:               
122:               void initBoard(void)
123:               
124:               {	/****************************************************************************
125:               	 * Oscillator Init
126:               	 * Clocking is setup at 32MHz sys clock and to allow USB functionality
127:               	 * Self-tune on SOF is enabled if USB is enabled and connected to host
128:               	 ***************************************************************************/
129:               	// DOZEN disabled; DOZE 1:16; CPDIV 1:1; RCDIV FRC/1; PLLEN disabled; ROI disabled;
130:               	CLKDIVbits.RCDIV = 0;
002240  2F8FF0     MOV #0xF8FF, W0
002242  B62744     AND CLKDIV
131:               	OSCCONbits.COSC = 0x1;
002244  803A10     MOV OSCCON, W0
002246  A0C000     BSET W0, #12
002248  A1D000     BCLR W0, #13
00224A  A1E000     BCLR W0, #14
00224C  883A10     MOV W0, OSCCON
132:               	OSCCONbits.NOSC = 0x1;
00224E  803A10     MOV OSCCON, W0
002250  A08000     BSET W0, #8
002252  A19000     BCLR W0, #9
002254  A1A000     BCLR W0, #10
002256  883A10     MOV W0, OSCCON
133:               
134:               	// STSRC USB; STEN enabled; STOR disabled; STORPOL Interrupt when STOR is 1; STLOCK disabled; STLPOL Interrupt when STLOCK is 1; STSIDL disabled; TUN Center frequency; 
135:               	OSCTUN = 0x0;
002258  EF2748     CLR OSCTUN
136:               
137:               	//Enable low voltage retention sleep mode
138:               	RCONbits.RETEN = 1;
00225A  A88741     BSET 0x741, #4
139:               
140:               	RCONbits.SWDTEN = 0;
00225C  A9A740     BCLR RCON, #5
141:               
142:               #ifdef SET_PMD_BITS    //see config.h, Application settings section
143:               	/****************************************************************************
144:               	 * PMD bits - setting a bit disables clocking to that peripheral
145:               	 * (drops operating current by about 2 mA when used in this app)
146:               	 ***************************************************************************/
147:               	PMD1bits.T4MD = 1;
148:               
149:               #if !defined (USE_SLEEP) || defined (SLEEP_MODE_RTCC)    //see config.h, Application settings section
150:               	PMD1bits.T1MD = 1;
151:               #endif
152:               
153:               	PMD1bits.I2C1MD = 1;
154:               	PMD1bits.U2MD = 1;
155:               	PMD1bits.SPI2MD = 1;
156:               	PMD1bits.SPI1MD = 1;
157:               	PMD3bits.TXMMD = 1;
158:               
159:               #if !defined (USE_SLEEP) || !defined (SLEEP_MODE_RTCC)    //see config.h, Application settings section
160:               	PMD3bits.RTCCMD = 1;
161:               #endif
162:               
163:               	PMD3bits.PMPMD = 1;
164:               	PMD3bits.CRCMD = 1;
165:               	PMD3bits.DAC1MD = 1;
166:               	PMD3bits.U3MD = 1;
167:               	PMD3bits.I2C2MD = 1;
168:               	PMD2 = 0xFFFF;
169:               	PMD4bits.UPWMMD = 1;
170:               	PMD4bits.U4MD = 1;
171:               	PMD4bits.REFOMD = 1;
172:               	PMD4bits.CTMUMD = 1;
173:               	PMD4bits.HLVDMD = 1;
174:               	PMD5 = 0xFFFF;
175:               	PMD6 = 0xFFFF;
176:               	PMD7 = 0xFFFF;
177:               #endif
178:               
179:               	/****************************************************************************
180:               	 * GPIO Init
181:               	 ***************************************************************************/
182:               	ANSA = 0x00;
00225E  EF24E0     CLR ANSA
183:               	ANSB = 0x00;
002260  EF24E2     CLR ANSB
184:               
185:               
186:               	CNPU1 = 0;
002262  EF206E     CLR CNPU1
187:               	CNPU2 = 0;
002264  EF2070     CLR CNPU2
188:               	CNPU1bits.CN7PUE = 1; // pullup for RB3
002266  A8E06E     BSET CNPU1, #7
189:               
190:               
191:               	CNPD1 = 0;
002268  EF2056     CLR CNPD1
192:               	CNPD2 = 0;
00226A  EF2058     CLR CNPD2
193:               
194:               
195:               	CNEN1 = 0x0000;
00226C  EF2062     CLR CNEN1
196:               	CNEN2 = 0x0000;
00226E  EF2064     CLR CNEN2
197:               
198:               	ODCB = 0x0000;
002270  EF22CE     CLR ODCB
199:               
200:               	IEC1bits.CNIE = 1;
002272  A86096     BSET IEC1, #3
201:               
202:               	// RELAYs are outputs and open-drain
203:               	// to drive ILQ2 opto
204:               	// setup in Mikrobus header
205:               	//	ODCDbits.ODD3 = 1; // pin 16
206:               	//	ODCDbits.ODD9 = 1; // pin 11
207:               	//	ODCDbits.ODD10 = 1; // pin 12
208:               	//	ODCDbits.ODD4 = 1; // pin 2
209:               
210:               	// LEDs are outputs and off
211:               	LED1 = 1;
002274  A8A2CD     BSET 0x2CD, #5
212:               	LED2 = 0;
002276  A982CD     BCLR 0x2CD, #4
213:               	LED3 = 0;
002278  A982CC     BCLR LATB, #4
214:               	LED4 = 0;
00227A  A962CC     BCLR LATB, #3
215:               	LED5 = 0;
00227C  A9A2CD     BCLR 0x2CD, #5
216:               	LED6 = 0;
00227E  A9A2CD     BCLR 0x2CD, #5
217:               	LED7 = 0;
002280  A9A2CD     BCLR 0x2CD, #5
218:               	LED_TRIS1 = 0;
002282  A9A2C9     BCLR 0x2C9, #5
219:               	LED_TRIS2 = 0;
002284  A982C9     BCLR 0x2C9, #4
220:               	LED_TRIS3 = 0;
002286  A982C8     BCLR TRISB, #4
221:               	LED_TRIS4 = 0;
002288  A962C8     BCLR TRISB, #3
222:               	SLED = 0;
00228A  A9C2CD     BCLR 0x2CD, #6
223:               	SLED_TRIS = 0;
00228C  A9C2C9     BCLR 0x2C9, #6
224:               
225:               	//RN4020 module - UART1
226:               	BT_WAKE_HW = 1; //Dormant line is set high
00228E  A842CD     BSET 0x2CD, #2
227:               	BT_WAKE_HW_TRIS = 0; //Dormant line is output
002290  A942C9     BCLR 0x2C9, #2
228:               
229:               	BT_WAKE_SW = 0; //keep low until after UART is initialized
002292  A962CD     BCLR 0x2CD, #3
230:               	BT_WAKE_SW_TRIS = 0;
002294  A962C9     BCLR 0x2C9, #3
231:               
232:               	BT_CMD = 0; //Command mode on
002296  A902C4     BCLR LATA, #0
233:               	BT_CMD_TRIS = 0;
002298  A902C0     BCLR TRISA, #0
234:               
235:               	BT_WS_TRIS = 1;
00229A  A842C0     BSET TRISA, #2
236:               	BT_MLDP_EV_TRIS = 1;
00229C  A882C0     BSET TRISA, #4
237:               	BT_CONNECTED_TRIS = 1;
00229E  A822C0     BSET TRISA, #1
238:               
239:               	U1CTS_TRIS = 1;
0022A0  A802C9     BSET 0x2C9, #0
240:               	U1RX_TRIS = 1;
0022A2  A842C8     BSET TRISB, #2
241:               	U1RTS_LAT = 0;
0022A4  A922CD     BCLR 0x2CD, #1
242:               	U1RTS_TRIS = 0;
0022A6  A922C9     BCLR 0x2C9, #1
243:               	U1TX_TRIS = 0;
0022A8  A9E2C8     BCLR TRISB, #7
244:               
245:               	// SPI Master Devices
246:               	SPI_CS0_TRIS = 0;
0022AA  A962C0     BCLR TRISA, #3
247:               	SPI_CS1_TRIS = 0;
0022AC  A9E2C9     BCLR 0x2C9, #7
248:               
249:               	/****************************************************************************
250:               	 * PPS Init - Peripheral Pin Select
251:               	 * Click Boards using PPS-controlled peripherals will require additional
252:               	 * setup here
253:               	 ***************************************************************************/
254:               	__builtin_disi(0x3FFF); //disable interrupts
0022AE  FC3FFF     DISI #0x3FFF
255:               
256:               	//unlock registers
257:               	__builtin_write_OSCCONL(OSCCON & 0xBF);
0022B0  200BF2     MOV #0xBF, W2
0022B2  803A10     MOV OSCCON, W0
0022B4  610100     AND W2, W0, W2
0022B6  200460     MOV #0x46, W0
0022B8  200571     MOV #0x57, W1
0022BA  207423     MOV #0x742, W3
0022BC  784980     MOV.B W0, [W3]
0022BE  784981     MOV.B W1, [W3]
0022C0  784982     MOV.B W2, [W3]
258:               
259:               	__builtin_write_OSCCONL(OSCCON | 0x40);
0022C2  803A12     MOV OSCCON, W2
0022C4  A06002     BSET W2, #6
0022C6  207423     MOV #0x742, W3
0022C8  784980     MOV.B W0, [W3]
0022CA  784981     MOV.B W1, [W3]
0022CC  784982     MOV.B W2, [W3]
260:               
261:               	__builtin_disi(0); //enable interrupts
0022CE  FC0000     DISI #0x0
262:               
263:               	/****************************************************************************
264:               	 * Interrupt Priorities
265:               	 * Interrupt-enabled peripherals being used for Click Boards should be
266:               	 * configured here as well
267:               	 ***************************************************************************/
268:               
269:               	// SPI
270:               	// error
271:               	IPC12bits.BCL2IP = 6;
0022D0  8005E0     MOV IPC12, W0
0022D2  A18000     BCLR W0, #8
0022D4  A09000     BSET W0, #9
0022D6  A0A000     BSET W0, #10
0022D8  8805E0     MOV W0, IPC12
272:               	// spi_buf
273:               	IPC12bits.SSP2IP = 5;
0022DA  8005E0     MOV IPC12, W0
0022DC  A04000     BSET W0, #4
0022DE  A15000     BCLR W0, #5
0022E0  A06000     BSET W0, #6
0022E2  8805E0     MOV W0, IPC12
274:               
275:               	//    UERI: U1E - UART1 Error
276:               	//    Priority: 6
277:               	IPC16bits.U1ERIP = 6;
0022E4  800620     MOV IPC16, W0
0022E6  A14000     BCLR W0, #4
0022E8  B30600     IOR #0x60, W0
0022EA  880620     MOV W0, IPC16
278:               
279:               	//    UTXI: U1TX - UART1 Transmitter
280:               	//    Priority: 5
281:               	IPC3bits.U1TXIP = 5;
0022EC  800550     MOV IPC3, W0
0022EE  A00000     BSET W0, #0
0022F0  A11000     BCLR W0, #1
0022F2  A02000     BSET W0, #2
0022F4  880550     MOV W0, IPC3
282:               
283:               	//    URXI: U1RX - UART1 Receiver
284:               	//    Priority: 5
285:               	IPC2bits.U1RXIP = 5;
0022F6  800540     MOV IPC2, W0
0022F8  A0C000     BSET W0, #12
0022FA  A1D000     BCLR W0, #13
0022FC  A0E000     BSET W0, #14
0022FE  880540     MOV W0, IPC2
286:               
287:               
288:               	//    TI: T1 - Timer1
289:               	//    Priority: 3
290:               	IPC0bits.T1IP = 3;
002300  800520     MOV IPC0, W0
002302  A0C000     BSET W0, #12
002304  A0D000     BSET W0, #13
002306  A1E000     BCLR W0, #14
002308  880520     MOV W0, IPC0
291:               
292:               	//    RTCI: RTCC - Real-Time Clock and Calendar
293:               	//    Priority: 2
294:               	IPC15bits.RTCIP = 2;
00230A  800610     MOV IPC15, W0
00230C  A18000     BCLR W0, #8
00230E  A09000     BSET W0, #9
002310  A1A000     BCLR W0, #10
002312  880610     MOV W0, IPC15
295:               
296:               	//    CN: Switches - change notification
297:               	//    Priority: 2
298:               	IPC4bits.CNIP = 2;
002314  800560     MOV IPC4, W0
002316  A1C000     BCLR W0, #12
002318  A0D000     BSET W0, #13
00231A  A1E000     BCLR W0, #14
00231C  880560     MOV W0, IPC4
299:               
300:               	//    ADI: ADC1 - Pipeline A/D Converter 1
301:               	//    Priority: 1
302:               	IPC3bits.AD1IP = 1;
00231E  800550     MOV IPC3, W0
002320  A04000     BSET W0, #4
002322  A15000     BCLR W0, #5
002324  A16000     BCLR W0, #6
002326  880550     MOV W0, IPC3
303:               }
002328  060000     RETURN
---  /sdd/work/fac_relay_clone/leds.c  ------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        leds.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 * add relay outputs
32:                 *
33:                 * LED functions
34:                 *
35:                 */
36:                
37:                #include "timers.h"
38:                #include "config.h"
39:                #include "leds.h"
40:                #include "app.h"
41:                
42:                extern APP_DATA appData;
43:                extern ADC_DATA adcData;
44:                static LED_LIGHTSHOW_T lightShow = LED_IDLE;
45:                
46:                void LED_Tasks()
47:                {
48:                	switch (lightShow) {
001FB0  805D40     MOV lightShow, W0
001FB2  500FE2     SUB W0, #0x2, [W15]
001FB4  320029     BRA Z, 0x2008
001FB6  3E0005     BRA GTU, 0x1FC2
001FB8  E00000     CP0 W0
001FBA  320008     BRA Z, 0x1FCC
001FBC  500FE1     SUB W0, #0x1, [W15]
001FBE  3A0089     BRA NZ, 0x20D2
001FC0  37000C     BRA 0x1FDA
001FC2  500FE3     SUB W0, #0x3, [W15]
001FC4  320066     BRA Z, 0x2092
001FC6  500FE4     SUB W0, #0x4, [W15]
001FC8  3A0084     BRA NZ, 0x20D2
001FCA  37007D     BRA 0x20C6
49:                	case LED_IDLE:
50:                		LED1 = 0;
001FCC  A9A2CD     BCLR 0x2CD, #5
51:                		LED2 = 0;
001FCE  A982CD     BCLR 0x2CD, #4
52:                		LED3 = 0;
001FD0  A982CC     BCLR LATB, #4
53:                		LED4 = 0;
001FD2  A962CC     BCLR LATB, #3
54:                		LED5 = 1;
001FD4  A8A2CD     BSET 0x2CD, #5
55:                		LED6 = 0;
001FD6  A9A2CD     BCLR 0x2CD, #5
56:                		break;
001FD8  37007C     BRA 0x20D2
57:                
58:                	case LED_BTLE_ADVERTISING:
59:                		LED1 = 0;
001FDA  A9A2CD     BCLR 0x2CD, #5
60:                		LED2 = 0;
001FDC  A982CD     BCLR 0x2CD, #4
61:                		LED3 = 0;
001FDE  A982CC     BCLR LATB, #4
62:                		LED4 = 0;
001FE0  A962CC     BCLR LATB, #3
63:                		LED6 = 0;
001FE2  A9A2CD     BCLR 0x2CD, #5
64:                		if (TimerDone(TMR_LEDS)) {
001FE4  B3C010     MOV.B #0x1, W0
001FE6  0702A0     RCALL TimerDone
001FE8  E00400     CP0.B W0
001FEA  320073     BRA Z, 0x20D2
65:                			LED5 ^= 1;
001FEC  801660     MOV LATB, W0
001FEE  DE004D     LSR W0, #13, W0
001FF0  EA8000     COM W0, W0
001FF2  600061     AND W0, #0x1, W0
001FF4  DD004D     SL W0, #13, W0
001FF6  2DFFF1     MOV #0xDFFF, W1
001FF8  801662     MOV LATB, W2
001FFA  608082     AND W1, W2, W1
001FFC  700081     IOR W0, W1, W1
001FFE  881661     MOV W1, LATB
66:                			StartTimer(TMR_LEDS, LED_BLINK_MS);
002000  201F41     MOV #0x1F4, W1
002002  B3C010     MOV.B #0x1, W0
002004  07028B     RCALL StartTimer
002006  370065     BRA 0x20D2
67:                		}
68:                		break;
69:                
70:                	case LED_BTLE_PAIRED:
71:                		LED1 = appData.led1; // logic high turns on led
002008  20AD91     MOV #0xAD9, W1
00200A  784091     MOV.B [W1], W1
00200C  608161     AND W1, #0x1, W2
00200E  DD11CD     SL W2, #13, W3
002010  2DFFF0     MOV #0xDFFF, W0
002012  801665     MOV LATB, W5
002014  600205     AND W0, W5, W4
002016  718204     IOR W3, W4, W4
002018  881664     MOV W4, LATB
72:                		SLED = appData.led1; // logic high turns on led
00201A  DD114E     SL W2, #14, W2
00201C  2BFFF3     MOV #0xBFFF, W3
00201E  801664     MOV LATB, W4
002020  618184     AND W3, W4, W3
002022  710183     IOR W2, W3, W3
002024  881663     MOV W3, LATB
73:                		RELAY1 = !appData.led1; // logic low turns on relay
002026  A20401     BTG.B W1, #0
002028  6080E1     AND W1, #0x1, W1
00202A  DD08CD     SL W1, #13, W1
00202C  B602CC     AND LATB, WREG
00202E  708000     IOR W1, W0, W0
002030  881660     MOV W0, LATB
74:                		LED2 = appData.led2;
002032  20ADA1     MOV #0xADA, W1
002034  784091     MOV.B [W1], W1
002036  608161     AND W1, #0x1, W2
002038  DD114C     SL W2, #12, W2
00203A  2EFFF0     MOV #0xEFFF, W0
00203C  801665     MOV LATB, W5
00203E  600185     AND W0, W5, W3
002040  710183     IOR W2, W3, W3
002042  881663     MOV W3, LATB
75:                		RELAY2 = !appData.led2;
002044  A20401     BTG.B W1, #0
002046  6080E1     AND W1, #0x1, W1
002048  DD08CC     SL W1, #12, W1
00204A  B602CC     AND LATB, WREG
00204C  708000     IOR W1, W0, W0
00204E  881660     MOV W0, LATB
76:                		LED3 = appData.led3;
002050  20ADB1     MOV #0xADB, W1
002052  784091     MOV.B [W1], W1
002054  608161     AND W1, #0x1, W2
002056  DD1144     SL W2, #4, W2
002058  2FFEF0     MOV #0xFFEF, W0
00205A  801664     MOV LATB, W4
00205C  600184     AND W0, W4, W3
00205E  710183     IOR W2, W3, W3
002060  881663     MOV W3, LATB
77:                		RELAY3 = !appData.led3;
002062  A20401     BTG.B W1, #0
002064  6080E1     AND W1, #0x1, W1
002066  DD08C4     SL W1, #4, W1
002068  B602CC     AND LATB, WREG
00206A  708000     IOR W1, W0, W0
00206C  881660     MOV W0, LATB
78:                		LED4 = appData.led4;
00206E  20ADC1     MOV #0xADC, W1
002070  784091     MOV.B [W1], W1
002072  608161     AND W1, #0x1, W2
002074  DD1143     SL W2, #3, W2
002076  2FFF70     MOV #0xFFF7, W0
002078  801665     MOV LATB, W5
00207A  600185     AND W0, W5, W3
00207C  710183     IOR W2, W3, W3
00207E  881663     MOV W3, LATB
79:                		RELAY4 = !appData.led4;
002080  A20401     BTG.B W1, #0
002082  6080E1     AND W1, #0x1, W1
002084  DD08C3     SL W1, #3, W1
002086  B602CC     AND LATB, WREG
002088  708000     IOR W1, W0, W0
00208A  881660     MOV W0, LATB
80:                		LED5 = 1;
00208C  A8A2CD     BSET 0x2CD, #5
81:                		LED6 = 0;
00208E  A9A2CD     BCLR 0x2CD, #5
82:                		break;
002090  370020     BRA 0x20D2
83:                
84:                	case LED_ERROR:
85:                		switch (appData.error_code) {
002092  BFCADF     MOV.B 0xADF, WREG
002094  404FE3     ADD.B W0, #0x3, [W15]
002096  320009     BRA Z, 0x20AA
002098  404FE2     ADD.B W0, #0x2, [W15]
00209A  3A000E     BRA NZ, 0x20B8
86:                		case ERROR_INITIALIZATION:
87:                			LED1 = 1;
00209C  A8A2CD     BSET 0x2CD, #5
88:                			LED2 = 0;
00209E  A982CD     BCLR 0x2CD, #4
89:                			LED3 = 0;
0020A0  A982CC     BCLR LATB, #4
90:                			LED4 = 0;
0020A2  A962CC     BCLR LATB, #3
91:                			LED5 = 1;
0020A4  A8A2CD     BSET 0x2CD, #5
92:                			LED6 = 1;
0020A6  A8A2CD     BSET 0x2CD, #5
93:                			break;
0020A8  370014     BRA 0x20D2
94:                		case ERROR_RN_FW:
95:                			LED1 = 1;
0020AA  A8A2CD     BSET 0x2CD, #5
96:                			LED2 = 1;
0020AC  A882CD     BSET 0x2CD, #4
97:                			LED3 = 0;
0020AE  A982CC     BCLR LATB, #4
98:                			LED4 = 0;
0020B0  A962CC     BCLR LATB, #3
99:                			LED5 = 1;
0020B2  A8A2CD     BSET 0x2CD, #5
100:               			LED6 = 1;
0020B4  A8A2CD     BSET 0x2CD, #5
101:               			break;
0020B6  37000D     BRA 0x20D2
102:               		default:
103:               			LED1 = 1;
0020B8  A8A2CD     BSET 0x2CD, #5
104:               			LED2 = 1;
0020BA  A882CD     BSET 0x2CD, #4
105:               			LED3 = 1;
0020BC  A882CC     BSET LATB, #4
106:               			LED4 = 1;
0020BE  A862CC     BSET LATB, #3
107:               			LED5 = 1;
0020C0  A8A2CD     BSET 0x2CD, #5
108:               			LED6 = 1;
0020C2  A8A2CD     BSET 0x2CD, #5
109:               			break;
0020C4  370006     BRA 0x20D2
110:               		}
111:               		break;
112:               
113:               	case LED_SLEEP:
114:               		LED1 = 0;
0020C6  A9A2CD     BCLR 0x2CD, #5
115:               		LED2 = 0;
0020C8  A982CD     BCLR 0x2CD, #4
116:               		LED3 = 0;
0020CA  A982CC     BCLR LATB, #4
117:               		LED4 = 0;
0020CC  A962CC     BCLR LATB, #3
118:               		LED5 = 0;
0020CE  A9A2CD     BCLR 0x2CD, #5
119:               		LED6 = 1;
0020D0  A8A2CD     BSET 0x2CD, #5
120:               		break;
121:               
122:               	default:
123:               		break;
124:               	}
125:               }
0020D2  060000     RETURN
126:               
127:               inline void LED_SET_LightShow(LED_LIGHTSHOW_T setting)
128:               {
129:               	lightShow = setting;
0020D4  885D40     MOV W0, lightShow
130:               }
0020D6  060000     RETURN
131:               
132:               //Update LEDs with status from LED update message
133:               
134:               void GetNewLEDs(void)
135:               {
136:               	appData.led1 = appData.receive_packet[9] == '1' ? 1 : 0;
0020D8  B3C310     MOV.B #0x31, W0
0020DA  20A171     MOV #0xA17, W1
0020DC  784091     MOV.B [W1], W1
0020DE  68C080     XOR.B W1, W0, W1
0020E0  FB8081     ZE W1, W1
0020E2  E90081     DEC W1, W1
0020E4  DE08CF     LSR W1, #15, W1
0020E6  784181     MOV.B W1, W3
0020E8  20AD92     MOV #0xAD9, W2
0020EA  784903     MOV.B W3, [W2]
137:               	appData.led2 = appData.receive_packet[11] == '1' ? 1 : 0;
0020EC  20A191     MOV #0xA19, W1
0020EE  784091     MOV.B [W1], W1
0020F0  68C080     XOR.B W1, W0, W1
0020F2  FB8081     ZE W1, W1
0020F4  E90081     DEC W1, W1
0020F6  DE08CF     LSR W1, #15, W1
0020F8  784181     MOV.B W1, W3
0020FA  20ADA2     MOV #0xADA, W2
0020FC  784903     MOV.B W3, [W2]
138:               	appData.led3 = appData.receive_packet[13] == '1' ? 1 : 0;
0020FE  20A1B1     MOV #0xA1B, W1
002100  784091     MOV.B [W1], W1
002102  68C080     XOR.B W1, W0, W1
002104  FB8081     ZE W1, W1
002106  E90081     DEC W1, W1
002108  DE08CF     LSR W1, #15, W1
00210A  20ADB2     MOV #0xADB, W2
00210C  784901     MOV.B W1, [W2]
139:               	appData.led4 = appData.receive_packet[15] == '1' ? 1 : 0;
00210E  20A1D2     MOV #0xA1D, W2
002110  784112     MOV.B [W2], W2
002112  694000     XOR.B W2, W0, W0
002114  FB8000     ZE W0, W0
002116  E90000     DEC W0, W0
002118  DE004F     LSR W0, #15, W0
00211A  B7EADC     MOV.B WREG, 0xADC
140:               	adcData.chan = appData.receive_packet[13] == '1' ? 1 : 0; // update adc channel 
141:               	adcData.chan += appData.receive_packet[15] == '1' ? 2 : 0;
00211C  EB4100     CLR.B W2
00211E  320001     BRA Z, 0x2122
002120  B3C022     MOV.B #0x2, W2
002122  414101     ADD.B W2, W1, W2
002124  784082     MOV.B W2, W1
002126  20AFC0     MOV #0xAFC, W0
002128  784801     MOV.B W1, [W0]
142:               }
00212A  060000     RETURN
---  /sdd/work/fac_relay_clone/comparator.c  ------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2015 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        comparator.c
29:                 * Date:        September 18, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Comparator functions
33:                 *
34:                 */
35:                
36:                #include <xc.h>
37:                #include "app.h"
38:                #include "config.h"
39:                #include "timers.h"
40:                
41:                //State machine for comparator
42:                //Returns next timer value
43:                
44:                uint16_t CMP_Tasks(void)
45:                {
46:                	return 1000;
47:                }
0025C0  203E80     MOV #0x3E8, W0
0025C2  060000     RETURN
48:                
49:                //Initialize CMP2 for low input voltage detection
50:                
51:                void CMP_Init(void)
52:                {
53:                
54:                }
0025C4  060000     RETURN
55:                
56:                //Comparator interrupt
57:                
58:                void _ISR_NO_AUTO_PSV _CompInterrupt(void)
59:                {
60:                	IFS1bits.CMIF = 0; //clear flags
0025C6  A94086     BCLR IFS1, #2
61:                
62:                }
0025C8  064000     RETFIE
---  /sdd/work/fac_relay_clone/bluetooth.c  -------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        bluetooth.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 * Functions to communicate with a RN4020 Bluetooth LE module over a UART
33:                 * 
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdio.h>
39:                #include <stdbool.h>
40:                #include "bluetooth.h"
41:                #include "config.h"
42:                #include "app.h"
43:                #include "uart.h"
44:                #include "timers.h"
45:                
46:                uint16_t BT_CheckFwVer(void);
47:                
48:                //**********************************************************************************************************************
49:                // Receive a message over the Bluetooth link
50:                
51:                bool BT_ReceivePacket(char * Message)
52:                {
00168C  BE9F88     MOV.D W8, [W15++]
00168E  780400     MOV W0, W8
53:                	static enum BluetoothDecodeState btDecodeState = WaitForCR; //Static so maintains state on reentry   //Byte read from the UART buffer
54:                	static uint16_t i = 0;
55:                
56:                	if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
001690  070563     RCALL UART_IsNewRxData
001692  784080     MOV.B W0, W1
001696  E00401     CP0.B W1
001698  320026     BRA Z, 0x16E6
57:                	{
58:                		Message[i++] = UART_ReadRxBuffer();
00169A  805D19     MOV i, W9
00169C  070566     RCALL UART_ReadRxBuffer
00169E  7CF400     MOV.B W0, [W8+W9]
0016A0  E80489     INC W9, W9
0016A2  885D19     MOV W9, i
59:                		if (i == BT_RX_PKT_SZ) {
0016A4  200640     MOV #0x64, W0
0016A6  548F80     SUB W9, W0, [W15]
0016A8  3A0001     BRA NZ, 0x16AC
60:                			i = 0;
0016AA  EF2BA2     CLR i
61:                		}
62:                
63:                		switch (btDecodeState) {
0016AC  805D20     MOV btDecodeState, W0
0016AE  E00000     CP0 W0
0016B0  320003     BRA Z, 0x16B8
0016B2  500FE1     SUB W0, #0x1, [W15]
0016B4  3A0016     BRA NZ, 0x16E2
0016B6  37000A     BRA 0x16CC
64:                		case WaitForCR:
65:                			if (Message[i - 1] == '\r') { //See if this is the CR
0016B8  805D10     MOV i, W0
0016BA  440400     ADD W8, W0, W8
0016BC  97F8F8     MOV.B [W8-1], W1
0016C0  50CFED     SUB.B W1, #0xD, [W15]
0016C2  3A0011     BRA NZ, 0x16E6
66:                				btDecodeState = WaitForLF; //Is CR so wait for LF
0016C4  200010     MOV #0x1, W0
0016C6  885D20     MOV W0, btDecodeState
67:                			}
68:                			break;
69:                
70:                		case WaitForLF:
71:                			btDecodeState = WaitForCR; //Will be looking for a new packet next
0016CC  EF2BA4     CLR btDecodeState
72:                			if (Message[i - 1] == '\n') //See if this is the LF
0016CE  805D11     MOV i, W1
0016D0  440001     ADD W8, W1, W0
0016D2  97F970     MOV.B [W0-1], W2
0016D6  514FEA     SUB.B W2, #0xA, [W15]
0016D8  3A0006     BRA NZ, 0x16E6
73:                			{
74:                				Message[i] = NULL; //Got a complete message!
0016DA  78F400     MOV.B W0, [W8+W1]
75:                				i = 0;
0016DC  EF2BA2     CLR i
76:                				return true;
0016DE  B3C010     MOV.B #0x1, W0
0016E0  370002     BRA 0x16E6
77:                			}
78:                			break;
79:                
80:                		default: //Invalid state so start looking for a new start of frame
81:                			btDecodeState = WaitForCR;
0016E2  EF2BA4     CLR btDecodeState
82:                		}
83:                	}
84:                	return false;
001694  EB4000     CLR.B W0
0016BE  EB4000     CLR.B W0
0016C8  EB4000     CLR.B W0
0016CA  37000D     BRA 0x16E6
0016D4  EB4000     CLR.B W0
0016E4  EB4000     CLR.B W0
85:                }
0016E6  BE044F     MOV.D [--W15], W8
0016E8  060000     RETURN
86:                
87:                //**********************************************************************************************************************
88:                // Send a command to the RN4020 module
89:                //Return true for success, false for busy
90:                
91:                bool BT_SendCommand(const char *data, bool wait)
001724  200FF9     MOV #0xFF, W9
001726  448488     ADD W9, W8, W9
001728  37FFEF     BRA 0x1708
92:                {
0016EA  BE9F88     MOV.D W8, [W15++]
0016EC  780400     MOV W0, W8
0016EE  784481     MOV.B W1, W9
93:                	uint16_t i;
94:                	//Only transmit a message if TX timer expired, or wait flag is set to false
95:                	//We limit transmission frequency to avoid overwhelming the BTLE link
96:                	if (TimerDone(TMR_BT_TX) || wait == false) {
0016F0  B3C090     MOV.B #0x9, W0
0016F2  07071A     RCALL TimerDone
0016F4  E00400     CP0.B W0
0016F6  320004     BRA Z, 0x1700
001702  E00409     CP0.B W9
001704  32FFF9     BRA Z, 0x16F8
001706  37000B     BRA 0x171E
97:                		for (i = 0; i < SIZE_TxBuffer; i++) {
001710  540F89     SUB W8, W9, [W15]
001712  3AFFFA     BRA NZ, 0x1708
98:                			if (*data != '\0') //Keep loading bytes until end of string
0016F8  784018     MOV.B [W8], W0
0016FA  E00400     CP0.B W0
0016FC  3A0012     BRA NZ, 0x1722
0016FE  37000A     BRA 0x1714
001708  784058     MOV.B [++W8], W0
00170A  E00400     CP0.B W0
00170C  320003     BRA Z, 0x1714
99:                				UART_WriteTxBuffer(*data++); //Load byte into the transmit buffer
00170E  07053E     RCALL UART_WriteTxBuffer
001722  070534     RCALL UART_WriteTxBuffer
100:               			else
101:               				break;
102:               		}
103:               		UART_TxStart(); //Start transmitting the bytes
001714  07051F     RCALL UART_TxStart
104:               		StartTimer(TMR_BT_TX, BT_TX_MS); //Restart transmit timer
001716  200961     MOV #0x96, W1
001718  B3C090     MOV.B #0x9, W0
00171A  070700     RCALL StartTimer
105:               		return true;
00171C  B3C010     MOV.B #0x1, W0
106:               	}
107:               	return false;
001700  EB4000     CLR.B W0
108:               }
00171E  BE044F     MOV.D [--W15], W8
001720  060000     RETURN
001722  070534     RCALL UART_WriteTxBuffer
001724  200FF9     MOV #0xFF, W9
001726  448488     ADD W9, W8, W9
001728  37FFEF     BRA 0x1708
109:               
110:               //**********************************************************************************************************************
111:               // Send a byte to the RN4020 module
112:               
113:               void BT_SendByte(char data)
114:               {
115:               	UART_WriteTxBuffer(data); //Load byte into the transmit buffer
00172A  070530     RCALL UART_WriteTxBuffer
116:               	UART_TxStart(); //Start transmitting the byte
00172C  070513     RCALL UART_TxStart
117:               }
00172E  060000     RETURN
118:               
119:               //**********************************************************************************************************************
120:               // Get a response from the RN4020 module
121:               
122:               bool BT_GetResponse(char *data)
123:               {
001730  BE9F88     MOV.D W8, [W15++]
001732  BE9F8A     MOV.D W10, [W15++]
001734  780480     MOV W0, W9
124:               	uint16_t byteCount = 0;
00173C  EB0400     CLR W8
125:               	char newByte;
126:               
127:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
001736  202581     MOV #0x258, W1
001738  B3C020     MOV.B #0x2, W0
00173A  0706F0     RCALL StartTimer
128:               
129:               	while (byteCount < BT_RX_PKT_SZ) //Don't accept more than the buffer size
001740  20063B     MOV #0x63, W11
00175C  540F8B     SUB W8, W11, [W15]
00175E  36FFF1     BRA LEU, 0x1742
001760  370003     BRA 0x1768
130:               	{
131:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
001742  07050A     RCALL UART_IsNewRxData
001744  E00400     CP0.B W0
001746  320006     BRA Z, 0x1754
132:               		{
133:               			newByte = UART_ReadRxBuffer(); //Read the data byte for processing
001748  070510     RCALL UART_ReadRxBuffer
134:               			*data++ = newByte; //Add it to the buffer
00174A  784C80     MOV.B W0, [W9]
001750  E80489     INC W9, W9
135:               			byteCount++; //Keep track of the number of bytes received
001752  E80408     INC W8, W8
136:               			if (newByte == '\n') //Check if got linefeed
00174C  504FEA     SUB.B W0, #0xA, [W15]
00174E  320009     BRA Z, 0x1762
137:               				return true; //If linefeed then return success
001762  B3C010     MOV.B #0x1, W0
001764  370001     BRA 0x1768
138:               		}
139:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
00173E  B3C02A     MOV.B #0x2, W10
001754  78400A     MOV.B W10, W0
001756  0706E8     RCALL TimerDone
001758  E00400     CP0.B W0
00175A  3A0005     BRA NZ, 0x1766
140:               			return false; //If timed out then return failure
001766  EB4000     CLR.B W0
141:               	}
142:               	return false;
143:               }
001768  BE054F     MOV.D [--W15], W10
00176A  BE044F     MOV.D [--W15], W8
00176C  060000     RETURN
144:               
145:               //**********************************************************************************************************************
146:               // Compare the buffer with the response with one of the expected responses
147:               
148:               bool BT_CompareResponse(const char *data1, const char *data2)
00177E  B00311     ADD #0x31, W1
149:               {
150:               	uint16_t i;
151:               
152:               	for (i = 0; i < 50; i++) //Compare up to 50 bytes
00178A  510F81     SUB W2, W1, [W15]
00178C  320006     BRA Z, 0x179A
153:               	{
154:               		if (*data1 == '\0') //See if reached end of string with no bytes different
00176E  784190     MOV.B [W0], W3
001772  E00403     CP0.B W3
001774  320013     BRA Z, 0x179C
001780  7841D0     MOV.B [++W0], W3
001782  E00403     CP0.B W3
001784  320006     BRA Z, 0x1792
155:               			return true; //No bytes were different so return success
001770  B3C012     MOV.B #0x1, W2
001792  B3C012     MOV.B #0x1, W2
001794  370003     BRA 0x179C
156:               		else if (*data1++ != *data2++) //else see if the bytes are different
001778  51CF91     SUB.B W3, [W1], [W15]
00177A  3A0010     BRA NZ, 0x179C
00177C  E80101     INC W1, W2
001786  51CF92     SUB.B W3, [W2], [W15]
001788  3A0006     BRA NZ, 0x1796
00178E  E80102     INC W2, W2
001790  37FFF7     BRA 0x1780
157:               			return false; //Bytes differ so return failure
001776  EB4100     CLR.B W2
001796  EB4100     CLR.B W2
001798  370001     BRA 0x179C
158:               	}
159:               	return false; //Did not reach end of string so return failure
00179A  EB4100     CLR.B W2
160:               }
00179C  784002     MOV.B W2, W0
00179E  060000     RETURN
161:               
162:               //**********************************************************************************************************************
163:               // Get a response from the RN4020 module and compare with an expected response
164:               
165:               bool BT_CheckResponse(const char *data)
166:               {
0017A0  B0034F     ADD #0x34, W15
0017A2  BE9F88     MOV.D W8, [W15++]
0017A4  BE9F8A     MOV.D W10, [W15++]
0017A6  781F8E     MOV W14, [W15++]
0017A8  780580     MOV W0, W11
167:               	uint16_t i, ByteCount = 0;
0017B4  EB0400     CLR W8
168:               	char NewByte, Buffer[50], *BufPtr;
169:               
170:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
0017AA  202581     MOV #0x258, W1
0017AC  B3C020     MOV.B #0x2, W0
0017AE  0706B6     RCALL StartTimer
171:               
172:               	BufPtr = Buffer;
0017B0  2FFC4E     MOV #0xFFC4, W14
0017B2  47070F     ADD W14, W15, W14
173:               	while (ByteCount < 50) //Don't accept more than the buffer size
0017B8  20031A     MOV #0x31, W10
0017D4  540F8A     SUB W8, W10, [W15]
0017D6  36FFF1     BRA LEU, 0x17BA
174:               	{
175:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
0017BA  0704CE     RCALL UART_IsNewRxData
0017BC  E00400     CP0.B W0
0017BE  320006     BRA Z, 0x17CC
176:               		{
177:               			NewByte = (char) UART_ReadRxBuffer(); //Read the data byte for processing
0017C0  0704D4     RCALL UART_ReadRxBuffer
178:               			*BufPtr++ = NewByte; //Add it to the buffer
0017C2  784F00     MOV.B W0, [W14]
0017CA  E8070E     INC W14, W14
179:               			ByteCount++;
0017C4  E80408     INC W8, W8
180:               			if (NewByte == '\n') //Check if got linefeed
0017C6  504FEA     SUB.B W0, #0xA, [W15]
0017C8  320007     BRA Z, 0x17D8
181:               				break; //If linefeed then we have what we want
182:               		}
183:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
0017B6  B3C029     MOV.B #0x2, W9
0017CC  784009     MOV.B W9, W0
0017CE  0706AC     RCALL TimerDone
0017D0  E00400     CP0.B W0
0017D2  3A001A     BRA NZ, 0x1808
184:               			return false; //If timed out then return failure
001808  EB4000     CLR.B W0
00180A  370003     BRA 0x1812
185:               	}
186:               
187:               	BufPtr = Buffer;
188:               	for (i = 0; i < ByteCount; i++) //Compare all bytes received
0017DA  E00008     CP0 W8
0017DC  32001A     BRA Z, 0x1812
0017F0  EB0000     CLR W0
0017F2  370005     BRA 0x17FE
0017FE  E80000     INC W0, W0
001800  540F80     SUB W8, W0, [W15]
001802  3EFFF8     BRA GTU, 0x17F4
189:               	{
190:               		if (*data == '\0') //See if reached end of string with no bytes different
0017DE  78409B     MOV.B [W11], W1
0017E0  E00401     CP0.B W1
0017E2  320017     BRA Z, 0x1812
0017F4  7840DB     MOV.B [++W11], W1
0017F6  E00401     CP0.B W1
0017F8  320009     BRA Z, 0x180C
191:               			return true; //No bytes were different so return success
00180C  B3C010     MOV.B #0x1, W0
00180E  370001     BRA 0x1812
192:               		else if (*data++ != *BufPtr++) //else see if the bytes are different
0017E6  97C14F     MOV.B [W15-60], W2
0017E8  50CF82     SUB.B W1, W2, [W15]
0017EA  3A0013     BRA NZ, 0x1812
0017EC  2FFC4E     MOV #0xFFC4, W14
0017EE  47070F     ADD W14, W15, W14
0017FA  50CFDE     SUB.B W1, [++W14], [W15]
0017FC  3A0009     BRA NZ, 0x1810
193:               			return false; //Bytes differ so return failure
0017E4  EB4000     CLR.B W0
001810  EB4000     CLR.B W0
194:               	}
195:               	return true; //All bytes matched so return success
0017D8  B3C010     MOV.B #0x1, W0
001804  B3C010     MOV.B #0x1, W0
001806  370005     BRA 0x1812
196:               }
001812  78074F     MOV [--W15], W14
001814  BE054F     MOV.D [--W15], W10
001816  BE044F     MOV.D [--W15], W8
001818  B1034F     SUB #0x34, W15
00181A  060000     RETURN
197:               
198:               //**********************************************************************************************************************
199:               // Get a response from the RN4020 module and compare with an expected response
200:               //   All incoming bytes in the position of the wildcard character are ignored
201:               //   Use this to ignore text that changes, like MAC addresses.
202:               
203:               bool BT_CheckResponseWithWildcard(const char *data, char Wildcard)
001864  E8060C     INC W12, W12
204:               {
00181C  B0034F     ADD #0x34, W15
00181E  BE9F88     MOV.D W8, [W15++]
001820  BE9F8A     MOV.D W10, [W15++]
001822  781F8C     MOV W12, [W15++]
001824  781F8E     MOV W14, [W15++]
001826  780600     MOV W0, W12
001828  784581     MOV.B W1, W11
205:               	uint16_t i, ByteCount = 0;
001834  EB0400     CLR W8
206:               	char NewByte, Buffer[50], *BufPtr;
207:               
208:               	StartTimer(TMR_RN_COMMS, 600); //Start 600ms timeout for routine
00182A  202581     MOV #0x258, W1
00182C  B3C020     MOV.B #0x2, W0
00182E  070676     RCALL StartTimer
209:               
210:               	BufPtr = Buffer;
001830  2FFC2E     MOV #0xFFC2, W14
001832  47070F     ADD W14, W15, W14
211:               	while (ByteCount < 50) //Don't accept more than the buffer size
001838  20031A     MOV #0x31, W10
001854  540F8A     SUB W8, W10, [W15]
001856  36FFF1     BRA LEU, 0x183A
212:               	{
213:               		if (UART_IsNewRxData()) //Check if new data byte from BT module and return if nothing new
00183A  07048E     RCALL UART_IsNewRxData
00183C  E00400     CP0.B W0
00183E  320006     BRA Z, 0x184C
214:               		{
215:               			NewByte = UART_ReadRxBuffer(); //Read the data byte for processing
001840  070494     RCALL UART_ReadRxBuffer
216:               			*BufPtr++ = NewByte; //Add it to the buffer
001842  784F00     MOV.B W0, [W14]
00184A  E8070E     INC W14, W14
217:               			ByteCount++;
001844  E80408     INC W8, W8
218:               			if (NewByte == '\n') //Check if got linefeed
001846  504FEA     SUB.B W0, #0xA, [W15]
001848  320007     BRA Z, 0x1858
219:               				break; //If linefeed then we have what we want
220:               		}
221:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001836  B3C029     MOV.B #0x2, W9
00184C  784009     MOV.B W9, W0
00184E  07066C     RCALL TimerDone
001850  E00400     CP0.B W0
001852  3A001E     BRA NZ, 0x1890
222:               			return false; //If timed out then return failure
001890  EB4000     CLR.B W0
001892  370003     BRA 0x189A
223:               	}
224:               
225:               	BufPtr = Buffer;
226:               	for (i = 0; i < ByteCount; i++) //Compare all bytes received
00185A  E00008     CP0 W8
00185C  32001E     BRA Z, 0x189A
001866  EB0000     CLR W0
001868  370004     BRA 0x1872
001886  E80000     INC W0, W0
001888  540F80     SUB W8, W0, [W15]
00188A  3EFFEF     BRA GTU, 0x186A
227:               	{
228:               		if (*data == '\0') //See if reached end of string with no bytes different
00185E  78409C     MOV.B [W12], W1
001860  E00401     CP0.B W1
001862  32001B     BRA Z, 0x189A
00186A  784091     MOV.B [W1], W1
00186C  E8060C     INC W12, W12
00186E  E00401     CP0.B W1
001870  320011     BRA Z, 0x1894
229:               			return true; //No bytes were different so return success
001894  B3C010     MOV.B #0x1, W0
001896  370001     BRA 0x189A
230:               		else if (*data == Wildcard) //else see if expected response byte is a wildcard
001872  50CF8B     SUB.B W1, W11, [W15]
001874  3A0002     BRA NZ, 0x187A
001876  78008C     MOV W12, W1
001878  370006     BRA 0x1886
231:               		{
232:               			data++; //Increment past wildcard byte
233:               			BufPtr++; //Increment to ignore byte correspinding to wildcard
234:               		} else if (*data++ != *BufPtr++) //else see if the bytes are different
00187A  2FFC23     MOV #0xFFC2, W3
00187C  41818F     ADD W3, W15, W3
00187E  784163     MOV.B [W3+W0], W2
001880  50CF82     SUB.B W1, W2, [W15]
001882  3A000A     BRA NZ, 0x1898
001884  78008C     MOV W12, W1
235:               			return false; //Bytes differ so return failure
001898  EB4000     CLR.B W0
236:               	}
237:               	return true; //All bytes matched or were ignored so return success
001858  B3C010     MOV.B #0x1, W0
00188C  B3C010     MOV.B #0x1, W0
00188E  370005     BRA 0x189A
238:               }
00189A  78074F     MOV [--W15], W14
00189C  78064F     MOV [--W15], W12
00189E  BE054F     MOV.D [--W15], W10
0018A0  BE044F     MOV.D [--W15], W8
0018A2  B1034F     SUB #0x34, W15
0018A4  060000     RETURN
239:               
240:               //**********************************************************************************************************************
241:               // Set up the RN4020 module
242:               
243:               bool BT_SetupModule(void)
244:               {
001B1A  FA001C     LNK #0x1C
245:               	uint16_t version_code;
246:               
247:               	//Check RN4020 module's firmware version for version specific setups
248:               	version_code = BT_CheckFwVer();
001B1C  07FFA2     RCALL BT_CheckFwVer
249:               
250:               	BT_SendCommand("sf,2\r", false); //Get RN4020 module feature settings
001B1E  EB4080     CLR.B W1
001B20  294980     MOV #0x9498, W0
001B22  07FDE3     RCALL BT_SendCommand
251:               	if (!BT_CheckResponse(AOK)) {
001B24  294320     MOV #0x9432, W0
001B26  07FE3C     RCALL BT_CheckResponse
001B28  784080     MOV.B W0, W1
001B2C  E00401     CP0.B W1
001B2E  32008A     BRA Z, 0x1C44
252:               		return false;
001B2A  EB4000     CLR.B W0
253:               	}
254:               
255:               	//Send "GR" to get feature settings
256:               	BT_SendCommand("gr\r", false); //Get RN4020 module feature settings
001B30  784080     MOV.B W0, W1
001B32  2949E0     MOV #0x949E, W0
001B34  07FDDA     RCALL BT_SendCommand
257:               	if (!BT_CheckResponse("22000000\r\n")) //Check if features are set for auto advertize and flow control
001B36  294A20     MOV #0x94A2, W0
001B38  07FE33     RCALL BT_CheckResponse
001B3A  E00400     CP0.B W0
001B3C  3A0009     BRA NZ, 0x1B50
258:               	{ //auto enable MLDP, suppress messages during MLDP
259:               		BT_SendCommand("sr,22000000\r", false); //Features not correct so set features
001B3E  EB4080     CLR.B W1
001B40  294AD0     MOV #0x94AD, W0
001B42  07FDD3     RCALL BT_SendCommand
260:               		if (!BT_CheckResponse(AOK)) {
001B44  294320     MOV #0x9432, W0
001B46  07FE2C     RCALL BT_CheckResponse
001B48  784080     MOV.B W0, W1
001B4C  E00401     CP0.B W1
001B4E  32007A     BRA Z, 0x1C44
261:               			return false;
001B4A  EB4000     CLR.B W0
262:               		}
263:               	}
264:               
265:               	char macAddr[16];
266:               	BT_SendCommand("gds\r", false); // Get mac address
001B50  EB4080     CLR.B W1
001B52  294BA0     MOV #0x94BA, W0
001B54  07FDCA     RCALL BT_SendCommand
267:               	while (!BT_ReceivePacket(macAddr));
001B56  78000E     MOV W14, W0
001B58  07FD99     RCALL BT_ReceivePacket
001B5A  E00400     CP0.B W0
001B5C  32FFFC     BRA Z, 0x1B56
268:               
269:               	char message[12];
270:               	macAddr[12] = '\0';
001B5E  EB4000     CLR.B W0
001B60  984F40     MOV.B W0, [W14+12]
271:               	sprintf(message, "sn,%s_BT\r", &macAddr[8]);
001B62  471FE8     ADD W14, #0x8, [W15++]
001B64  294BF0     MOV #0x94BF, W0
001B66  781F80     MOV W0, [W15++]
001B68  470070     ADD W14, #0x10, W0
001B6A  07F5FD     RCALL 0x766
272:               
273:               	BT_SendCommand(message, false); //Set advertise name
001B6C  EB4080     CLR.B W1
001B6E  470070     ADD W14, #0x10, W0
001B70  07FDBC     RCALL BT_SendCommand
274:               	if (!BT_CheckResponse(AOK)) {
001B72  294320     MOV #0x9432, W0
001B74  07FE15     RCALL BT_CheckResponse
001B76  784080     MOV.B W0, W1
001B78  5787E4     SUB W15, #0x4, W15
001B7C  E00401     CP0.B W1
001B7E  320062     BRA Z, 0x1C44
275:               		return false;
001B7A  EB4000     CLR.B W0
276:               	}
277:               
278:               	BT_SendCommand("gs\r", false);
001B80  784080     MOV.B W0, W1
001B82  294C90     MOV #0x94C9, W0
001B84  07FDB2     RCALL BT_SendCommand
279:               	if (!BT_CheckResponse("80000001\r\n")) {
001B86  294CD0     MOV #0x94CD, W0
001B88  07FE0B     RCALL BT_CheckResponse
001B8A  E00400     CP0.B W0
001B8C  3A0009     BRA NZ, 0x1BA0
280:               		//Send "SS" to set user defined private profiles
281:               		BT_SendCommand("ss,80000001\r", false);
001B8E  EB4080     CLR.B W1
001B90  294D80     MOV #0x94D8, W0
001B92  07FDAB     RCALL BT_SendCommand
282:               		if (!BT_CheckResponse(AOK)) {
001B94  294320     MOV #0x9432, W0
001B96  07FE04     RCALL BT_CheckResponse
001B98  784080     MOV.B W0, W1
001B9C  E00401     CP0.B W1
001B9E  320052     BRA Z, 0x1C44
283:               			return false;
001B9A  EB4000     CLR.B W0
284:               		}
285:               	}
286:               
287:               	// Clear all settings of private service and private characteristic
288:               	BT_SendCommand("pz\r", false);
001BA0  EB4080     CLR.B W1
001BA2  294E50     MOV #0x94E5, W0
001BA4  07FDA2     RCALL BT_SendCommand
289:               	if (!BT_CheckResponse(AOK)) {
001BA6  294320     MOV #0x9432, W0
001BA8  07FDFB     RCALL BT_CheckResponse
001BAA  784080     MOV.B W0, W1
001BAE  E00401     CP0.B W1
001BB0  320049     BRA Z, 0x1C44
290:               		return false;
001BAC  EB4000     CLR.B W0
291:               	}
292:               
293:               	//Send "ps" to set user defined service UUID
294:               	BT_SendCommand("ps,"PRIVATE_SERVICE",\r", false);
001BB2  784080     MOV.B W0, W1
001BB4  294E90     MOV #0x94E9, W0
001BB6  07FD99     RCALL BT_SendCommand
295:               	if (!BT_CheckResponse(AOK)) {
001BB8  294320     MOV #0x9432, W0
001BBA  07FDF2     RCALL BT_CheckResponse
001BBC  784080     MOV.B W0, W1
001BC0  E00401     CP0.B W1
001BC2  320040     BRA Z, 0x1C44
296:               		return false;
001BBE  EB4000     CLR.B W0
297:               	}
298:               
299:               	// Custom button characteristic with generated UUID
300:               	BT_SendCommand("pc,"PRIVATE_CHAR_SWITCHES",22,02\r", false); //Indicate, Read
001BC4  784080     MOV.B W0, W1
001BC6  2950F0     MOV #0x950F, W0
001BC8  07FD90     RCALL BT_SendCommand
301:               	if (!BT_CheckResponse(AOK)) {
001BCA  294320     MOV #0x9432, W0
001BCC  07FDE9     RCALL BT_CheckResponse
001BCE  784080     MOV.B W0, W1
001BD2  E00401     CP0.B W1
001BD4  320037     BRA Z, 0x1C44
302:               		return false;
001BD0  EB4000     CLR.B W0
303:               	}
304:               
305:               	// Custom potentiometer characteristic with generated UUID
306:               	BT_SendCommand("pc,"PRIVATE_CHAR_POTENTIOMETER",22,02\r", false); //Indicate, Read
001BD6  784080     MOV.B W0, W1
001BD8  2953A0     MOV #0x953A, W0
001BDA  07FD87     RCALL BT_SendCommand
307:               	if (!BT_CheckResponse(AOK)) {
001BDC  294320     MOV #0x9432, W0
001BDE  07FDE0     RCALL BT_CheckResponse
001BE0  784080     MOV.B W0, W1
001BE4  E00401     CP0.B W1
001BE6  32002E     BRA Z, 0x1C44
308:               		return false;
001BE2  EB4000     CLR.B W0
309:               	}
310:               
311:               	// Custom LED characteristic with generated UUID
312:               	BT_SendCommand("pc,"PRIVATE_CHAR_LEDS",0A,04\r", false); //Write w/ACK, Read
001BE8  784080     MOV.B W0, W1
001BEA  295650     MOV #0x9565, W0
001BEC  07FD7E     RCALL BT_SendCommand
313:               	if (!BT_CheckResponse(AOK)) {
001BEE  294320     MOV #0x9432, W0
001BF0  07FDD7     RCALL BT_CheckResponse
001BF2  784080     MOV.B W0, W1
001BF6  E00401     CP0.B W1
001BF8  320025     BRA Z, 0x1C44
314:               		return false;
001BF4  EB4000     CLR.B W0
315:               	}
316:               
317:               	// Custom RELAY characteristic with generated UUID
318:               	BT_SendCommand("pc,"PRIVATE_CHAR_RELAYS",0A,04\r", false); //Write w/ACK, Read
001BFA  784080     MOV.B W0, W1
001BFC  295900     MOV #0x9590, W0
001BFE  07FD75     RCALL BT_SendCommand
319:               	if (!BT_CheckResponse(AOK)) {
001C00  294320     MOV #0x9432, W0
001C02  07FDCE     RCALL BT_CheckResponse
001C04  784080     MOV.B W0, W1
001C08  E00401     CP0.B W1
001C0A  32001C     BRA Z, 0x1C44
320:               		return false;
001C06  EB4000     CLR.B W0
321:               	}
322:               
323:               	// Custom analog input characteristic with generated UUID //Write w/ACK, Read
324:               	BT_SendCommand("pc,"PRIVATE_CHAR_ADC_CHAN",0A,02\r", false);
001C0C  784080     MOV.B W0, W1
001C0E  295BB0     MOV #0x95BB, W0
001C10  07FD6C     RCALL BT_SendCommand
325:               	if (!BT_CheckResponse(AOK)) {
001C12  294320     MOV #0x9432, W0
001C14  07FDC5     RCALL BT_CheckResponse
001C16  784080     MOV.B W0, W1
001C1A  E00401     CP0.B W1
001C1C  320013     BRA Z, 0x1C44
326:               		return false;
001C18  EB4000     CLR.B W0
327:               	}
328:               
329:               	// Custom analog input characteristic with generated UUID //Write w/ACK, Read
330:               	BT_SendCommand("pc,"PRIVATE_CHAR_PIC_SLAVE",0A,0F\r", false);
001C1E  784080     MOV.B W0, W1
001C20  295E60     MOV #0x95E6, W0
001C22  07FD63     RCALL BT_SendCommand
331:               	if (!BT_CheckResponse(AOK)) {
001C24  294320     MOV #0x9432, W0
001C26  07FDBC     RCALL BT_CheckResponse
001C28  784080     MOV.B W0, W1
001C2C  E00401     CP0.B W1
001C2E  32000A     BRA Z, 0x1C44
332:               		return false;
001C2A  EB4000     CLR.B W0
333:               	}
334:               
335:               	BT_SendCommand("wc\r", false); //Command to clear script, just in case there is a script
001C30  784080     MOV.B W0, W1
001C32  296110     MOV #0x9611, W0
001C34  07FD5A     RCALL BT_SendCommand
336:               	if (!BT_CheckResponse(AOK)) {
001C36  294320     MOV #0x9432, W0
001C38  07FDB3     RCALL BT_CheckResponse
001C3A  784080     MOV.B W0, W1
001C3E  E00401     CP0.B W1
001C40  320001     BRA Z, 0x1C44
337:               		return false;
001C3C  EB4000     CLR.B W0
338:               	}
339:               
340:               	//Send "R,1" to save changes and reboot
341:               	return BT_RebootEnFlow();
001C42  07FE31     RCALL BT_RebootEnFlow
342:               }
001C44  FA8000     ULNK
001C46  060000     RETURN
343:               
344:               //**********************************************************************************************************************
345:               // Reboot the module and enable flow control on PIC UART
346:               
347:               bool BT_RebootEnFlow(void)
348:               {
0018A6  BE9F88     MOV.D W8, [W15++]
0018A8  781F8A     MOV W10, [W15++]
349:               	//Send "R,1" to save changes and reboot
350:               	BT_SendCommand("r,1\r", false); //Force reboot
0018AA  EB4080     CLR.B W1
0018AC  2941E0     MOV #0x941E, W0
0018AE  07FF1D     RCALL BT_SendCommand
351:               	if (!BT_CheckResponse("Reboot\r\n")) {
0018B0  294230     MOV #0x9423, W0
0018B2  07FF76     RCALL BT_CheckResponse
0018B4  784080     MOV.B W0, W1
0018B8  E00401     CP0.B W1
0018BA  3200D0     BRA Z, 0x1A5C
352:               		return false;
0018B6  EB4000     CLR.B W0
353:               	}
354:               
355:               	//Disable UART while TX line from RN is low during reset and bootup
356:               	StartTimer(TMR_RN_COMMS, 1000);
0018BC  203E81     MOV #0x3E8, W1
0018BE  B3C020     MOV.B #0x2, W0
0018C0  07062D     RCALL StartTimer
357:               	U1MODE &= 0x7FFF;
0018C2  A9E221     BCLR 0x221, #7
358:               	while (U1RX_PORT) {
0018C6  370004     BRA 0x18D0
0018D0  AB42CA     BTST PORTB, #2
0018D2  3AFFFA     BRA NZ, 0x18C8
359:               		if (TimerDone(TMR_RN_COMMS)) {
0018C4  B3C028     MOV.B #0x2, W8
0018C8  784008     MOV.B W8, W0
0018CA  07062E     RCALL TimerDone
0018CC  E00400     CP0.B W0
0018CE  3A0002     BRA NZ, 0x18D4
360:               			break;
361:               		}
362:               	}
363:               	StartTimer(TMR_RN_COMMS, 4000);
0018D4  20FA01     MOV #0xFA0, W1
0018D6  B3C020     MOV.B #0x2, W0
0018D8  070621     RCALL StartTimer
364:               	while (!U1RX_PORT) {
0018DC  370004     BRA 0x18E6
0018E6  AB42CA     BTST PORTB, #2
0018E8  32FFFA     BRA Z, 0x18DE
365:               		if (TimerDone(TMR_RN_COMMS)) {
0018DA  B3C028     MOV.B #0x2, W8
0018DE  784008     MOV.B W8, W0
0018E0  070623     RCALL TimerDone
0018E2  E00400     CP0.B W0
0018E4  3A0002     BRA NZ, 0x18EA
366:               			break;
367:               		}
368:               	}
369:               	UART_RX_IF = 0; //Clear UART Receive interrupt flag
0018EA  A96085     BCLR 0x85, #3
370:               	U1MODE |= 0x8200; //Enable UART, use RTC/CTS flow control
0018EC  801101     MOV U1MODE, W1
0018EE  282000     MOV #0x8200, W0
0018F0  700001     IOR W0, W1, W0
0018F2  881100     MOV W0, U1MODE
371:               	U1STA |= 0x0400; //Enable transmit
0018F4  A84223     BSET 0x223, #2
372:               
373:               	//Clear out NULL char(s) and other garbage if present after reboot, wait for first char of CMD\r\n response
374:               	StartTimer(TMR_RN_COMMS, 4000);
0018F6  20FA01     MOV #0xFA0, W1
0018F8  B3C020     MOV.B #0x2, W0
0018FA  070610     RCALL StartTimer
375:               	while (UART_ReadRxBuffer() != 'C') {
0018FC  B3C438     MOV.B #0x43, W8
001900  370007     BRA 0x1910
001910  07042C     RCALL UART_ReadRxBuffer
001912  504F88     SUB.B W0, W8, [W15]
001914  3AFFFA     BRA NZ, 0x190A
376:               		while (!UART_IsNewRxData()) {
00190A  070426     RCALL UART_IsNewRxData
00190C  E00400     CP0.B W0
00190E  32FFF9     BRA Z, 0x1902
377:               			if (TimerDone(TMR_RN_COMMS)) { //Check if timed out
0018FE  B3C029     MOV.B #0x2, W9
001902  784009     MOV.B W9, W0
001904  070611     RCALL TimerDone
001906  E00400     CP0.B W0
001908  3A00A4     BRA NZ, 0x1A52
378:               				return false; //If timed out then return failure
001A52  EB4000     CLR.B W0
001A54  370003     BRA 0x1A5C
379:               			}
380:               		}
381:               	}
382:               
383:               	/* Jumper on DFU OTA UPDATE */
384:               	BT_OTA_UPD_TRIS = 1; // set for jumper input
001916  A862C8     BSET TRISB, #3
385:               	CNPU1bits.CN7PUE = 1; // pullup for RB3
001918  A8E06E     BSET CNPU1, #7
386:               	WaitMs(2); // jumper pullup read delay, rise time is slow
00191A  200020     MOV #0x2, W0
00191C  07060E     RCALL WaitMs
387:               	if (BT_OTA_UPD == 0) {
00191E  AB62CA     BTST PORTB, #3
001920  3A0094     BRA NZ, 0x1A4A
388:               		BT_OTA_UPD_TRIS = 0; // set back to output
001922  A962C8     BCLR TRISB, #3
389:               		BT_WAKE_SW = 1;
001924  A862CD     BSET 0x2CD, #3
390:               		BT_WAKE_HW = 1;
001926  A842CD     BSET 0x2CD, #2
391:               		BT_CMD = 0;
001928  A902C4     BCLR LATA, #0
392:               
393:               		WaitMs(100);
00192A  200640     MOV #0x64, W0
00192C  070606     RCALL WaitMs
394:               		BT_SendCommand("SF,2\r", false); // perform complete factory reset
00192E  EB4080     CLR.B W1
001930  2942C0     MOV #0x942C, W0
001932  07FEDB     RCALL BT_SendCommand
395:               		WaitMs(100);
001934  200640     MOV #0x64, W0
001936  070601     RCALL WaitMs
396:               		BT_CheckResponse(AOK);
001938  294320     MOV #0x9432, W0
00193A  07FF32     RCALL BT_CheckResponse
397:               
398:               		BT_SendCommand("SF,2\r", false); // perform complete factory reset again
00193C  EB4080     CLR.B W1
00193E  2942C0     MOV #0x942C, W0
001940  07FED4     RCALL BT_SendCommand
399:               		WaitMs(100);
001942  200640     MOV #0x64, W0
001944  0705FA     RCALL WaitMs
400:               		if (!BT_CheckResponse(AOK)) {
001946  294320     MOV #0x9432, W0
001948  07FF2B     RCALL BT_CheckResponse
00194A  784080     MOV.B W0, W1
00194E  E00401     CP0.B W1
001950  320085     BRA Z, 0x1A5C
401:               			return false;
00194C  EB4000     CLR.B W0
402:               		}
403:               
404:               		BT_SendCommand("SDH,4.1\r", false); // defaults
001952  784080     MOV.B W0, W1
001954  294380     MOV #0x9438, W0
001956  07FEC9     RCALL BT_SendCommand
405:               		WaitMs(100);
001958  200640     MOV #0x64, W0
00195A  0705EF     RCALL WaitMs
406:               		if (!BT_CheckResponse(AOK)) {
00195C  294320     MOV #0x9432, W0
00195E  07FF20     RCALL BT_CheckResponse
001960  784080     MOV.B W0, W1
001964  E00401     CP0.B W1
001966  32007A     BRA Z, 0x1A5C
407:               			return false;
001962  EB4000     CLR.B W0
408:               		}
409:               		BT_SendCommand("SDM,RN4020\r", false); // defaults
001968  784080     MOV.B W0, W1
00196A  294410     MOV #0x9441, W0
00196C  07FEBE     RCALL BT_SendCommand
410:               		WaitMs(100);
00196E  200640     MOV #0x64, W0
001970  0705E4     RCALL WaitMs
411:               		if (!BT_CheckResponse(AOK)) {
001972  294320     MOV #0x9432, W0
001974  07FF15     RCALL BT_CheckResponse
001976  784080     MOV.B W0, W1
00197A  E00401     CP0.B W1
00197C  32006F     BRA Z, 0x1A5C
412:               			return false;
001978  EB4000     CLR.B W0
413:               		}
414:               
415:               		BT_SendCommand("SDN,Microchip\r", false); // defaults
00197E  784080     MOV.B W0, W1
001980  2944D0     MOV #0x944D, W0
001982  07FEB3     RCALL BT_SendCommand
416:               		WaitMs(100);
001984  200640     MOV #0x64, W0
001986  0705D9     RCALL WaitMs
417:               		if (!BT_CheckResponse(AOK)) {
001988  294320     MOV #0x9432, W0
00198A  07FF0A     RCALL BT_CheckResponse
00198C  784080     MOV.B W0, W1
001990  E00401     CP0.B W1
001992  320064     BRA Z, 0x1A5C
418:               			return false;
00198E  EB4000     CLR.B W0
419:               		}
420:               
421:               		BT_SendCommand("SP,7\r", false); // defaults
001994  784080     MOV.B W0, W1
001996  2945C0     MOV #0x945C, W0
001998  07FEA8     RCALL BT_SendCommand
422:               		WaitMs(100);
00199A  200640     MOV #0x64, W0
00199C  0705CE     RCALL WaitMs
423:               		if (!BT_CheckResponse(AOK)) {
00199E  294320     MOV #0x9432, W0
0019A0  07FEFF     RCALL BT_CheckResponse
0019A2  784080     MOV.B W0, W1
0019A6  E00401     CP0.B W1
0019A8  320059     BRA Z, 0x1A5C
424:               			return false;
0019A4  EB4000     CLR.B W0
425:               		}
426:               
427:               		BT_SendCommand("SS,C0000000\r", false); // add service
0019AA  784080     MOV.B W0, W1
0019AC  294620     MOV #0x9462, W0
0019AE  07FE9D     RCALL BT_SendCommand
428:               		WaitMs(100);
0019B0  200640     MOV #0x64, W0
0019B2  0705C3     RCALL WaitMs
429:               		if (!BT_CheckResponse(AOK)) {
0019B4  294320     MOV #0x9432, W0
0019B6  07FEF4     RCALL BT_CheckResponse
0019B8  784080     MOV.B W0, W1
0019BC  E00401     CP0.B W1
0019BE  32004E     BRA Z, 0x1A5C
430:               			return false;
0019BA  EB4000     CLR.B W0
431:               		}
432:               
433:               		BT_SendCommand("SR,32008000\r", false); // support MLDP, enable OTA (peripheral mode is enabled by default)
0019C0  784080     MOV.B W0, W1
0019C2  2946F0     MOV #0x946F, W0
0019C4  07FE92     RCALL BT_SendCommand
434:               		WaitMs(100);
0019C6  200640     MOV #0x64, W0
0019C8  0705B8     RCALL WaitMs
435:               		if (!BT_CheckResponse(AOK)) {
0019CA  294320     MOV #0x9432, W0
0019CC  07FEE9     RCALL BT_CheckResponse
0019CE  784080     MOV.B W0, W1
0019D2  E00401     CP0.B W1
0019D4  320043     BRA Z, 0x1A5C
436:               			return false;
0019D0  EB4000     CLR.B W0
437:               		}
438:               		BT_SendCommand("R,1\r", false); //Force reboot
0019D6  784080     MOV.B W0, W1
0019D8  2947C0     MOV #0x947C, W0
0019DA  07FE87     RCALL BT_SendCommand
439:               
440:               		//Wait for WS status high
441:               		StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
0019DC  20FA01     MOV #0xFA0, W1
0019DE  B3C020     MOV.B #0x2, W0
0019E0  07059D     RCALL StartTimer
442:               		while (BT_WS == 0) {
0019E4  370004     BRA 0x19EE
0019EE  AB42C2     BTST PORTA, #2
0019F0  32FFFA     BRA Z, 0x19E6
443:               			if (TimerDone(TMR_RN_COMMS)) //Check if timed out
0019E2  B3C028     MOV.B #0x2, W8
0019E6  784008     MOV.B W8, W0
0019E8  07059F     RCALL TimerDone
0019EA  E00400     CP0.B W0
0019EC  3A0034     BRA NZ, 0x1A56
444:               			{
445:               				return false;
001A56  EB4000     CLR.B W0
001A58  370001     BRA 0x1A5C
446:               			}
447:               		}
448:               
449:               		//Wait for end of "CMD\r\n" - we don't check for full "CMD\r\n" string because we may 
450:               		//miss some bits or bytes at the beginning while the UART starts up
451:               		StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
0019F2  20FA01     MOV #0xFA0, W1
0019F4  B3C020     MOV.B #0x2, W0
0019F6  070592     RCALL StartTimer
452:               		while (UART_ReadRxBuffer() != '\n') {
0019FA  370004     BRA 0x1A04
001A04  0703B2     RCALL UART_ReadRxBuffer
001A06  504FEA     SUB.B W0, #0xA, [W15]
001A08  3AFFF9     BRA NZ, 0x19FC
453:               			if (TimerDone(TMR_RN_COMMS)) //Check if timed out
0019F8  B3C028     MOV.B #0x2, W8
0019FC  784008     MOV.B W8, W0
0019FE  070594     RCALL TimerDone
001A00  E00400     CP0.B W0
001A02  3A002B     BRA NZ, 0x1A5A
454:               			{
455:               				return false;
001A5A  EB4000     CLR.B W0
456:               			}
457:               		}
458:               
459:               		BT_SendCommand("I\r", false); // MLDP mode
001A0A  EB4080     CLR.B W1
001A0C  294810     MOV #0x9481, W0
001A0E  07FE6D     RCALL BT_SendCommand
460:               		BT_SendCommand("A\r", false); // start advertising
001A10  EB4080     CLR.B W1
001A12  294840     MOV #0x9484, W0
001A14  07FE6A     RCALL BT_SendCommand
461:               
462:               		/* wait controller for power cycle/reset */
463:               		while (true) {
464:               			while (true) { // fast flash waiting for OTA
465:               				ClrWdt();
001A1A  FE6000     CLRWDT
466:               				while (UART_IsNewRxData()) { //While buffer contains old data
001A1E  370006     BRA 0x1A2C
001A2C  070395     RCALL UART_IsNewRxData
001A2E  E00400     CP0.B W0
001A30  3AFFF7     BRA NZ, 0x1A20
467:               					UART_ReadRxBuffer(); //Keep reading until empty
001A20  0703A4     RCALL UART_ReadRxBuffer
468:               					if (!UART_IsNewRxData()) {
001A22  07039A     RCALL UART_IsNewRxData
001A24  E00400     CP0.B W0
001A26  3A0002     BRA NZ, 0x1A2C
469:               						WaitMs(200);
001A1C  200C88     MOV #0xC8, W8
001A28  780008     MOV W8, W0
001A2A  070587     RCALL WaitMs
470:               					}
471:               				}
472:               				WaitMs(200);
001A32  200C80     MOV #0xC8, W0
001A34  070582     RCALL WaitMs
473:               				SLED = !SLED;
001A16  240009     MOV #0x4000, W9
001A18  2BFFFA     MOV #0xBFFF, W10
001A36  801661     MOV LATB, W1
001A38  648001     AND W9, W1, W0
001A3A  E90000     DEC W0, W0
001A3C  DE004F     LSR W0, #15, W0
001A3E  DD004E     SL W0, #14, W0
001A40  801662     MOV LATB, W2
001A42  650082     AND W10, W2, W1
001A44  700081     IOR W0, W1, W1
001A46  881661     MOV W1, LATB
474:               			}
001A48  37FFE8     BRA 0x1A1A
475:               
476:               		}
477:               
478:               	}
479:               	BT_OTA_UPD_TRIS = 0;
001A4A  A962C8     BCLR TRISB, #3
480:               
481:               	return BT_CheckResponse("MD\r\n"); //Check that we received CMD indicating reboot is done	
001A4C  294870     MOV #0x9487, W0
001A4E  07FEA8     RCALL BT_CheckResponse
001A50  370005     BRA 0x1A5C
482:               }
001A5C  78054F     MOV [--W15], W10
001A5E  BE044F     MOV.D [--W15], W8
001A60  060000     RETURN
483:               
484:               #ifdef VERIFY_RN_FW_VER
485:               //Retrieve firmware version on module and check against the required version
486:               //Returns true if version is correct; false if not or communication failure
487:               
488:               uint16_t BT_CheckFwVer(void)
489:               {
001A62  FA007E     LNK #0x7E
001A64  781F88     MOV W8, [W15++]
490:               	char fpVer[20];
491:               	char *pfpVer = fpVer;
492:               	char strVer[100];
493:               	char *pstrVer = strVer;
001AB4  4700F4     ADD W14, #0x14, W1
001AB6  370001     BRA 0x1ABA
001AB8  4700F4     ADD W14, #0x14, W1
494:               	uint16_t verMajor,
495:               		verMinor,
496:               		verPatch;
497:               
498:               	//flush UART RX buffer just in case there's old data
499:               	while (UART_IsNewRxData()) { //While buffer contains old data
001A68  370003     BRA 0x1A70
001A70  070373     RCALL UART_IsNewRxData
001A72  E00400     CP0.B W0
001A74  3AFFFA     BRA NZ, 0x1A6A
500:               		UART_ReadRxBuffer(); //Keep reading until empty
001A6A  07037F     RCALL UART_ReadRxBuffer
501:               		WaitMs(100);
001A66  200648     MOV #0x64, W8
001A6C  780008     MOV W8, W0
001A6E  070565     RCALL WaitMs
502:               	}
503:               
504:               	StartTimer(TMR_RN_COMMS, 2000);
001A76  207D01     MOV #0x7D0, W1
001A78  B3C020     MOV.B #0x2, W0
001A7A  070550     RCALL StartTimer
505:               	BT_SendCommand("v\r", false); // Get firmware ver
001A7C  EB4080     CLR.B W1
001A7E  2948C0     MOV #0x948C, W0
001A80  07FE34     RCALL BT_SendCommand
506:               	while (!BT_ReceivePacket(strVer)) {
001A84  370004     BRA 0x1A8E
001A8E  470074     ADD W14, #0x14, W0
001A90  07FDFD     RCALL BT_ReceivePacket
001A92  E00400     CP0.B W0
001A94  32FFF8     BRA Z, 0x1A86
507:               		if (TimerDone(TMR_RN_COMMS)) {
001A82  B3C028     MOV.B #0x2, W8
001A86  784008     MOV.B W8, W0
001A88  07054F     RCALL TimerDone
001A8A  E00400     CP0.B W0
001A8C  3A0040     BRA NZ, 0x1B0E
508:               			return false;
001B0E  EB0000     CLR W0
001B10  370001     BRA 0x1B14
509:               		}
510:               	}
511:               
512:               	//Skip to first digit
513:               	while ((*pstrVer < '0' || *pstrVer > '9') && *pstrVer != NULL) {
001A96  90504E     MOV.B [W14+20], W0
001A98  B3CD01     MOV.B #0xD0, W1
001A9A  404081     ADD.B W0, W1, W1
001A9C  50CFE9     SUB.B W1, #0x9, [W15]
001A9E  36000A     BRA LEU, 0x1AB4
001AA0  E00400     CP0.B W0
001AA2  32000A     BRA Z, 0x1AB8
001AA4  470075     ADD W14, #0x15, W0
001AA6  B3CD04     MOV.B #0xD0, W4
001AA8  780080     MOV W0, W1
001AAA  784130     MOV.B [W0++], W2
001AAC  414184     ADD.B W2, W4, W3
001AAE  51CFE9     SUB.B W3, #0x9, [W15]
001AB0  3E0008     BRA GTU, 0x1AC2
001AB2  370003     BRA 0x1ABA
001ABA  78028E     MOV W14, W5
001AC2  E00402     CP0.B W2
001AC4  3AFFF1     BRA NZ, 0x1AA8
001AC6  37FFF9     BRA 0x1ABA
514:               		pstrVer++;
515:               	}
516:               	//Extract version number
517:               	while ((*pstrVer >= '0' && *pstrVer <= '9') || *pstrVer == '.') {
001ABC  B3CD03     MOV.B #0xD0, W3
001ABE  B3C2E4     MOV.B #0x2E, W4
001AC0  370004     BRA 0x1ACA
001ACA  784031     MOV.B [W1++], W0
001ACC  404103     ADD.B W0, W3, W2
001ACE  514FE9     SUB.B W2, #0x9, [W15]
001AD0  36FFFB     BRA LEU, 0x1AC8
001AD2  504F84     SUB.B W0, W4, [W15]
001AD4  32FFF9     BRA Z, 0x1AC8
518:               		*pfpVer = *pstrVer;
001AC8  785A80     MOV.B W0, [W5++]
519:               		pfpVer++;
520:               		pstrVer++;
521:               	}
522:               	*pfpVer = '\0';
001AD6  EB4A80     CLR.B [W5]
523:               
524:               	//Tokenize and convert to unsigned
525:               	sscanf(fpVer, "%u.%u.%u", &verMajor, &verMinor, &verPatch);
001AD8  2007C0     MOV #0x7C, W0
001ADA  471F80     ADD W14, W0, [W15++]
001ADC  2007A1     MOV #0x7A, W1
001ADE  471F81     ADD W14, W1, [W15++]
001AE0  500064     SUB W0, #0x4, W0
001AE2  471F80     ADD W14, W0, [W15++]
001AE4  2948F0     MOV #0x948F, W0
001AE6  781F80     MOV W0, [W15++]
001AE8  78000E     MOV W14, W0
001AEA  07F486     RCALL 0x3F8
526:               
527:               	//Verify version number
528:               	if ((verMajor != RN_FW_VER_MAJOR133) && (verMajor != RN_FW_VER_MAJOR)) {
001AEC  5787E8     SUB W15, #0x8, W15
001AF0  9038CE     MOV [W14+120], W1
001AF2  508FE1     SUB W1, #0x1, [W15]
001AF4  3A000F     BRA NZ, 0x1B14
529:               		return false;
001AEE  EB0000     CLR W0
530:               	}
531:               	if ((verMinor != RN_FW_VER_MINOR133) && (verMinor != RN_FW_VER_MINOR)) {
001AF6  90385E     MOV [W14+122], W0
001AF8  200211     MOV #0x21, W1
001AFA  500F81     SUB W0, W1, [W15]
001AFC  320002     BRA Z, 0x1B02
001AFE  500FF7     SUB W0, #0x17, [W15]
001B00  3A0008     BRA NZ, 0x1B12
532:               		return false;
001B12  EB0000     CLR W0
533:               	}
534:               	if ((verPatch != RN_FW_VER_PATCH133) && (verPatch != RN_FW_VER_PATCH)) {
001B02  9038EE     MOV [W14+124], W1
001B04  5080E4     SUB W1, #0x4, W1
001B06  508FE1     SUB W1, #0x1, [W15]
001B08  360005     BRA LEU, 0x1B14
535:               		return false;
001B0A  EB0000     CLR W0
001B0C  370003     BRA 0x1B14
536:               	}
537:               
538:               	return verMinor;
539:               }
001B14  78044F     MOV [--W15], W8
001B16  FA8000     ULNK
001B18  060000     RETURN
540:               #endif //VERIFY_RN_FW_VER
---  /sdd/work/fac_relay_clone/app.c  -------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        app.c
29:                 * Date:        July 24, 2014
30:                 * Compiler:    XC16 v1.23
31:                 *
32:                 */
33:                
34:                // *****************************************************************************
35:                // *****************************************************************************
36:                // Section: Included Files
37:                // *****************************************************************************
38:                // *****************************************************************************
39:                
40:                #include <xc.h>
41:                #include <stdint.h>
42:                #include <stdbool.h>
43:                #include <stdio.h>
44:                #include <string.h>
45:                #include "app.h"
46:                #include "config.h"
47:                #include "timers.h"
48:                #include "uart.h"
49:                #include "bluetooth.h"
50:                #include "adc.h"
51:                #include "leds.h"
52:                #include "switches.h"
53:                #include "comparator.h"
54:                #include "rtcc.h"
55:                #include "sleep.h"
56:                #include "spi.h"
57:                
58:                APP_DATA appData;
59:                ADC_DATA adcData;
60:                
61:                //Primary application state machine
62:                
63:                void APP_Tasks(void)
64:                {
65:                #ifdef USE_SLEEP                //see config.h, Application setting section
66:                	APP_STATE_T savedState;
67:                	int16_t potDiff;
68:                
69:                	//Has inactivity timer expired?
70:                	if (appData.sleepFlag) {
71:                		savedState = appData.state; //Save context
72:                		appData.state = APP_SLEEP; //Enter sleep state
73:                	}
74:                #endif
75:                
76:                	//Update LED outputs
77:                	LED_Tasks();
001D08  070153     RCALL LED_Tasks
78:                
79:                	//Time to check battery/input voltage?
80:                	if (TimerDone(TMR_BAT_CHECK) && appData.state != APP_INITIALIZE) {
001D0A  B3C0A0     MOV.B #0xA, W0
001D0C  07040D     RCALL TimerDone
001D0E  E00400     CP0.B W0
001D10  320006     BRA Z, 0x1D1E
001D12  E20A0C     CP0 appData
001D14  32000D     BRA Z, 0x1D30
81:                		StartTimer(TMR_BAT_CHECK, CMP_Tasks()); //Run tasks and restart timer
001D16  070454     RCALL CMP_Tasks
001D18  780080     MOV W0, W1
001D1A  B3C0A0     MOV.B #0xA, W0
001D1C  0703FF     RCALL StartTimer
82:                	}
83:                
84:                	switch (appData.state) {
001D1E  805060     MOV appData, W0
001D20  500FE1     SUB W0, #0x1, [W15]
001D22  32000F     BRA Z, 0x1D42
001D24  390005     BRA NC, 0x1D30
001D26  500FE2     SUB W0, #0x2, [W15]
001D28  32000F     BRA Z, 0x1D48
001D2A  500FE3     SUB W0, #0x3, [W15]
001D2C  3A007F     BRA NZ, 0x1E2C
001D2E  370013     BRA 0x1D56
85:                		//Initial state
86:                	case APP_INITIALIZE:
87:                		if (APP_Initialize()) {
001D30  07FF8B     RCALL APP_Initialize
001D32  E00400     CP0.B W0
001D34  320003     BRA Z, 0x1D3C
88:                			appData.state = APP_BLUETOOTH_ADVERTISE;
001D36  200020     MOV #0x2, W0
001D38  885060     MOV W0, appData
001D3A  370078     BRA 0x1E2C
89:                		} else {
90:                			appData.state = APP_INITIALIZATION_ERROR;
001D3C  200010     MOV #0x1, W0
001D3E  885060     MOV W0, appData
001D40  370075     BRA 0x1E2C
91:                		}
92:                		break;
93:                
94:                		//Initialization failed
95:                	case APP_INITIALIZATION_ERROR:
96:                		LED_SET_LightShow(LED_ERROR);
001D42  200030     MOV #0x3, W0
001D44  0701C7     RCALL LED_SET_LightShow
97:                		break;
001D46  370072     BRA 0x1E2C
98:                
99:                		//We're not connected to a device - advertise mode
100:               	case APP_BLUETOOTH_ADVERTISE:
101:               		LED_SET_LightShow(LED_BTLE_ADVERTISING);
001D48  200010     MOV #0x1, W0
001D4A  0701C4     RCALL LED_SET_LightShow
102:               		if (BT_CONNECTED) {
001D4C  AB22C2     BTST PORTA, #1
001D4E  32006E     BRA Z, 0x1E2C
103:               			appData.state = APP_BLUETOOTH_PAIRED;
001D50  200030     MOV #0x3, W0
001D52  885060     MOV W0, appData
001D54  37006B     BRA 0x1E2C
104:               		}
105:               		break;
106:               
107:               		//We are connected to a BTLE device
108:               	case APP_BLUETOOTH_PAIRED:
109:               		//Update LEDs
110:               		LED_SET_LightShow(LED_BTLE_PAIRED);
001D56  200020     MOV #0x2, W0
001D58  0701BD     RCALL LED_SET_LightShow
111:               		//Check to see if we are still connected; return to advertise state if not
112:               		if (!BT_CONNECTED) {
001D5A  AB22C2     BTST PORTA, #1
001D5C  3A0005     BRA NZ, 0x1D68
113:               			LED_SET_LightShow(LED_BTLE_ADVERTISING);
001D5E  200010     MOV #0x1, W0
001D60  0701B9     RCALL LED_SET_LightShow
114:               			appData.state = APP_BLUETOOTH_ADVERTISE;
001D62  200020     MOV #0x2, W0
001D64  885060     MOV W0, appData
115:               			break;
001D66  370062     BRA 0x1E2C
116:               		}
117:               
118:               		//Check if switches have changed and debounce timers are expired
119:               		Switch_Tasks();
001D68  070404     RCALL Switch_Tasks
120:               		if (appData.sendSwitches) { //New switch status to send?
001D6A  E24AD7     CP0.B 0xAD7
001D6C  32001A     BRA Z, 0x1DA2
121:               			//Form message
122:               			sprintf(appData.transmit_packet, "suw,"PRIVATE_CHAR_SWITCHES",%d%d%d%d\r", appData.sw1, appData.sw2, appData.sw3, appData.sw4);
001D6E  20AE33     MOV #0xAE3, W3
001D70  784193     MOV.B [W3], W3
001D72  20AE22     MOV #0xAE2, W2
001D74  784112     MOV.B [W2], W2
001D76  20AE11     MOV #0xAE1, W1
001D78  784091     MOV.B [W1], W1
001D7A  BFCAE0     MOV.B 0xAE0, WREG
001D7C  FB8183     ZE W3, W3
001D7E  781F83     MOV W3, [W15++]
001D80  FB8102     ZE W2, W2
001D82  781F82     MOV W2, [W15++]
001D84  FB8081     ZE W1, W1
001D86  781F81     MOV W1, [W15++]
001D88  FB8000     ZE W0, W0
001D8A  781F80     MOV W0, [W15++]
001D8C  296160     MOV #0x9616, W0
001D8E  781F80     MOV W0, [W15++]
001D90  20A720     MOV #0xA72, W0
001D92  07F4E9     RCALL 0x766
123:               			//Try to transmit the message; reset flag if successful
124:               			if (BT_SendCommand(appData.transmit_packet, true)) {
001D94  B3C011     MOV.B #0x1, W1
001D96  20A720     MOV #0xA72, W0
001D98  07FCA8     RCALL BT_SendCommand
001D9A  5787EA     SUB W15, #0xA, W15
001D9C  E00400     CP0.B W0
001D9E  320001     BRA Z, 0x1DA2
125:               				appData.sendSwitches = false;
001DA0  EF6AD7     CLR.B 0xAD7
126:               			}
127:               		}
128:               
129:               		//Process ADC accumulator value if oversampling is complete
130:               		if (appData.accumReady) {
001DA2  E24AE9     CP0.B 0xAE9
001DA4  320003     BRA Z, 0x1DAC
131:               			ADC_ProcAccum();
001DA6  070398     RCALL ADC_ProcAccum
132:               #ifdef USE_SLEEP                //see config.h, Application setting section
133:               			potDiff = appData.potValue - appData.potValueOld; //Reset the inactivity sleep timer if pot has changed
134:               			if (potDiff > POT_KEEP_AWAKE_DELTA || potDiff < -POT_KEEP_AWAKE_DELTA) {
135:               				SleepTimerReset();
136:               			}
137:               #endif
138:               			appData.accumReady = false; //Clear app flags
001DA8  EF6AE9     CLR.B 0xAE9
139:               			appData.ADCinUse = false;
001DAA  EF6AEA     CLR.B 0xAEA
140:               		}
141:               
142:               		//Start new ADC read if timer expired, not currently sampling, and not waiting to process accumulator
143:               		if (TimerDone(TMR_ADC) && appData.ADCinUse == false) {
001DAC  B3C030     MOV.B #0x3, W0
001DAE  0703BC     RCALL TimerDone
001DB0  E00400     CP0.B W0
001DB2  320008     BRA Z, 0x1DC4
001DB4  E24AEA     CP0.B 0xAEA
001DB6  3A0006     BRA NZ, 0x1DC4
144:               			if (ADC_Tasks()) {
001DB8  070345     RCALL ADC_Tasks
001DBA  E00400     CP0.B W0
001DBC  320003     BRA Z, 0x1DC4
145:               				StartTimer(TMR_ADC, ADC_REFRESH_MS);
001DBE  200321     MOV #0x32, W1
001DC0  B3C030     MOV.B #0x3, W0
001DC2  0703AC     RCALL StartTimer
146:               			} //Restart timer once module is up and running
147:               		}
148:               
149:               		//Transmit new potentiometer reading?
150:               		if (TimerDone(TMR_POT)) {
001DC4  B3C040     MOV.B #0x4, W0
001DC6  0703B0     RCALL TimerDone
001DC8  E00400     CP0.B W0
001DCA  320017     BRA Z, 0x1DFA
151:               			//Send message only if pot value has changed
152:               			if (appData.potValue != appData.potValueLastTX) {
001DCC  805770     MOV 0xAEE, W0
001DCE  E30AF2     CP 0xAF2
001DD0  320011     BRA Z, 0x1DF4
153:               				//Form message
154:               				sprintf(appData.transmit_packet, "suw,"PRIVATE_CHAR_POTENTIOMETER",%04d\r", appData.potValue);
001DD2  781F80     MOV W0, [W15++]
001DD4  296450     MOV #0x9645, W0
001DD6  781F80     MOV W0, [W15++]
001DD8  20A720     MOV #0xA72, W0
001DDA  07F4C5     RCALL 0x766
155:               				//Try to transmit the message; reset timer if successful
156:               				if (BT_SendCommand(appData.transmit_packet, true)) {
001DDC  B3C011     MOV.B #0x1, W1
001DDE  20A720     MOV #0xA72, W0
001DE0  07FC84     RCALL BT_SendCommand
001DE2  5787E4     SUB W15, #0x4, W15
001DE4  E00400     CP0.B W0
001DE6  320009     BRA Z, 0x1DFA
157:               					appData.potValueLastTX = appData.potValue;
001DE8  F80AEE     PUSH 0xAEE
001DEA  F90AF2     POP 0xAF2
158:               					StartTimer(TMR_POT, POT_TX_MS);
001DEC  201F41     MOV #0x1F4, W1
001DEE  B3C040     MOV.B #0x4, W0
001DF0  070395     RCALL StartTimer
001DF2  370003     BRA 0x1DFA
159:               				}
160:               			} else {
161:               				StartTimer(TMR_POT, POT_TX_MS);
001DF4  201F41     MOV #0x1F4, W1
001DF6  B3C040     MOV.B #0x4, W0
001DF8  070391     RCALL StartTimer
162:               			} //value not changed - skip this transmission
163:               		}
164:               
165:               		//Process any new messages received from RN module
166:               		appData.got_packet = BT_ReceivePacket(appData.receive_packet); //Get new message if one has been received from the RN4020
001DFA  20A0E0     MOV #0xA0E, W0
001DFC  07FC47     RCALL BT_ReceivePacket
001DFE  B7EAD6     MOV.B WREG, 0xAD6
167:               		if (appData.got_packet == true) { //true if new packet received
001E00  E00400     CP0.B W0
001E02  320014     BRA Z, 0x1E2C
168:               			SPI_CS1 = 1;
001E04  A8E2CD     BSET 0x2CD, #7
169:               			if (strstr(appData.receive_packet, "WV,001E,")) { //Check for LED update message 1.23
001E06  296701     MOV #0x9670, W1
001E08  20A0E0     MOV #0xA0E, W0
001E0A  07F2D3     RCALL 0x3B2
001E0C  E00000     CP0 W0
001E0E  320001     BRA Z, 0x1E12
170:               				GetNewLEDs(); //Latch new LED values
001E10  070163     RCALL GetNewLEDs
171:               			}
172:               			if (strstr(appData.receive_packet, "WV,0021,")) { //Check for LED update message 1.33
001E12  296791     MOV #0x9679, W1
001E14  20A0E0     MOV #0xA0E, W0
001E16  07F2CD     RCALL 0x3B2
001E18  E00000     CP0 W0
001E1A  320001     BRA Z, 0x1E1E
173:               				GetNewLEDs(); //Latch new LED values
001E1C  07015D     RCALL GetNewLEDs
174:               			}
175:               			//
176:               			//Other message handling can be added here
177:               			//
178:               			//receive new SPI ADC channel
179:               			if (strstr(appData.receive_packet, "WV,0025,")) {
001E1E  296821     MOV #0x9682, W1
001E20  20A0E0     MOV #0xA0E, W0
001E22  07F2C7     RCALL 0x3B2
001E24  E00000     CP0 W0
001E26  320001     BRA Z, 0x1E2A
180:               				GetNewADC_Chan(); // new ADC config data
001E28  07035E     RCALL GetNewADC_Chan
181:               			}
182:               			//receive new SPI SLAVE request
183:               			if (strstr(appData.receive_packet, "WV,0027,")) {
184:               
185:               			}
186:               			SPI_CS1 = 0;
001E2A  A9E2CD     BCLR 0x2CD, #7
187:               		}
188:               		break;
189:               
190:               #ifdef USE_SLEEP                //see config.h, Application setting section        
191:               		//Put micro and RN module to sleep - any button press will cause wake up
192:               	case APP_SLEEP:
193:               		appData.sleepFlag = 0; //clear flag and call sleep function
194:               		APP_SleepNow();
195:               		appData.state = savedState; //Woken from sleep; restore state
196:               		break;
197:               #endif //USE_SLEEP
198:               
199:               	default:
200:               		break;
201:               	} //end switch(appData.state)
202:               } //end APP_Tasks()
001E2C  060000     RETURN
203:               
204:               //Sets up the RN module
205:               
206:               bool APP_Initialize(void)
207:               {
001C48  781F88     MOV W8, [W15++]
208:               	/****************************************************************************
209:               	 * Initialize appData structure
210:               	 ***************************************************************************/
211:               	appData.error_code = ERROR_NONE;
001C4A  B3C010     MOV.B #0x1, W0
001C4C  B7EADF     MOV.B WREG, 0xADF
212:               	appData.got_packet = false;
001C4E  EF6AD6     CLR.B 0xAD6
213:               	appData.potValue = 0;
001C50  EF2AEE     CLR 0xAEE
214:               	appData.potValueOld = 0xFFFF;
001C52  EB8000     SETM W0
001C54  885780     MOV W0, 0xAF0
215:               	appData.potValueLastTX = 0xFFFF;
001C56  885790     MOV W0, 0xAF2
216:               	appData.state = APP_INITIALIZE;
001C58  EF2A0C     CLR appData
217:               	appData.sw1 = false;
001C5A  EF6AE0     CLR.B 0xAE0
218:               	appData.sw2 = false;
001C5C  EF6AE1     CLR.B 0xAE1
219:               	appData.sw3 = false;
001C5E  EF6AE2     CLR.B 0xAE2
220:               	appData.sw4 = false;
001C60  EF6AE3     CLR.B 0xAE3
221:               	appData.led1 = 0;
001C62  EF6AD9     CLR.B 0xAD9
222:               	appData.led2 = 0;
001C64  EF6ADA     CLR.B 0xADA
223:               	appData.led3 = 0;
001C66  EF6ADB     CLR.B 0xADB
224:               	appData.led4 = 0;
001C68  EF6ADC     CLR.B 0xADC
225:               	appData.led5 = 0;
001C6A  EF6ADD     CLR.B 0xADD
226:               	appData.led6 = 0;
001C6C  EF6ADE     CLR.B 0xADE
227:               	appData.sw1Changed = false;
001C6E  EF6AE4     CLR.B 0xAE4
228:               	appData.sw2Changed = false;
001C70  EF6AE5     CLR.B 0xAE5
229:               	appData.sw3Changed = false;
001C72  EF6AE6     CLR.B 0xAE6
230:               	appData.sw4Changed = false;
001C74  EF6AE7     CLR.B 0xAE7
231:               	appData.sendSwitches = false;
001C76  EF6AD7     CLR.B 0xAD7
232:               	appData.ADCcalFlag = false;
001C78  EF6AD8     CLR.B 0xAD8
233:               	appData.sleepFlag = false;
001C7A  EF6AED     CLR.B 0xAED
234:               	appData.RTCCalarm = false;
001C7C  EF6AE8     CLR.B 0xAE8
235:               	appData.accumReady = false;
001C7E  EF6AE9     CLR.B 0xAE9
236:               	appData.ADCinUse = false;
001C80  EF6AEA     CLR.B 0xAEA
237:               	appData.timer1Flag = false;
001C82  EF6AEB     CLR.B 0xAEB
238:               
239:               	/****************************************************************************
240:               	 * Peripherals Init
241:               	 ***************************************************************************/
242:               	ADC_Init(); //Initialize the pADC
001C84  0703CF     RCALL ADC_Init
243:               	UART_Init(); //Initialize the UART
001C86  070252     RCALL UART_Init
244:               	Timers_Init(); //Initialize the timers
001C88  07043E     RCALL Timers_Init
245:               	CMP_Init(); //Initialize CVref and CMP2
001C8A  07049C     RCALL CMP_Init
246:               	SPI_Init();
001C8C  0700D0     RCALL SPI_Init
247:               
248:               #ifdef USE_SLEEP            //see config.h, Application settings section
249:               #ifdef SLEEP_MODE_RTCC
250:               	RTCC_Init();
251:               #endif  //SLEEP_MODE_RTCC
252:               #endif  //USE_SLEEP
253:               
254:               	BT_WAKE_SW = 1; //wake module
001C8E  A862CD     BSET 0x2CD, #3
255:               	//Wait for WS status high
256:               	StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
001C90  20FA01     MOV #0xFA0, W1
001C92  B3C020     MOV.B #0x2, W0
001C94  070443     RCALL StartTimer
257:               	while (BT_WS == 0) {
001C98  370008     BRA 0x1CAA
001CAA  AB42C2     BTST PORTA, #2
001CAC  32FFF6     BRA Z, 0x1C9A
258:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001C96  B3C028     MOV.B #0x2, W8
001C9A  784008     MOV.B W8, W0
001C9C  070445     RCALL TimerDone
001C9E  E00400     CP0.B W0
001CA0  320004     BRA Z, 0x1CAA
259:               		{
260:               			appData.error_code = ERROR_INITIALIZATION;
001CA2  B3CFE0     MOV.B #0xFE, W0
001CA4  B7EADF     MOV.B WREG, 0xADF
261:               			return false;
001CA6  EB4000     CLR.B W0
001CA8  37002D     BRA 0x1D04
262:               		}
263:               	}
264:               
265:               	//Wait for end of "CMD\r\n" - we don't check for full "CMD\r\n" string because we may 
266:               	//miss some bits or bytes at the beginning while the UART starts up
267:               	StartTimer(TMR_RN_COMMS, 4000); //Start 4s timeout
001CAE  20FA01     MOV #0xFA0, W1
001CB0  B3C020     MOV.B #0x2, W0
001CB2  070434     RCALL StartTimer
268:               	while (UART_ReadRxBuffer() != '\n') {
001CB6  370008     BRA 0x1CC8
001CC8  070250     RCALL UART_ReadRxBuffer
001CCA  504FEA     SUB.B W0, #0xA, [W15]
001CCC  3AFFF5     BRA NZ, 0x1CB8
269:               		if (TimerDone(TMR_RN_COMMS)) //Check if timed out
001CB4  B3C028     MOV.B #0x2, W8
001CB8  784008     MOV.B W8, W0
001CBA  070436     RCALL TimerDone
001CBC  E00400     CP0.B W0
001CBE  320004     BRA Z, 0x1CC8
270:               		{
271:               			appData.error_code = ERROR_INITIALIZATION;
001CC0  B3CFE0     MOV.B #0xFE, W0
001CC2  B7EADF     MOV.B WREG, 0xADF
272:               			return false;
001CC4  EB4000     CLR.B W0
001CC6  37001E     BRA 0x1D04
273:               		}
274:               	}
275:               
276:               	//Module is now in command mode and ready for input
277:               	if (!BT_SetupModule()) { //Setup RN4020 module
001CCE  07FF25     RCALL BT_SetupModule
001CD0  E00400     CP0.B W0
001CD2  3A0004     BRA NZ, 0x1CDC
278:               		appData.error_code = ERROR_INITIALIZATION;
001CD4  B3CFE0     MOV.B #0xFE, W0
001CD6  B7EADF     MOV.B WREG, 0xADF
279:               		return false;
001CD8  EB4000     CLR.B W0
001CDA  370014     BRA 0x1D04
280:               	}
281:               
282:               #ifdef VERIFY_RN_FW_VER
283:               	//Verify RN4020 module's firmware version
284:               	if (!(appData.version_code = BT_CheckFwVer())) {
001CDC  07FEC2     RCALL BT_CheckFwVer
001CDE  8857A0     MOV W0, 0xAF4
001CE2  E00000     CP0 W0
001CE4  3A000A     BRA NZ, 0x1CFA
285:               		appData.error_code = ERROR_RN_FW;
001CE6  B3CFD0     MOV.B #0xFD, W0
001CE8  B7EADF     MOV.B WREG, 0xADF
286:               		return false;
001CEA  EB4000     CLR.B W0
001CEC  37000B     BRA 0x1D04
287:               	}
288:               #endif // VERIFY_RN_FW_VER 
289:               
290:               	//flush UART RX buffer as a precaution before starting app state machine
291:               	while (UART_IsNewRxData()) { //While buffer contains old data
001CFA  07022E     RCALL UART_IsNewRxData
001CFC  E00400     CP0.B W0
001CFE  3AFFF7     BRA NZ, 0x1CEE
292:               		UART_ReadRxBuffer(); //Keep reading until empty
001CEE  07023D     RCALL UART_ReadRxBuffer
293:               		if (!UART_IsNewRxData()) {
001CF0  070233     RCALL UART_IsNewRxData
001CF2  E00400     CP0.B W0
001CF4  3A0002     BRA NZ, 0x1CFA
294:               			WaitMs(100);
001CE0  200648     MOV #0x64, W8
001CF6  780008     MOV W8, W0
001CF8  070420     RCALL WaitMs
295:               		}
296:               	}
297:               
298:               	SLED = 1; // init completed
001D00  A8C2CD     BSET 0x2CD, #6
299:               	return true;
001D02  B3C010     MOV.B #0x1, W0
300:               }
001D04  78044F     MOV [--W15], W8
001D06  060000     RETURN
---  /sdd/work/fac_relay_clone/adc.c  -------------------------------------------------------------------
1:                 /*
2:                  * Copyright (C) 2014 Microchip Technology Inc. and its subsidiaries.  You may use this software and any derivatives
3:                  * exclusively with Microchip products.
4:                  *
5:                  * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any derivatives created by any person or
6:                  * entity by or on your behalf, exclusively with Microchip?s products.  Microchip and its licensors retain all ownership
7:                  * and intellectual property rights in the accompanying software and in all derivatives hereto.
8:                  *
9:                  * This software and any accompanying information is for suggestion only.  It does not modify Microchip?s standard
10:                 * warranty for its products.  You agree that you are solely responsible for testing the software and determining its
11:                 * suitability.  Microchip has no obligation to modify, test, certify, or support the software.
12:                 *
13:                 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,
14:                 * BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
15:                 * APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP?S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN
16:                 * ANY APPLICATION.
17:                 *
18:                 * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
19:                 * STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
20:                 * EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
21:                 * SOFTWARE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
22:                 * TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
23:                 * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:                 *
25:                 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE TERMS.
26:                 *
27:                 *
28:                 * File:        adc.c
29:                 * Date:        January 20, 2015
30:                 * Compiler:    XC16 v1.23
31:                 * modified for MCP3208 device Nov 2016
32:                 *
33:                 *
34:                 */
35:                
36:                #include <xc.h>
37:                #include <stdint.h>
38:                #include <stdbool.h>
39:                #include "adc.h"
40:                #include "spi.h"
41:                #include "app.h"
42:                #include "config.h"
43:                #include "timers.h"
44:                
45:                extern APP_DATA appData;
46:                extern ADC_DATA adcData;
47:                
48:                /******************************************************************************
49:                 * Function:        void ADC_Init()
50:                 *
51:                 * PreCondition:    None
52:                 *
53:                 * Input:           None
54:                 *
55:                 * Output:          None
56:                 *
57:                 * Side Effects:    None
58:                 *
59:                 * Overview:        This routine initializes the ADC 
60:                 *                 
61:                 * Note:
62:                 *
63:                 *****************************************************************************/
64:                
65:                void ADC_Init()
66:                {
67:                	adcData.mcp3208_cmd.ld = 0; // clear the command word
002424  20AF60     MOV #0xAF6, W0
002426  EB0800     CLR [W0]
002428  781030     MOV [W0++], [W0--]
68:                	adcData.chan = 0;
00242A  EB4080     CLR.B W1
00242C  984061     MOV.B W1, [W0+6]
69:                	adcData.mcp3208_cmd.map.start_bit = 1;
00242E  900090     MOV [W0+2], W1
70:                	adcData.mcp3208_cmd.map.single_diff = 1;
002430  B30061     IOR #0x6, W1
71:                	adcData.mcp3208_cmd.map.index = 0; // channel
002432  23FFF2     MOV #0x3FFF, W2
002434  610810     AND W2, [W0], [W0]
002436  A10001     BCLR W1, #0
002438  980011     MOV W1, [W0+2]
72:                	appData.ADCcalFlag = true;
00243A  B3C010     MOV.B #0x1, W0
00243C  B7EAD8     MOV.B WREG, 0xAD8
73:                	SPI_CS0 = 1;
00243E  A862C4     BSET LATA, #3
74:                	SPI_CS1 = 1;
002440  A8E2CD     BSET 0x2CD, #7
75:                }
002442  060000     RETURN
76:                
77:                //State machine for restarting ADC and taking new readings from pot
78:                //Returns true when SPI data has been returned from the mpc3208; false otherwise
79:                
80:                bool ADC_Tasks(void)
81:                {
002444  BE9F88     MOV.D W8, [W15++]
82:                	static uint8_t count = 0;
83:                
84:                	/* send the command sequence to the adc */
85:                	if (!adcData.mcp3208_cmd.map.in_progress) {
002446  AB8AF9     BTST 0xAF9, #4
002448  3A003A     BRA NZ, 0x24BE
86:                		adcData.mcp3208_cmd.map.in_progress = true;
00244A  20AF61     MOV #0xAF6, W1
00244C  900011     MOV [W1+2], W0
00244E  A0C000     BSET W0, #12
87:                		adcData.mcp3208_cmd.map.finish = false;
002450  A1B000     BCLR W0, #11
002452  980090     MOV W0, [W1+2]
88:                		count = 0;
002454  EF6BA6     CLR.B count
89:                		if (SPI_GetTXBufferFreeSpace() > 8) {
002456  07FD58     RCALL SPI_GetTXBufferFreeSpace
002458  780080     MOV W0, W1
00245C  508FE8     SUB W1, #0x8, [W15]
00245E  36003A     BRA LEU, 0x24D4
90:                			adcData.mcp3208_cmd.map.single_diff = 1;
002460  20AF68     MOV #0xAF6, W8
002462  900018     MOV [W8+2], W0
002464  A01000     BSET W0, #1
91:                			adcData.mcp3208_cmd.map.index = adcData.chan;
002466  9000B8     MOV [W8+6], W1
002468  DD094E     SL W1, #14, W2
00246A  23FFF3     MOV #0x3FFF, W3
00246C  618198     AND W3, [W8], W3
00246E  718C02     IOR W3, W2, [W8]
002470  DE08C2     LSR W1, #2, W1
002472  6080E1     AND W1, #0x1, W1
002474  A10000     BCLR W0, #0
002476  708000     IOR W1, W0, W0
002478  980410     MOV W0, [W8+2]
92:                			SPI_ClearBufs(); // dump the spi buffers
00247A  07FCF6     RCALL SPI_ClearBufs
93:                			SPI_WriteTxBuffer(adcData.mcp3208_cmd.bd[2]);
00247C  904028     MOV.B [W8+2], W0
00247E  07FD35     RCALL SPI_WriteTxBuffer
94:                			SPI_WriteTxBuffer(adcData.mcp3208_cmd.bd[1]);
002480  904018     MOV.B [W8+1], W0
002482  07FD33     RCALL SPI_WriteTxBuffer
95:                			SPI_WriteTxBuffer(adcData.mcp3208_cmd.bd[0]);
002484  784018     MOV.B [W8], W0
002486  07FD31     RCALL SPI_WriteTxBuffer
96:                			SPI_CS0 = 0; // select the ADC
002488  A962C4     BCLR LATA, #3
97:                			SPI_TxStart();
00248A  07FCF9     RCALL SPI_TxStart
98:                		}
99:                		return false;
00245A  EB4000     CLR.B W0
00248C  EB4000     CLR.B W0
00248E  370022     BRA 0x24D4
100:               	}
101:               
102:               	/* read the returned spi data from the buffer and format it */
103:               	if (adcData.mcp3208_cmd.map.in_progress) {
104:               		while (SPI_IsNewRxData()) {
0024BE  07FCF2     RCALL SPI_IsNewRxData
0024C0  E00400     CP0.B W0
0024C2  3AFFE6     BRA NZ, 0x2490
105:               			switch (count) {
002490  BFCBA6     MOV.B count, WREG
002492  504FE1     SUB.B W0, #0x1, [W15]
002494  320003     BRA Z, 0x249C
002496  504FE2     SUB.B W0, #0x2, [W15]
002498  3A0010     BRA NZ, 0x24BA
00249A  370005     BRA 0x24A6
106:               			case 1:
107:               				adcData.potValue = (SPI_ReadRxBuffer()&0x0f) << 8;
00249C  07FD0C     RCALL SPI_ReadRxBuffer
00249E  60006F     AND W0, #0xF, W0
0024A0  DD0048     SL W0, #8, W0
0024A2  8857D0     MOV W0, 0xAFA
108:               				break;
0024A4  37000B     BRA 0x24BC
109:               			case 2:
110:               				adcData.potValue += SPI_ReadRxBuffer();
0024A6  20AF68     MOV #0xAF6, W8
0024A8  9004A8     MOV [W8+4], W9
0024AA  07FD05     RCALL SPI_ReadRxBuffer
0024AC  FB8000     ZE W0, W0
0024AE  400489     ADD W0, W9, W9
0024B0  980429     MOV W9, [W8+4]
111:               				adcData.mcp3208_cmd.map.finish = true;
0024B2  900018     MOV [W8+2], W0
0024B4  A0B000     BSET W0, #11
0024B6  980410     MOV W0, [W8+2]
112:               				break;
0024B8  370001     BRA 0x24BC
113:               			default:
114:               				SPI_ReadRxBuffer(); // eat extra bytes
0024BA  07FCFD     RCALL SPI_ReadRxBuffer
115:               				break;
116:               			}
117:               			count++;
0024BC  EC6BA6     INC.B count
118:               		}
119:               	}
120:               
121:               	/* cleanup for next time */
122:               	if (adcData.mcp3208_cmd.map.finish) {
0024C4  AB6AF9     BTST 0xAF9, #3
0024C6  320006     BRA Z, 0x24D4
123:               		adcData.mcp3208_cmd.map.in_progress = false;
0024C8  20AF61     MOV #0xAF6, W1
0024CA  900011     MOV [W1+2], W0
0024CC  A1C000     BCLR W0, #12
0024CE  980090     MOV W0, [W1+2]
124:               		appData.accumReady = true;
0024D0  B3C010     MOV.B #0x1, W0
0024D2  B7EAE9     MOV.B WREG, 0xAE9
125:               		return true;
126:               	}
127:               
128:               	return false;
129:               }
0024D4  BE044F     MOV.D [--W15], W8
0024D6  060000     RETURN
130:               
131:               //Process the accumulator value once it is ready
132:               //And update stored potentiometer values
133:               
134:               void ADC_ProcAccum(void)
135:               {
136:               	appData.potValueOld = appData.potValue; //Save previous value
0024D8  F80AEE     PUSH 0xAEE
0024DA  F90AF0     POP 0xAF0
137:               	appData.potValue = adcData.potValue;
0024DC  F80AFA     PUSH 0xAFA
0024DE  F90AEE     POP 0xAEE
138:               }
0024E0  060000     RETURN
139:               
140:               //ADC ISR
141:               
142:               void _ISR_NO_AUTO_PSV _ISR _ADC1Interrupt(void)
143:               {
144:               	IFS0bits.AD1IF = 0;
0024E2  A9A085     BCLR 0x85, #5
145:               	//Accumulation complete
146:               
147:               }
0024E4  064000     RETFIE
148:               
149:               void GetNewADC_Chan(void)
150:               {
151:               	adcData.chan = appData.receive_packet[13] == '1' ? 1 : 0; // update adc channel 
0024E6  B3C310     MOV.B #0x31, W0
0024E8  20A1B2     MOV #0xA1B, W2
0024EA  784112     MOV.B [W2], W2
0024EC  694100     XOR.B W2, W0, W2
0024EE  FB8102     ZE W2, W2
0024F0  E90102     DEC W2, W2
0024F2  DE114F     LSR W2, #15, W2
152:               	adcData.chan += appData.receive_packet[15] == '1' ? 2 : 0;
0024F4  EB4080     CLR.B W1
0024F6  E34A1D     CP.B 0xA1D
0024F8  3A0001     BRA NZ, 0x24FC
0024FA  B3C021     MOV.B #0x2, W1
0024FC  40C082     ADD.B W1, W2, W1
0024FE  784101     MOV.B W1, W2
002500  20AFC0     MOV #0xAFC, W0
002502  784802     MOV.B W2, [W0]
153:               }
002504  060000     RETURN
